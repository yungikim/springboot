window.txEval = function(source, target) {
    if (typeof source == "function") {
        return source.call(target || this);
    } else if (typeof source == "string") {
        return (target) ? target.eval(source) : this.eval(source);
    }
};

try {
    EditorJSLoader.readyState = "loading";
} catch (s) {}

/**
 * @fileoverview
 * Trex 정의
 */

/** @namespace */
var Trex = {
    __WORD_JOINER: "\ufeff",
    __WORD_JOINER_REGEXP: /\ufeff/g,
    __KEY: {
        ENTER: '13',
        DELETE: '46',
        SPACE: '32',
        BACKSPACE: '8',
        TAB: '9',
        PASTE: '86', //+ ctrl
        CUT: '88' //+ ctrl
    },
    I: {},
    X: {},
    define: function(destination, properties) {
        return Object.extend(destination, properties);
    },
    available: function(config, name) {
        if (!$tx("tx_" + name)) {
            //console.log("Warning: JsObject is existed but element 'tx_" + name + "' is not found.");
            return _FALSE;
        }
        if (!config) {
            //console.log("Warning: no config for" + name);
            return _FALSE;
        }
        if (config.use == _FALSE) {
            //console.log("Warning: config.use == _FALSE");
            return _FALSE;
        }
        return _TRUE;
    }
};
try {
    if (EditorJSLoader.getOption('i18n')) {
        Trex._I18N_ = window[EditorJSLoader.getOption('i18n')];
    }
    Trex._I18N = {
        'g': function() {
            var args = [];
            for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
            var defaultvalue = args.pop();
            if (!Trex._I18N_ || !Trex._I18N_.words[args[0]]) return defaultvalue;
            else return Trex._I18N_.get.apply(Trex._I18N_, args);
        },
        'w': function() {
            document.write(Trex._I18N.g.apply(Trex._I18N, arguments));
        }
    };
    Trex._JS_MIN = EditorJSLoader.getOption('js_min');
} catch (s) {}

Trex._getDisplayFileSize = function(size){
    var unit = 'Kb';
    var dis = size / 1024;
    if(dis > 1024) {
        dis /= 1024;
        unit = 'Mb';
    }
    dis = Math.round(dis * 100) / 100;
    return dis + unit;
};

Trex.KEditor = {
    '_clipboardProcess': function(kEditor, e) {
        try {
            var clipData = e.clipboardData;
            if (window.FormData &&
                clipData && clipData.items && clipData.items[0]) {
                var items = clipData.items;
                var img_item = null,
                    html_item = null,
                    plain_item = null,
                    _html = null,
                    _plain = null,
                    _img = null;
                for (var i = 0; i < items.length; i++) {
                    if (items[i].kind == 'file' &&
                        items[i].type.search(/image/i) != -1) {
                        img_item = items[i];
                    } else if (items[i].kind == 'string' &&
                        items[i].type.search(/text\/html/i) != -1) {
                        html_item = items[i];
                    } else if (items[i].kind == 'string' &&
                        items[i].type.search(/text\/plain/i) != -1) {
                        plain_item = items[i];
                    }
                }
                if (html_item) _html = clipData.getData('text/html');
                if (plain_item) _plain = clipData.getData('text/plain');
                /*if (html_item != null && img_item != null) {
                    if (_html.search(/<img[^>]+src\s*=\s*["']?(?!http|\/|\.)/) == -1) {
                        img_item = null;
                    } else 
                    if (kEditor.config.confirmPasteType && !confirm(Trex._I18N.g('image_paste_confirm', "이미지로 붙여넣으시겠습니까?\n(취소를 선택하시면 로컬 이미지는 삭제됩니다.)"))) {
                        img_item = null;
                        var reg = /src\s*=\s*["']?(?!http|\/|\.)/i;
                        _html = _html.replace(/<img[^>]*>/gi, function($1) {
                            if (reg.test($1)) {
                                return '';
                            } else {
                                return $1;
                            }
                        });
                    }
                }
                
                if (img_item != null && img_item.kind == "file" &&
                    img_item.type.search(/image/i) != -1) {
                    var blob = img_item.getAsFile();
                    var result = Trex.KEditor.blobUpload(kEditor, blob);
                    if (result && result.img_src) {
                        kEditor.editor.getCanvas().execute(
                            function(processor) {
                                var _node = processor.win.img({
                                    'src': result.img_src,
                                    'border': "0",
                                    'className': ''
                                });
                                processor.pasteNode(_node, false);
                            }
                        );
                        return true;
                    }
                } else if (html_item != null && _html != _NULL) {
                    return Trex.KEditor._pasteClipboardHtml(kEditor, _html);
                }*/
                if (img_item != null && img_item.kind == "file" &&
                    img_item.type.search(/image/i) != -1) {
                    var blob = img_item.getAsFile();
                    var limit = kEditor.config.imageLimitSize||0;
                    if(blob.size && limit != 0 && limit < blob.size){
                        _img = {error:'LIMIT', 'limit':limit, 'size':blob.size};
                    }else{
                        _img = Trex.KEditor.blobUpload(kEditor, blob);
                        _img.size = blob.size;
                        if(!(_img && _img.img_src)) _img = null;
                    }
                }
                var _canvas = kEditor.editor.getCanvas();
                var range = _canvas.getProcessor().getSelectionRange(kEditor.editor.getCanvas());
                if(_html && _img && _img.error != "LIMIT"){
                    var _layer = kEditor.editor.getImagePasteLayer();                    
                    _layer.showPopup(null, 
                        {
                            'image':function(data){
                                var _canvas = kEditor.editor.getCanvas();
                                _canvas.focus();
                                _canvas.execute(
                                    function(processor) {
                                        var _node = processor.win.img({
                                            'src': data.src?data.src:_img.img_src,
                                            'border': "0",
                                            'className': ''
                                        });
                                        if(data.width != null) {
                                            _node.width = data.width;
                                            _node.style.width = data.width + 'px';
                                        }
                                        if(data.height != null) {
                                            _node.height = data.height;
                                            _node.style.height = data.height + 'px';
                                        }
                                        if(data.border) _node.style.border = data.border;
                                        // var __node = processor.pasteNode(_node, false);
                                        var __node = processor.pasteNodeCustom(_node, _canvas, range);
                                        if(data.align && __node){
                                            var _w = $tom.find(__node, "%paragraph");
                                            if(_w) _w.style.textAlign = data.align;
                                        }
                                    }
                                );
                            },
                            'html':function(_data){
                                var _canvas = kEditor.editor.getCanvas();
                                _canvas.focus();
                                Trex.KEditor._pasteClipboardHtml(kEditor, _data, range);
                            },
                            'plain':_plain?function(_data){
                                var _canvas = kEditor.editor.getCanvas();
                                _canvas.focus();                                
                                _canvas.execute(
                                    function(processor) {
                                        processor.pasteHtml(_data, _canvas, range);
                                    }
                                );
                            }:null
                        },
                        {'src':_img.img_src},
                        _html,
                        _plain, 
                        _img.size);
                    return true;
                }else if(_html){
                    return Trex.KEditor._pasteClipboardHtml(kEditor, _html, range);
                }else if(_img){
                    if(_img.error == "LIMIT"){
                        if(Trex.Image._SUPPORT_JPEG_QUALITY){
                            alert(Trex._I18N.g('image.upload_limit_canvas', Trex._getDisplayFileSize(_img.size), Trex._getDisplayFileSize(_img.limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(_img.limit)  + ').\n이미지 첨부의 JPEG 품질 기능을 사용하여 이미지를 첨부해 주세요.'));
                        }else{
                            alert(Trex._I18N.g('image.upload_limit', Trex._getDisplayFileSize(_img.size), Trex._getDisplayFileSize(_img.limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(_img.limit)  + ').'));
                        }
                    }else{
                        kEditor.editor.getCanvas().execute(
                            function(processor) {
                                var _node = processor.win.img({
                                    'src': _img.img_src,
                                    'border': "0",
                                    'className': ''
                                });
                                // processor.pasteNode(_node, false);
                                processor.pasteNodeCustom(_node, kEditor.editor.getCanvas(), range);
                            }
                        );
                    }
                    return true;
                }else{
                    return false;
                }
            } else if(clipData = window.clipboardData, clipData 
                && clipData.files && clipData.files[0] && $tx.msie && $tx.msie_ver == 11){
                // IE Clipboard에 이미지만 있는 경우 jre 통하지 않고 바로 처리함.
                var _canvas = kEditor.editor.getCanvas();
                var range = _canvas.getProcessor().getSelectionRange(kEditor.editor.getCanvas());
                var txt = clipData.getData('text');
                if(txt != null) return false;
                var item = clipData.files[0];
                if (item.type.indexOf("image") > -1) {
                    var blob = item; //.getAsFile();
                    var limit = kEditor.config.imageLimitSize||0;
                    if(blob.size && limit != 0 && limit < blob.size){
                        _img = {error:'LIMIT', 'limit':limit, 'size':blob.size};
                    }else{
                        _img = Trex.KEditor.blobUpload(kEditor, blob);
                        _img.size = blob.size;
                        if(!(_img && _img.img_src)) _img = null;
                    }
                    if(_img){
                        if(_img.error == "LIMIT"){
                            if(Trex.Image._SUPPORT_JPEG_QUALITY){
                                alert(Trex._I18N.g('image.upload_limit_canvas', Trex._getDisplayFileSize(_img.size), Trex._getDisplayFileSize(_img.limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(_img.limit)  + ').\n이미지 첨부의 JPEG 품질 기능을 사용하여 이미지를 첨부해 주세요.'));
                            }else{
                                alert(Trex._I18N.g('image.upload_limit', Trex._getDisplayFileSize(_img.size), Trex._getDisplayFileSize(_img.limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(_img.limit)  + ').'));
                            }
                        }else{
                            kEditor.editor.getCanvas().execute(
                                function(processor) {
                                    var _node = processor.win.img({
                                        'src': _img.img_src,
                                        'border': "0",
                                        'className': ''
                                    });
                                    // processor.pasteNode(_node, false);
                                    processor.pasteNodeCustom(_node, kEditor.editor.getCanvas(), range);
                                }
                            );
                        }
                        return true;
                    }
                }
            }
        } catch (eee) {
            // console.log('Trex.KEditor._clipboardProcess Error', e);
            return false;
        }
    },
    '_pasteClipboardHtml': function(kEditor, _html, _range) {
        var _isChanged = false;
        var excel_reg = /<html[\S\s]*?office:excel[\S\s]*?>/gi;
        var isExcel = excel_reg.test(_html);
        if (_html.search(/<\!--StartFragment-->([\S\s]*?)<\!--EndFragment-->/i) != -1) {
            var html = _html.match(/<\!--StartFragment-->([\S\s]*?)<\!--EndFragment-->/i)[1];
            if (html.search(/<[a-zA-Z]+[^>]*?>/) == -1) {
                return false; // plain text임
            }
        }
        _html = _html.replace(/(<v:shape(?:>|\s+[^>]*>))([\S*\s*]*?)<\/v:shape>/g,
            function(all, shapetag, shapecontent) {
                if (shapecontent.search(/<v:imagedata/) != -1) {
                    var imagetag = shapecontent.match(/<v:imagedata(?:>|\s+[^>]*>)/)[0];
                    var src = (imagetag.match(/src\s*=\s*(?:'[^']*'|"[^"]*"|[^\s>]*)/) || [""])[0];
                    var style = (shapetag.match(/style\s*=\s*(?:'[^']*'|"[^"]*"|[^\s>]*)/) || [""])[0];
                    _isChanged = true;
                    return "<img " + src + " " + style + ">";
                } else {
                    return all;
                }
            }
        );
        _html = _html.replace(/>&#13;</gi, '>&#xFEFF;<'); // PPT 붙여넣기 공백 줄
        var _reg = /(<\!--\[if\s+(gte\s+|lte\s*|lt\s+|gt\s+|\!)(mso|vml)(\s+\d+|\s*)\]>(((?:[^<])*(?:<(?!\!\[endif\]\s*-->)[^>]*>)[^<]*)*)<\!\[endif\]\s*-->|<\!--\[if\s*\!mso\s*\&\s*vml\]>[\S\s]*?<\!\[endif]-->|<\!--\s*\[if\s+\!vml\]\s*-->|<\!--\s*\[endif\]\s*-->|<\!\[if\s+\![a-zA-Z]+\]>|<\!\[endif\]>)/g;
        if (_reg.test(_html)) {
            _isChanged = true;
            _html = _html.replace(_reg, "");
        }
        _reg = /<(\/?)form/gi;
        if (_reg.test(_html)) {
            _isChanged = true;
            _html = _html.replace(_reg, "<" + "$1" + "x-form");
        }
        _reg = /<\/?[a-zA-Z]+\:[a-zA-Z]+[^>]*>/gi;
        if (_reg.test(_html)) {
            _isChanged = true;
            _html = _html.replace(_reg, "");
        }
        _reg = /(<style(?:>|\s+[^>]*>))(((?:[^<])*(?:<(?!\/style>)[^>]*>)[^<]*)*)<\/style>/g;
        if (_reg.test(_html)) {
            _isChanged = true;
            _html = _html.replace(_reg,
                function(all) {
                    return all.replace(/([:\s]0?)\.5pt/g, "$1" + "1px");
                }
            );
        }
        _reg = /[\S\s]+?(<html)/i;
        if (_reg.test(_html)) {
            //_isChanged = true;
            _html = _html.replace(_reg, "$1");
        }
        var styles = Trex.KEditor._getStyles(_html);
        if (_html.search(/<\!--StartFragment-->([\S\s]*?)<\!--EndFragment-->/) != -1) {
            var html = _html.match(/<\!--StartFragment-->([\S\s]*?)<\!--EndFragment-->/i)[1];
            if (html.search(/<\/?(?!a|abbr|address|b|br|cite|code|em|font|i|img|label|p|span|strike|strong|sub|sup|tt|u)[a-zA-Z]/i) == -1) {
                _isChanged = true;
                _html = html;
            }
            /* table에 cell 내용만 복사 할때 table 구조 제거 */
            if(_html.search(/<table/i) != -1 && html.search(/<\/?(tr|td|th)/i) == -1){
                _html = _html.replace(/<table([\S\s]*?)<\!--StartFragment-->/i, '<!--StartFragment-->');
                _html = _html.replace(/<\!--EndFragment-->([\S\s]*?)<\/table[^>]*>/i, '<!--EndFragment-->');
            }
            /* table 만 복사 한 경우 */
            if(_html.search(/<\!--StartFragment-->\s*<table/i) != -1 && _html.search(/<\/table\s*>\s*<\!--EndFragment-->/i) != -1){
                _html = _html.replace(/(<body[\S\s]*?>)([\S\s]*?)(<\!--StartFragment-->)/i, '$1$3');
                _html = _html.replace(/(<\!--EndFragment-->)([\S\s]*?)(<\/body[\S\s]*?>)/i, '$1$3');
            }
        }

        //엑셀 붙여넣기시 col태그가 존재할 경우 컬럼사이즈 조정이 정상작동 안함 col태그 제거
        if (isExcel && _html.search(/<col[^>]*>/gi) != -1) {
            _isChanged = true;
            _html = _html.replace(/<col[^>]*>/gi, '');
        }        
        _html = _html.replace(/(<\!--StartFragment-->|<\!--EndFragment-->)/gi, "");
        if (_html.search(/<body[^>]*>([\S\s]*)<\/body/i) != -1) {
            _html = _html.match(/<body[^>]*>([\S\s]*)<\/body/i)[1];
        }
        var hasProps = Trex.KEditor._regexpHasStyleProps(kEditor.config.removeStyleProps);
        if (!styles && !(hasProps && hasProps.match.test(_html)) && !_isChanged &&
            !(
                kEditor.imageUploader &&
                kEditor.imageUploader.isLoadComplete() &&
                _html.search(/src\s*\=\s*["']*(file:|[a-zA-Z]:)/i) == -1
            )
        ) return false;
        _html = Trex.KEditor.cleanupHTML(_html);
        _html = Trex.KEditor.inlineStyle(styles, _html, kEditor.config.removeStyleProps);
        _html = Trex.KEditor.htmlLocalImageUpload(kEditor, _html);
        _html = _html.replace(/(\r\n){1,}/g, '\r\n').replace(/(\n){1,}/g, '\n').replace(/(\r){1,}/g, '\r');
        
        var canvas = kEditor.editor.getCanvas();
        // Table을 붙여넣는경우 위아래 공백줄 추가.
        if(_html.search(/\s*<table/i) != -1){
            _html = '<br>' + _html + '<br>';
        }
        kEditor.editor.getCanvas().execute(
            function(processor) {
                processor.pasteHtml(_html, canvas, _range);
                //processor.pasteContent(_html);
            }
        );
        return true;
    },
    '_getStyles': function(_html) {
        var styles = null;
        if (_html.search(/<style/i) != -1) {
            styles = _html.match(/<style[^>]*>[\S\s]*?<\/style>/gi);
        }
        return styles;
    },
    '_controlClipboardProcess': function(kEditor, data) {
        var json = null;
        if (!data) return false;
        try {
            json = eval("(" + data + ")");
        } catch (e) {
            // console.log('json parse error', e);
            return false;
        }
        // Word인 경우 이미지 삭제 (배경색이 검은색으로 됨)
        if (json.type == "multi" && json.data.html && json.data.image){
            var _html = json.data.html;
            if(_html.search(/urn\:schemas\-microsoft\-com\:office\:word/i) != -1){
                json.data.image = null;
            }
        }
        var limit = kEditor.config.imageLimitSize||0;
        if(limit != 0 && (json.type == "image" || (json.type == "multi" && json.data.image))){
            var _data = json.type == "multi"?json.data.image:json.data;
            for (var i = 0; i < _data.length; i++) {
                if(_data[i].size && limit < _data[i].size){
                    _data[i].error = "LIMIT";                    
                }
            }
        }
        var _canvas = kEditor.editor.getCanvas();
        var range = _canvas.getProcessor().getSelectionRange(kEditor.editor.getCanvas());
        if (json.type == "plain") {
            // plain 처리 안함.
            return false;
        } else if (json.type == "multi" && json.data.html && json.data.image && json.data.image[0] && json.data.image[0].error != "LIMIT"){
            var _layer = kEditor.editor.getImagePasteLayer();
            // var _img = {'img_src':"file:///" + json.data.image[0].path};
            var _img = {'img_src':json.data.image[0].dataURL, 'size':json.data.image[0].size};
            var _html = json.data.html;
            var _plain = json.data.plain;
            _layer.showPopup(null, 
                {
                    'image':function(data){
                        var _canvas = kEditor.editor.getCanvas();
                        _canvas.focus();
                        _canvas.execute(
                            function(processor) {
                                var _node = processor.win.img({
                                    'src': data.src?data.src:_img.img_src,
                                    'border': "0",
                                    'className': ''
                                });
                                if(data.width != null) {
                                    _node.width = data.width;
                                    _node.style.width = data.width + 'px';
                                }
                                if(data.height != null) {
                                    _node.height = data.height;
                                    _node.style.height = data.height + 'px';
                                }
                                if(data.border) _node.style.border = data.border;
                                var __node = null;
                                __node = processor.pasteNodeCustom(_node, _canvas, range);
                                if(data.align && __node){
                                    var _w = $tom.find(__node, "%paragraph");
                                    if(_w) _w.style.textAlign = data.align;
                                }
                            }
                        );
                    },
                    'html':function(_data){
                        var _canvas = kEditor.editor.getCanvas();
                        _canvas.focus();
                        Trex.KEditor._pasteClipboardHtml(kEditor, _data, range);
                    },
                    'plain':_plain?function(_data){
                        var _canvas = kEditor.editor.getCanvas();
                        _canvas.focus();                                
                        _canvas.execute(
                            function(processor) {
                                processor.pasteHtml(_data, _canvas, range);
                            }
                        );
                    }:null
                }
                , {'src':_img.img_src}
                , _html
                , _plain
                , _img.size);
            return true;
        } else if (json.type == "multi" && json.data.html){
            return Trex.KEditor._pasteClipboardHtml(kEditor, json.data.html, range);
        } else if (json.type == "html") {
            var html = json.data;
            return Trex.KEditor._pasteClipboardHtml(kEditor, html, range);
        } else if (json.type == "image" || (json.type == "multi" && json.data.image)){
            try{
                if(json.type == "image" 
                    && $tx.msie && $tx.msie_ver == 11
                    && json.data
                    && json.data.length == 1
                    && json.data[0].dataURL
                ) return false;
            }catch(e){}            
            var html = "";
            var doc = kEditor.getDom();
            var _data = json.type == "multi"?json.data.image:json.data;
            // var maxWidth = doc.body.clientWidth - 40;
            // var maxHeight = doc.body.clientHeight;
            var hasLimit = false;
            var limitSize = '';
            for (var i = 0; i < _data.length; i++) {
                if(_data[i].error == "LIMIT"){
                    hasLimit = true;
                    limitSize = _data[i].size;
                }else{
                    // var width = maxWidth < _data[i].width ? maxWidth + "px" : "";
                    var width = _data[i].width;
                    html += '<img ' + (width ? ' width="' + width + '"' : "") +
                        'src="file:///' + _data[i].path.replace(/"/g, "&qout;").replace(/\\/g, "/") + '">';
                }
            }
            if(!html && hasLimit){
                if(Trex.Image._SUPPORT_JPEG_QUALITY){
                    alert(Trex._I18N.g('image.upload_limit_canvas', Trex._getDisplayFileSize(limitSize), Trex._getDisplayFileSize(limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(limit)  + ').\n이미지 첨부의 JPEG 품질 기능을 사용하여 이미지를 첨부해 주세요.'))
                }else{
                    alert(Trex._I18N.g('image.upload_limit', Trex._getDisplayFileSize(limitSize), Trex._getDisplayFileSize(limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(limit)  + ').'))
                }
                return true;
            }else if (html) {
                html = Trex.KEditor.htmlLocalImageUpload(kEditor, html);
                kEditor.editor.getCanvas().execute(
                    function(processor) {
                        processor.pasteHtml(html, _canvas, range);
                        //processor.pasteContent(html);
                    }
                );
                return true;
            } else {
                return false;
            }
        }
    },
    'htmlLocalImageUpload': function(kEditor, html) {
        if (!kEditor.imageUploader || !kEditor.imageUploader.isLoadComplete()) return html;
        var _html = '';
        var elem = $('<div>' + html + '</div>');
        elem = Trex.KEditor._controlLocalImageUpload(kEditor, elem);
        if (elem != null) {
            _html = elem.html();
        } else {
            _html = html;
        }
        return _html;
    },
    '_controlLocalImageUpload': function(kEditor, elem) {
        if (!kEditor.imageUploader || !kEditor.imageUploader.isLoadComplete()) return;
        return kEditor.imageUploader.uploadImage(kEditor, elem);
    },
    'eventPaste': function(kEditor, e, isOnPaste) {
        var _self = this;
        if(isOnPaste){
            if(_self.pasteCtrlV){
                clearTimeout(_self.pasteCtrlV);
                _self.pasteCtrlV = null;
            }
            _self.__eventPaste(kEditor, e, isOnPaste);
        }else{
            (function(_kEditor, _e, _isOnPaste){
                _self.pasteCtrlV = setTimeout(function(){
                    _self.__eventPaste(_kEditor, _e, _isOnPaste);
                }, 50);
            })(kEditor, e, isOnPaste);            
        }
    },
    '__eventPaste':function(kEditor, e, isOnPaste){
        if (Trex.KEditor._clipboardProcess(kEditor, e)) {            
            // clipboard 처리 완료 event 중지
            if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; }
            if (e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; }
        } else {
            // clipboard 처리내용 없음 event 계속.
            // Applet 사용 본문 html style inline처리
            if (kEditor.imageUploader && kEditor.imageUploader.isLoadComplete()) {
                var data = kEditor.imageUploader.getClipboardData();
                if (Trex.KEditor._controlClipboardProcess(kEditor, data)) {
                    // clipboard 처리 완료 event 중지
                    if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; }
                    if (e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; }
                }
            }
        }
    },
    'base64ImageUpload': function(kEditor) {
        var dfd = $.Deferred();
        try {
            if (window.Blob != null && window.atob != null &&
                window.FormData != null && window.Uint8Array != null) {
                var dom = kEditor.getDom();
                var reg = /data\:(image\/[^;]+)\;base64\,/i;
                $.each(
                    //$('img[src^="data:"]', dom),
                    $('img[src]', dom),
                    function(index, elem) {
                        var src = elem.src;
                        if (reg.test(src)) {
                            var info = src.substring(0, src.indexOf(','));
                            var data = src.substring(src.indexOf(',') + 1);
                            var type = info.split(":")[1].split(";")[0];
                            var blob = Trex.KEditor.base64ToBlob(data, type);
                            var result = Trex.KEditor.blobUpload(kEditor, blob);
                            if (result && result.img_src) {
                                elem.src = result.img_src;
                            }
                            try{
                                data = '';
                                data = null;
                                delete blob;
                                blob = null;
                                delete result;
                                result = null;
                            }catch(e){}
                        }
                    }
                );
            }
            dfd.resolve(true, null);
        } catch (e) {
            dfd.resolve(false, e);
        }
        return dfd.promise();
    },
    'externalImageUpload': function(kEditor) {
        var dfd = $.Deferred();
        try {
            var dom = kEditor.getDom();
            if (window.Blob != null && window.atob != null &&
                window.FormData != null && window.Uint8Array != null) {
                var uploadImages = {};
                var hasImage = false;
                $.each(
                    //$('img[src^="data:"]', dom),
                    $('img[src]', dom),
                    function(index, elem) {
                        var src = elem.src;
                        if (kEditor._checkExternalImage(src)) {
                            if (uploadImages[src] == null) {
                                uploadImages[src] = [];
                            }
                            uploadImages[src].push(elem);
                            hasImage = true;
                        } else {
                            elem.width = elem.width;
                            elem.height = elem.height;
                        }
                    }
                );
                if (hasImage) {
                    Trex.KEditor._externalImageUpload(kEditor, uploadImages, dfd);
                } else {
                    dfd.resolve(true, null);
                }
            } else if (kEditor.imageUploader && kEditor.imageUploader.isLoadComplete()) {
                kEditor.imageUploader.uploadImage(kEditor, dom);
                dfd.resolve(true, null);
            } else {
                dfd.resolve(false, null);
            }
        } catch (e) {
            dfd.resolve(false, e);
        }
        return dfd.promise();
    },
    '_externalImageUpload': function(kEditor, uploadImages, deferred) {
        var _defs = [];
        var uploadImageById = {};
        var uploadedImage = {};
        for (var img_path in uploadImages) {
            var promi = Trex.KEditor._getBlob(img_path)
                .then(
                    function(blob, _img_path) {
                        var uploadInfo = null;
                        try {
                            uploadInfo = Trex.KEditor.blobUpload(kEditor, blob);
                        } catch (e) {
                            // console.log('blobUpload fail', e);
                        }
                        if (uploadInfo) {
                            try {
                                var imgs = uploadImages[_img_path];
                                uploadImageById[uploadInfo.imageName] = imgs;
                                if (imgs != null) {
                                    for (var j = 0; j < imgs.length; j++) {
                                        uploadedImage[uploadInfo.imageName] = uploadInfo.img_src;
                                    }
                                }
                            } catch (e) {
                                // console.log(e);
                            }
                        }
                        return $.Deferred().resolve();
                    },
                    function(e, _img_path) {
                        // console.log('_getBlob fail', _img_path, e);
                        return $.Deferred().resolve();
                    }
                );
            _defs.push(promi);
        }
        $.when.apply($, _defs)
            .always(
                function() {
                    try {
                        var uploadInfo = { uploadedImage: uploadedImage, uploadId: uploadImageById };
                        // console.log('_externalImageUpload all', uploadInfo);
                        for (var idx in uploadInfo.uploadedImage) {
                            var imgs = uploadInfo.uploadId[idx];
                            if (imgs != null) {
                                for (var j = 0; j < imgs.length; j++) {
                                    imgs[j].removeAttribute("id");
                                    imgs[j].src = uploadInfo.uploadedImage[idx];
                                    // console.log('img src', uploadInfo.uploadedImage[idx], imgs[j].src);
                                }
                            }
                        }
                        deferred.resolve(true, null);
                    } catch (e) {
                        deferred.resolve(false, e);
                    }
                }
            );
    },
    '_getBlob': function(url) {
        var dfd = $.Deferred();
        try {
            var xhr = new XMLHttpRequest();
            xhr.onload = function() {
                if (xhr.readyState == 4 && xhr.status == 200) {
                    dfd.resolve(xhr.response, url);
                } else {
                    dfd.reject(null);
                }
            };
            xhr.onerror = function(e) {
                dfd.reject(e, url);
            };
            xhr.open("GET", url.replace(/\:\/\/[^\/]+\//, "://" + document.location.host + "/"), true);
            xhr.responseType = "blob";
            xhr.send();
        } catch (e) {
            dfd.reject(e, url);
        }
        return dfd.promise();
    },
    'blobUpload': function(kEditor, blob) {
        var type = (blob.type.split("/")[1] || "").toLowerCase();
        var ext = "gif";
        if (type == "gif") ext = "gif";
        else if (type == "jpg" || type == "jpeg") ext = "jpg";
        else if (type == "png") ext = "png";
        else if (type != "") ext = type;

        var _info = kEditor._getUploadImageInfo('', blob.type, ext, 'blob');
        if (!_info.postdata) _info.postdata = {};
        if (!_info.type) _info.type == 'domino';
        if (!_info.fieldname) _info.fieldname = '%%File';
        var cid = _info.cid;
        var imageName = _info.name;
        var url = _info.url;
        var _host = _info.host;
        var form_data = new FormData();
        if (_info.type == 'domino') {
            form_data.append("__Click", "0");
            form_data.append("%%PostCharset", "UTF-8");
            form_data.append("Body", "");
        }
        for (var idx in _info.postdata) {
            form_data.append(idx, _info.postdata[idx]);
        }
        form_data.append(_info.fieldname, blob, imageName);
        var formAction = url;
        var xhr = new XMLHttpRequest();
        xhr.open("POST", formAction, false);
        xhr.send(form_data);
        var uploadResult = xhr.responseText;
        var result = null;
        result = kEditor._parseUploadResponse(uploadResult, _info, 'blob');
        return result;
    },
    'base64ToBlob': function(base64, contentType, sliceSize) {
        contentType = contentType || '';
        sliceSize = sliceSize || 1024;

        var byteCharacters = atob(base64);
        var byteArrays = [];

        for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            var slice = byteCharacters.slice(offset, offset + sliceSize);
            var byteNumbers = new Array(slice.length);
            for (var i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            var byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
            try{
                delete byteNumbers;
                byteNumbers = null;
                delete byteArray;
                byteArray = null;
            }catch(e){}
        }
        var blob = new Blob(byteArrays, { type: contentType });
        try{
            delete byteArrays;
            byteArrays = null;
            delete byteCharacters;
            byteCharacters = null;
            base64 = '';
            base64 = null;
        }catch(e){}
        return blob;
    },
    '_regexps': {},
    '_regexpHasStyleProps': function(props) {
        var _reg = null;
        if (props && props.join) {
            var _props = (props.join('\\s*:\\s*("[^"]*"|\'[^\']*\'|[^;\'">]*)+?;?|') + '\\s*:\\s*("[^"]*"|\'[^\']*\'|[^;\'">]*)+?;?').toLowerCase();
            var _props2 = (props.join('\\s*:\\s*("[^"]*"|\'[^\']*\'|[^;]*)+?;?|') + '\\s*:\\s*("[^"]*"|\'[^\']*\'|[^;]*)+?;?').toLowerCase();
            if (Trex.KEditor._regexps['styleprops_' + _props]) {
                _reg = Trex.KEditor._regexps['styleprops_' + _props];
            } else {
                _reg = Trex.KEditor._regexps['styleprops_' + _props] = {
                    'match': new RegExp("<[a-zA-Z]+\\s+[^>]*(" + _props + ")[^>]*?>", "ig"),
                    'replace': new RegExp("(" + _props + ")", "ig"),
                    'replace_prop': new RegExp("(" + _props2 + ")", "ig"),
                };
            }
        }
        return _reg;
    },
    'inlineStyle': function(styles, _html, ignoreProps, wrapBody) {
        var _ignoreProps = null;
        if (ignoreProps && ignoreProps.join) {
            _ignoreProps = Trex.KEditor._regexpHasStyleProps(ignoreProps);
        }
        if (styles == null && _ignoreProps == null) return _html;
        var elem = null;
        var bodyCSS = "";
        if (styles) {
            var cssReg = /<style[^>]*>([\S*\s*]*?)<\/style[^>]*>/i;
            var cssRegAll = /<style[^>]*>([\S*\s*]*?)<\/style[^>]*>/gi;
            var mediaReg = /[^\{\}]+\{([^\{\}]+\{[^\}]*?\})*\}/g;
            var cssItemReg = /([^\{\}]+)\{([^}]*?)\}/g;
            var selectorReg = /([^\{\}]+)\{([^\}]*?)\}/i;
            var cssText = "";            
            var css_list = [];
            _html = _html.replace(cssRegAll, "");
            for (var i = 0; i < styles.length; i++) {
                var css_match = styles[i].match(cssReg);
                if (css_match) cssText += css_match[1].replace(/<!--/g, "").replace(/-->/g, "");
            }
            cssText = cssText.replace(mediaReg, "");
            cssText = cssText.replace(/hairline/gi, 'dotted');
            cssText = cssText.replace(/\/\*[\S\s]*?\*\//gi, '');
            var selectors = cssText.match(cssItemReg);
            if (selectors != null) {
                for (var i = 0; i < selectors.length; i++) {
                    var item_match = selectors[i].match(selectorReg);
                    var selector = item_match[1];
                    var sel_css = item_match[2];
                    var sel_arr = selector.split(/,/);
                    try{if(_ignoreProps) sel_css = sel_css.replace(_ignoreProps.replace_prop, '');}catch(e){}
                    if(sel_css && sel_css.trim()) {
                        for (var j = 0; j < sel_arr.length; j++) {
                            var sel = sel_arr[j].replace(/^\s+/g, "").replace(/\s+$/g, "");
                            if (sel.charAt(0) == "@") continue;
                            var wk = sel.split(/\s/);
                            wk = wk[wk.length - 1];
                            var weight = 0;
                            if (wk.indexOf(".") == -1) {
                                if (wk.charAt(0) == "#") weight = 900000;
                                else weight = 0;
                            } else {
                                if (wk.charAt(0) == "#") weight = 910000;
                                else weight = 100000 + (1000 * (wk.split(".").length - 1));
                            }
                            css_list.push({
                                "selector": sel,
                                "css": sel_css,
                                "weight": weight
                            });
                            if(wrapBody&&sel&&sel.toLowerCase()=='body') bodyCSS+=(bodyCSS?';':'') + sel_css;
                        }
                    }
                }
            }
            elem = $('<div>' + _html + '</div>');
            for (var i = 0; i < css_list.length; i++) {
                var item = css_list[i];
                var _te = null;
                try {
                    _te = $(item.selector, elem);
                } catch (e) {
                    _te = null;
                }
                if (!_te) continue;
                $.each(_te, function() {
                    var _elem = $(this);
                    _elem.addClass("_inline_style");
                    var s_arr = _elem.data("__style") || [];
                    s_arr.push(item);
                    _elem.data("__style", s_arr);
                });
            }
            $.each($("._inline_style", elem), function() {
                var _elem = $(this);
                var inline_style = _elem.attr("style") || '';
                var _data = _elem.data("__style");
                var _css = _data.sort(function(a, b) {
                    if (a.weight > b.weight) {
                        return 1;
                    } else if (a.weight == b.weight) {
                        return 0;
                    } else {
                        return -1;
                    }
                });
                var _csstext = '';
                for (var i = 0; i < _css.length; i++) {
                    _csstext += (_csstext ? ";" : "") + _css[i].css;
                }
                if(_csstext.indexOf('border') != -1 && inline_style.search(/border\s*:\s*currentColor\s*;?/gi) != -1) 
                    inline_style = inline_style.replace(/border\s*:\s*currentColor\s*;?/gi, '');
                _csstext += (_csstext ? ";" : "") + inline_style;
                _csstext = _csstext.replace(/;;/g, ";");
                _elem.attr("style", _csstext);
            });
            if(bodyCSS){
                var css_text = bodyCSS.replace(/\s*;\s*;\s*/g, ";").split(';');
                for(var i = 0; i < css_text.length; i++){
                    if(css_text[i].search(/(margin|padding|float\s*:|position|clear|height\s*:|width\s*:|left\s*:|right\s*:|bottom\s*:|top\s*:|overflow|display\s*:|visibility\s*:)/i) != -1) css_text[i] = '';
                }
                bodyCSS = css_text.join(';').replace(/;;/g, ";") + ';margin:0;padding:0';
            }
            if(bodyCSS && elem.children().length == 1){
                elem.children().each(function(){
                    var css_text = bodyCSS + ";" + $(this).css('cssText');
                    css_text = css_text.replace(/;;/g, ";");
                    $(this).attr('style', css_text);
                });
                bodyCSS = '';
            }
        }
        if (elem) {
            $("[class], [id]", elem).removeAttr("class").removeAttr("id");
            _html = elem.html();
        }
        if (_ignoreProps) {
            if (_ignoreProps.match.test(_html)) {
                _html = _html.replace(_ignoreProps.match, function(a) {
                    return a.replace(_ignoreProps.replace, '');
                });
            }
        }
        if(bodyCSS){
            _html = '<div style="' + bodyCSS.replace(/"/g, '') + '">' + _html + '</div>';
        }
        return _html;
    },
    cleanupHTML: function(html, removeEmptyTag, reReq){
        var _html = html;
        var hasRemoveTag = 0;
        if(removeEmptyTag !== false){
            var emptyTags = /<(p|span|strike|u|i|em|b|strong|font)[^>a-zA-Z]*?><\/\1[^>a-zA-Z]*?>/gi;
            var limit_empty = 10;
            while(_html.search(emptyTags) != -1){
                limit_empty--;
                if(limit_empty < 0) break;
                _html = _html.replace(emptyTags, '');
            }
        }
        var attrKey = 'REMOVE_TAG' + (new Date()).getTime().toString(16);
        var __compact = _html.replace(/((<(span[^>]*?>|strike>|u>|i>|em>|b>|strong>|(strike|u|i|em|b|strong)\s+[^>]*?>)\s*){2,}|((<div>|<div\s+[^>]*?>)\s*){2,})/gi, function(_all, _open){
            var _o = _open.split('>');
            var _suffix = _o.pop();
            _o[_o.length - 1] += '>';
            for(var i = 0; i < _o.length - 1; i++){
                _o[i] += ' ' + attrKey;
                _o[i] += '>';
                hasRemoveTag++;
            }
            return _o.join('') + _suffix;
        });
        var needRecheck = false;
        if(hasRemoveTag > 0){
            var _compact = $('<div></div>');
            _compact.html(__compact);           
            var _m = $('[' + attrKey + ']', _compact); //.contents().unwrap().html();
            for(var ii = _m.length - 1; ii >= 0; ii--){
                var _item = _m[ii];
                if(_item.nodeType == 1 && _item.childNodes && _item.childNodes.length == 1){
                    if(
                        ((_item.childNodes[0].nodeName == 'SPAN' && _item.nodeName != "DIV") || _item.childNodes[0].nodeName == 'DIV')
                        && _item.nodeName != "STRIKE" && _item.nodeName != "U" && _item.nodeName != "I" && _item.nodeName != "EM"
                    ){
                        _item.childNodes[0].style.cssText = (_item.nodeName == "B" || _item.nodeName == "STRONG" ?'font-weight:bold': _item.style.cssText) 
                            + ";" + _item.childNodes[0].style.cssText
                        var _parent = _item.parentNode;
                        while( _item.firstChild ) {
                            _parent.insertBefore( _item.firstChild, _item );
                        }
                        _parent.removeChild(_item);
                    }else if(_item.nodeName == "STRIKE" || _item.nodeName == "U" || _item.nodeName == "I" || _item.nodeName == "EM" || _item.nodeName == "B" || _item.nodeName == "STRONG"){ // strong, b, strike, u, i, em 연속으로 중복
                        var _loop = _item.childNodes[0];
                        var _limit_l = 10;
                        var _dupl = false;
                        while(_loop){
                            _limit_l--;
                            if(_limit_l < 0) break;
                            var _work = _loop;
                            if(_work.nodeName == _item.nodeName){
                                _dupl = true; break;
                            }
                            if(_work.childNodes.length == 1){
                                _loop = _work.childNodes[0];
                            }
                        }
                        if(_dupl){
                            var _parent = _item.parentNode;
                            while( _item.firstChild ) {
                                _parent.insertBefore( _item.firstChild, _item );
                            }
                            _parent.removeChild(_item);
                        }
                    }
                }
                /*else if(_item.nodeType == 1 && _item.nodeName == "DIV" 
                    && _item.childNodes && _item.childNodes.length > 1 
                    && _item.childNodes[0].nodeName == "DIV"
                    && _item.style.cssText == _item.childNodes[0].style.cssText
                ){
                    var __item = _item.childNodes[0];
                    var _parent = __item.parentNode;
                    while( __item.firstChild ) {
                        _parent.insertBefore( __item.firstChild, __item);
                    }
                    _parent.removeChild(__item);
                    needRecheck = true;
                }*/
            }
            var replaceAttrKey = eval('/' + attrKey + '(="")?/gi');
            _html = _compact.html().replace(replaceAttrKey, '');            
        }
        // if(needRecheck && !reReq){
        //     return this.cleanupHTML(_html, false, true);
        // }else{
            return _html;
        // }
    }
};
Trex.KEditor.ImageResizeCtrl = function(editor, _canvas) {
    var _self = this;
    this.editor = editor;
    this.canvas = _canvas;
    this.isActive = false;
    this.isResize = false;
    this.resizeType = '';
    this.pos = { x: 0, y: 0 };
    this.origin = { width: 0, height: 0 };
    this.work = { width: 0, height: 0 };
    this.activeElement = null;
    this.wrapper = null;
    this.htmlBody = this.canvas.panels['html'].el.contentWindow.document.body
    if($tx.msie){
        this.htmlBody.addEventListener('mscontrolselect', function(e){
            var elem = $tx.element(e);
            if(elem.tagName == "IMG" && _self.enableControl == null) e.preventDefault();
        });
    }
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYDOWN, function(ev) {
        _self.keyDown(ev);
    });
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYUP, function(ev) {
        _self.keyUp(ev);
    });
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, function(ev) {
        _self.mouseClick(ev);
    });
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev) {
        _self.mouseDown(ev);
    });
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, function(ev) {
        _self.mouseMove(ev);
    });
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev) {
        _self.mouseUp(ev);
    });
    _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_BLUR, function(ev) {
        _self.blur(ev);
    });
};
Trex.KEditor.ImageResizeCtrl.prototype = {
    'mouseClick': function(ev) {
        var elem = $tx.element(ev);
        var tag = elem && elem.tagName ? elem.tagName.toLowerCase() : '';
        // if(ev.ctrlKey){
        //     if (this.isActive && this.activeElement !== elem) {
        //         this.clearWrapper(this.activeElement);
        //     }
        // }else 
        if (tag == "img") {
            if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; }
            if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; }
            if (this.isActive && this.activeElement !== elem) {
                this.clearWrapper(this.activeElement);
            }
            if (!this.isActive) {
                this.wrapping(elem);
            }
            if (this.isActive) {
            }
            if($tx.chrome){
                var sel = this.htmlBody.ownerDocument.getSelection();
                sel.removeAllRanges();
            }
        } else if (tag == "div" && $(elem).is('.ke-img.drag')) {} else if (tag == "div" && ($(elem).is('.ke-img.inner-wrapper') ||
                $(elem).is('.ke-img.inner-comment'))) {
            if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; }
            if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; }
        } else {
            if (this.isActive && this.activeElement !== elem) {
                this.clearWrapper(this.activeElement);
                //this.clearAll();
            }
        }
    },
    'mouseDown': function(ev) {
        var elem = $tx.element(ev);
        var tag = elem && elem.tagName ? elem.tagName.toLowerCase() : '';
        if (tag == "div" && $(elem).is('.ke-img.drag')) {
            try {
                var img = this.activeElement;
                this.pos.x = ev.clientX;
                this.pos.y = ev.clientY;
                this.resizeType = elem.getAttribute("keType") || 'tl';
                this.isResize = true;
                this.wrapper
                    .addClass("resize")
                    .removeClass('tl tc tr lm rm bl bc br')
                    .addClass(this.resizeType);
                this._size_offset = this["_size_" + this.resizeType];
            } catch (e) {
                // console.log('isResize error');
                this.clearAll();
                return;
            }
        }
    },
    '_size': function(ev, img, sizeLock) {
        var w, h;
        var offset = this._size_offset(ev, img, sizeLock);
        // this.pos.x = ev.clientX;
        // this.pos.y = ev.clientY;
        // w = img.width - 0 + offset.x;
        // h = img.height - 0 + offset.y;
        w = this.work.width - 0 + offset.x;
        h = this.work.height - 0 + offset.y;
        if (w < 0) {
            this.pos.x = ev.clientX - (w * offset.ox);
            w = 0;
        }else{
            this.pos.x = ev.clientX;
        }
        if (h < 0) {
            this.pos.y = ev.clientY - (h * offset.oy);
            h = 0;
        }else{
            this.pos.y = ev.clientY;
        }
        if (sizeLock) {
            if (w > h) h = '';
            else w = '';
        }
        this.work.width = w;
        this.work.height = h;
        return { w: w, h: h };
    },
    '_size_tl': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = this.pos.x - ev.clientX;
        y = this.pos.y - ev.clientY;
        return { x: x, y: y, ox:-1, oy:-1};
    },
    '_size_tc': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = 0;
        y = this.pos.y - ev.clientY;
        return { x: x, y: y, ox:1, oy:-1};
    },
    '_size_tr': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = ev.clientX - this.pos.x;
        y = this.pos.y - ev.clientY;
        return { x: x, y: y, ox:1, oy:-1};
    },
    '_size_lm': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = this.pos.x - ev.clientX;
        y = 0;
        return { x: x, y: y, ox:-1, oy:1};
    },
    '_size_rm': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = ev.clientX - this.pos.x;
        y = 0;
        return { x: x, y: y, ox:1, oy:1};
    },
    '_size_bl': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = this.pos.x - ev.clientX;
        y = ev.clientY - this.pos.y;
        return { x: x, y: y, ox:-1, oy:1};
    },
    '_size_bc': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = 0;
        y = ev.clientY - this.pos.y;
        return { x: x, y: y, ox:1, oy:1};
    },
    '_size_br': function(ev, img, sizeLock) {
        var x = 0;
        var y = 0;
        x = ev.clientX - this.pos.x;
        y = ev.clientY - this.pos.y;
        return { x: x, y: y, ox:1, oy:1};
    },
    'mouseMove': function(e) {
        if (!(this.isActive && this.isResize)) return;
        var self = this;
        if(e.buttons != '1') {
            self.mouseUp();
            return;
        }
        try {
            var img = self.activeElement;
            var size = self._size(e, img, e.shiftKey);
            self._resize(img, size);
        } catch (ee) {
            self.clearAll();
            return;
        }
    },
    '_resize': function(img, size) {
        if (size.w === '') img.removeAttribute('width');
        else img.width = size.w;
        if (size.h === '') img.removeAttribute('height');
        else img.height = size.h;
        img.width = img.width;
        img.height = img.height;
        this.wrapper.css = {
            width: img.width + 'px',
            height: img.height + 'px'
        };
        this._hasResize = true;
        this.displaySize();
    },
    'mouseUp': function() {
        if (!(this.isActive && this.isResize)) return;
        this.isResize = false;
        this.wrapper.removeClass("resize")
            .removeClass('tl tc tr lm rm bl bc br');
        if(this._hasResize) {
            var tmp = this.activeElement;
            this.clearWrapper(this.activeElement);
            if((this.work.width !== "" && this.work.width < 10) || (this.work.height !== "" && this.work.height < 10)){
                this._resize(tmp, {
                    w:(this.work.width !== "" && this.work.width < 10)?10:this.work.width,
                    h:(this.work.height !== "" && this.work.height < 10)?10:this.work.height
                });
            }
            this.canvas.history.saveHistory();
            this.wrapping(tmp);
        }
        this._hasResize = false;
    },
    'keyDown': function(ev) {
        if (!this.isActive) return;
        var self = this;
        function _defaultObject(_init){
            var tmp = self.activeElement;
            self.clearWrapper(self.activeElement);
            self.enableControl = tmp;
            if($tx.msie){
                var range = self.htmlBody.createControlRange();
                range.add(tmp);
                range.select();
            }else{
                var range = self.htmlBody.ownerDocument.createRange();
                range.selectNode(tmp);                    
                var sel = self.htmlBody.ownerDocument.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);                  
            }
            if(_init === false) self.enableControl = null;
        }
        if (this.activeElement) {
            var img = this.activeElement;
            var offset = 1;
            if (ev.keyCode == 38) { // up
                if(ev.altKey){
                    this._resize(this.activeElement, {
                        w: ev.shiftKey ? '' : img.width - 0,
                        h: img.height - 0 - offset
                    });
                    if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; }
                }else{
                    _defaultObject(false);
                }
            } else if (ev.keyCode == 40) { // down
                if(ev.altKey){
                    this._resize(this.activeElement, {
                        w: ev.shiftKey ? '' : img.width - 0,
                        h: img.height - 0 + offset
                    });
                    if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; }
                }else{
                    _defaultObject(false);
                }                
            } else if (ev.keyCode == 37) { // left
                if(ev.altKey){
                    this._resize(this.activeElement, {
                        w: img.width - 0 - offset,
                        h: ev.shiftKey ? '' : img.height - 0
                    });
                    if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; }
                }else{
                    _defaultObject(false);
                }
            } else if (ev.keyCode == 39) { // right
                if(ev.altKey){
                    this._resize(this.activeElement, {
                        w: img.width - 0 + offset,
                        h: ev.shiftKey ? '' : img.height - 0
                    });
                    if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; }
                }else{
                    _defaultObject(false);
                }
            } else if (ev.keyCode == 16 || ev.shiftKey) {

            } else if (ev.keyCode == Trex.__KEY.DELETE) {
                this.clearWrapper(this.activeElement, true);
            } else if (ev.ctrlKey){
                _defaultObject();
            } else if (ev.altKey) {

            } else {
                this.clearWrapper(this.activeElement);
            }
        }
    },
    'keyUp': function(ev){
        if(this.enableControl){
            var tmp = this.enableControl;
            this.enableControl = null;
            this.htmlBody.focus();
            this.wrapping(tmp);
            tmp.focus();
            if($tx.chrome){
                var sel = this.htmlBody.ownerDocument.getSelection();
                sel.removeAllRanges();
            }
        }
    },
    'blur': function(ev) {
        if (this.activeElement) {
            this.clearWrapper(this.activeElement);
        }
    },
    'changeMode': function() {
        if (this.activeElement) {
            this.clearWrapper(this.activeElement);
        }
    },
    'displaySize': function(pos) {
        $(".ke-img.inner-comment", this.wrapper)
            .html(this.activeElement.width + 'x' + this.activeElement.height);
    },
    'wrapping': function(elem) {
        var _doc = this.canvas.panels.html.wysiwygDoc;
        var _body = _doc.body;
        var _html = _body.parentNode;
        var _pos_last = _body.scrollWidth == (_html.scrollLeft + _html.offsetWidth);
        var img = this.activeElement = elem;
        this.work.width = this.origin.width = img.width = img.width;
        this.work.height = this.origin.height = img.height = img.height;
        img.style.width = null;
        img.style.height = null;
        this.isActive = true;
        var _imageElem = $(img)[0];
        var _imageCss = _imageElem.style.cssText;

        $(img).wrap('<div class="ke-img wrapper" contenteditable="false" unselectable="on"></div>');
        this.wrapper = $(this.activeElement).parent();       

        this.wrapper[0].style.cssText = _imageCss;
        this.wrapper.css = {
            'width': this.origin.width + 'px',
            'height': this.origin.height + 'px'
        };
        this.wrapper[0].setCSS = 'true';
        _imageElem.style.cssText = '';

        this.wrapper.append(
            //'<div class="ke-img inner-wrapper"></div>' +
            '<div class="ke-img drag tl" keType="tl" unselectable="on"></div>' +
            '<div class="ke-img drag tc" keType="tc" unselectable="on"></div>' +
            '<div class="ke-img drag tr" keType="tr" unselectable="on"></div>' +
            '<div class="ke-img drag lm" keType="lm" unselectable="on"></div>' +
            '<div class="ke-img drag rm" keType="rm" unselectable="on"></div>' +
            '<div class="ke-img drag bl" keType="bl" unselectable="on"></div>' +
            '<div class="ke-img drag bc" keType="bc" unselectable="on"></div>' +
            '<div class="ke-img drag br" keType="br" unselectable="on"></div>' +
            '<div class="ke-img inner-comment" unselectable="on"></div>');
        this.displaySize();
        if(_pos_last){
            _html.scrollLeft = _body.scrollWidth;
        }
    },
    'clearAll': function() {
        var dom = this.editor.getCanvas().getPanel('html').getDocument();
        var _self = this;
        $('.ke-img.wrapper img', dom).each(function(index, elem) {
            _self.clearWrapper(elem);
        });
    },
    'clearWrapper': function(elem, isremove) {
        if ($(elem).parent().is('div.ke-img.wrapper')) {
            if (this.wrapper[0].setCSS == 'true') elem.style.cssText = this.wrapper[0].style.cssText;
            $("div.ke-img", this.wrapper).remove();
            if (elem) $(elem).unwrap();
            if (isremove) $(this.activeElement).remove();
            this.wrapper = null;
            this.activeElement = null;
            this.isActive = false;
        }
    }
};

//oop
(function(Trex) {

    function $$reference($instance) {
        var _$ref = $instance;
        while (_$ref.$reference) {
            _$ref = _$ref.$reference;
        }
        return _$ref;
    }

    function $$super($instance) {
        var _$superclass = $instance.constructor.superclass;
        if (_$superclass) {
            var _$initbak = _$superclass.prototype.initialize;
            _$superclass.prototype.initialize = function() {
                this.$reference = $instance;
            }; //fake initialize
            var _$superobj = new _$superclass();
            _$superclass.prototype.initialize = _$initbak;

            var _wrapFunc = function(name) {
                if (!_$superobj[name]) return _NULL;
                return function() {
                    var _arguments = arguments;
                    var _$reference = $$reference($instance);
                    var _$superbak = _$reference.$super;
                    _$reference.$super = _$superobj.$super;
                    var _returns = _$superobj[name].apply(_$reference, _arguments);
                    _$reference.$super = _$superbak;
                    return _returns;
                };
            };

            var _$wrapobj = {};
            for (var _name in _$superobj) {
                if (_name.charAt(0) != '$') {
                    if (typeof(_$superobj[_name]) == 'function') {
                        _$wrapobj[_name] = _wrapFunc(_name);
                    }
                }
            }
            $instance.$super = _$wrapobj;
        }
    }

    /**
     * @namespace
     * @name Trex.Class
     */
    Trex.Class = /** @lends Trex.Class */ {
        /**
         * creates class
         * @param {Object} properties
         */
        create: function(properties) {
            var _class = function() {
                var _proto = this.constructor.prototype; //NOTE: Cuz properties must not share
                for (var _name in _proto) {
                    if (_proto[_name] && typeof(_proto[_name]) === 'object') {
                        if (_proto[_name].constructor == Array) { //Array
                            this[_name] = [].concat(_proto[_name]);
                        } else {
                            this[_name] = Object.extend({}, _proto[_name]);
                        }
                    }
                }
                $$super(this);
                var _arguments = arguments;
                this.initialize.apply(this, _arguments);
            };
            return Trex.Class.draft(properties, _class);
        },
        draft: function(properties, aClass) {
            var _class = aClass ?
                aClass :
                function() {
                    $$super(this);
                };

            if (properties.$const) {
                Object.extend(_class, properties.$const);
            }

            if (properties.$extend) {
                Object.extend(_class.prototype, properties.$extend.prototype);
                _class.superclass = properties.$extend;
            }

            if (properties.$mixins) {
                var sources = $A(properties.$mixins);
                sources.each(function(source) {
                    Object.extend(_class.prototype, source);
                });
            }
            for (var _name in properties) {
                if (_name.charAt(0) != '$') {
                    _class.prototype[_name] = properties[_name];
                }
            }
            return _class;
        },
        overwrite: function(source, properties) {
            if (source.prototype) {
                Object.extend(source.prototype, properties);
            }
            return source;
        }
    };

    /**
     * @namespace
     * @name Trex.Faculty, Trex.Mixin
     */
    Trex.Mixin = Trex.Faculty = /** @lends Trex.Mixin */ {
        /**
         * Creates
         * @param {Object} properties
         */
        create: function(properties) {
            var _class = {};
            for (var _name in properties) {
                if (properties[_name] && typeof(properties[_name]) === 'object') {
                    if (properties[_name].constructor == Array) { //Array
                        _class[_name] = [].concat(properties[_name]);
                    } else {
                        _class[_name] = Object.extend({}, properties[_name]);
                    }
                } else {
                    _class[_name] = properties[_name];
                }
            }
            return _class;
        },
        toClass: function(properties, initializeFunc) {
            return Trex.Class.create(
                Object.extend({
                    initialize: initializeFunc ? initializeFunc : function() {}
                }, properties)
            );
        }
    };
})(Trex);

//module
(function(Trex) {
    Object.extend(Trex, /** @lends Trex */ {
        installs: [],
        registers: [],
        modules: [],
        modulesX: [],
        /**
         * Installs component
         * @param {Object} description
         * @param {Object} fn
         */
        install: function(description, fn) {
            fn.desc = '[install] ' + description;
            Trex.installs.push(fn);
        },
        register: function(description, fn) {
            fn.desc = '[register] ' + description;
            Trex.registers.push(fn);
        },
        module: function(description, fn) {
            //console.log(' >>> ' + description);
            fn.desc = '[module] ' + description;
            Trex.modules.push(fn);
        },
        moduleX: function(description, fn) {
            fn.desc = '[moduleX] ' + description;
            Trex.modulesX.push(fn);
        },
        invoke: function(fns, editor, toolbar, sidebar, canvas, config) {
            for (var i = 0, len = fns.length; i < len; i++) {
                var fn = fns[i];
                fn(editor, toolbar, sidebar, canvas, config);
            }
        },
        invokeInstallation: function(editor, toolbar, sidebar, canvas, config) {
            Trex.invoke(Trex.installs, editor, toolbar, sidebar, canvas, config);
        },
        invokeRegisters: function(editor, toolbar, sidebar, canvas, config) {
            Trex.invoke(Trex.registers, editor, toolbar, sidebar, canvas, config);
        },
        invokeModules: function(editor, toolbar, sidebar, canvas, config) {
            Trex.invoke(Trex.modules, editor, toolbar, sidebar, canvas, config);
        },
        group: function() {},
        groupEnd: function() {}
    });
})(Trex);

_WIN.Trex = Trex;

/**
 * @fileoverview
 * 사용자 정의 이벤트를 미리 정의
 */

(function(Trex) {
    /**
     *  @namespace
     *  @name Trex.Ev
     */
    Trex.Ev = /** @lends Trex.Ev */ {
        /** wysiwyg mode */
        __EDITOR_PANEL_MOUSEDOWN: 'editor.panel.mousedown',
        /**
         * Editor에 데이터의 셋팅이 시작되면 발생하는 이벤트
         * @example
         * 	editor.observeJob(Trex.Ev.__EDITOR_LOAD_DATA_BEGIN, function(ev) {
         *	});
         */
        __EDITOR_LOAD_DATA_BEGIN: 'editor.load.data.begin',
        /**
         * Editor에 데이터의 셋팅이 완료되면 발생하는 이벤트
         * @example
         * 	editor.observeJob(Trex.Ev.__EDITOR_LOAD_DATA_END, function(ev) {
         *	});
         */
        __EDITOR_LOAD_DATA_END: 'editor.load.data.end',
        /**
         * wysiwyg 영역에 발생하는 keydown 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYDOWN, function(ev) {
         *	});
         */
        __CANVAS_PANEL_KEYDOWN: 'canvas.panel.keydown',
        /**
         * wysiwyg 영역에 발생하는 keyup 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYUP, function(ev) {
         *	});
         */
        __CANVAS_PANEL_KEYUP: 'canvas.panel.keyup',
        /**
         * wysiwyg 영역에 발생하는 mousedown 이벤트<br/>
         * Element Observer 보다 늦게 실행되며, mouseclick 보다 앞서 실행된다.
         * 경우에 따라 상위 엘리먼트까지 탐색하여 실행하는 Element Observer를 사용한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev) {
         *		//execute function
         *	});
         *  canvas.observeElement({ tag: "img", klass: "txc-image" }, function(element) {
         *		//execute function with element
         *	});
         */
        __CANVAS_PANEL_MOUSEDOWN: 'canvas.panel.mousedown',
        /**
         * wysiwyg 영역에 발생하는 mouseup 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev) {
         *	});
         */
        __CANVAS_PANEL_MOUSEUP: 'canvas.panel.mouseup',
        /**
         * wysiwyg 영역에 발생하는 mouseover 이벤트<br/>
         * wysiwyg 영역에서 마우스를 움직일 때마다 발생하므로 과하게 사용하지 않도록 한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEOVER, function(ev) {
         *	});
         */
        __CANVAS_PANEL_MOUSEOVER: 'canvas.panel.mouseover',
        /**
         * wysiwyg 영역에 발생하는 mouseout 이벤트<br/>
         * wysiwyg 영역에서 마우스를 움직일 때마다 발생하므로 과하게 사용하지 않도록 한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEOUT, function(ev) {
         *	});
         */
        __CANVAS_PANEL_MOUSEOUT: 'canvas.panel.mouseout',
        /**
         * wysiwyg 영역에 발생하는 __CANVAS_PANEL_BLUR 이벤트<br/>
         */
        __CANVAS_PANEL_BLUR: 'canvas.panel.blur',
        /**
         * wysiwyg 영역에 발생하는 movemove 이벤트<br/>
         * wysiwyg 영역에서 마우스를 움직일 때마다 발생하므로 과하게 사용하지 않도록 한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, function(ev) {
         *	});
         */
        __CANVAS_PANEL_MOUSEMOVE: 'canvas.panel.mousemove',
        /**
         * wysiwyg 영역에 발생하는 click 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, function(ev) {
         *	});
         */
        __CANVAS_PANEL_CLICK: 'canvas.panel.click',
        /**
         * wysiwyg 영역에서 발생하는 더블클릭 이벤트<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DBLCLICK, function(ev) {
         *	});
         */
        __CANVAS_PANEL_DBLCLICK: 'canvas.panel.dbclick',
        /**
         * wysiwyg 영역에서 발생하는 붙여넣기 이벤트<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_PASTE, function() {
         *	});
         */
        __CANVAS_PANEL_PASTE: 'canvas.panel.paste',
        /**
         * wysiwyg 영역에서 발생하는 붙여넣기 이벤트<br/>
         */
        __CANVAS_PANEL_PASTE_CUSTOM: 'canvas.panel.paste.custom',
        __CANVAS_PANEL_PASTE_CUSTOM_KEY: 'canvas.panel.paste.custom.key',
        /**
         * wysiwyg 영역에서 발생하는 Drop 이벤트
         */
        __CANVAS_PANEL_DROP: 'canvas.panel.drop',
        /**
         * wysiwyg 영역에서 발생하는 Focus 이벤트
         */
        __CANVAS_PANEL_FOCUS: 'canvas.panel.focus',
        /**
         * wysiwyg 영역에서 발생하는 스크롤 변경 이벤트<br/>
         * 이 이벤트는 wysiwyg 영역의 스크롤 높이가 변경되거나 위치가 변경될 경우 발생한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_SCROLLING, function(ev) {
         *	});
         */
        __CANVAS_PANEL_SCROLLING: 'canvas.panel.scrolling',
        /**
         * wysiwyg 영역이 로드되었을 경우 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(ev) {
         *	});
         */
        __IFRAME_LOAD_COMPLETE: 'iframe.load.complete',
        /**
         * wysiwyg 영역이 loading 되기까지 걸린시간을 알리는 이벤트
         */
        __IFRAME_LOADING_TIME: 'iframe.loading.time',
        /**
         * HTML모드(소스모드) 영역에서 발생하는 click 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, function(ev) {
         *	});
         */
        __CANVAS_SOURCE_PANEL_CLICK: 'canvas.source.panel.click',
        /**
         * HTML모드(소스모드) 영역에서 발생하는 keydown 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_KEYDOWN, function(ev) {
         *	});
         */
        __CANVAS_SOURCE_PANEL_KEYDOWN: 'canvas.source.panel.mousedown',
        /**
         * HTML모드(소스모드) 영역에서 발생하는 mousedown 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_MOUSEDOWN, function(ev) {
         *	});
         */
        __CANVAS_SOURCE_PANEL_MOUSEDOWN: 'canvas.source.panel.mousedown',
        /**
         * 텍스트모드 영역에서 발생하는 click 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, function(ev) {
         *	});
         */
        __CANVAS_TEXT_PANEL_CLICK: 'canvas.text.panel.click',
        /**
         * 모드가 변경될 때 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function(from, to) {
         *		//from - 변경되기 전 모드
         *		//to - 변경되고난 후 모드
         *	});
         */
        __CANVAS_MODE_CHANGE: 'canvas.mode.change',
        /**
         * 전체화면용 canvas로 변경 시 발생
         */
        __CANVAS_FULL_SCREEN_CHANGE: 'canvas.fullscreen.change',
        /**
         * 일반화면용 canvas로 변경 시 발생
         */
        __CANVAS_NORMAL_SCREEN_CHANGE: 'canvas.normalscreen.change',
        /**
         * 테이블에서 우측 컨텍스트 메뉴 표시
         */
        __CANVAS_CONTEXTMENU_SHOW: 'canvas.contextmenu.show',
        /**
         * 툴바의 버튼이 눌렸을 경우 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__TOOL_CLICK, function(identity) {
         *		//identity - tool의 Identity(bold, aligncenter...)
         *	});
         */
        __TOOL_CLICK: 'toolbar.button.click',
        /**
         * 툴이 단축키에 의해 실행 되었을 경우 발생
         */
        __TOOL_SHORTCUT_KEY: 'toolbar.shortcut',
        /**
         * 컨텍스트 메뉴 클릭시 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__TOOL_CLICK, function(identity) {
         *		//identity - tool의 Identity(bold, aligncenter...)
         *	});
         */
        __CONTEXTMENU_CLICK: 'contextmenu.click',
        /**
         * Editor.save()가 호출되었을 경우 발생하는 사용자 정의 이벤트<br/>
         * 실제 form이 submit이 되기 전에 발생한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__ON_SUBMIT, function(editor) {
         *		//editor - editor 객체
         *	});
         */
        __ON_SUBMIT: "editor.submit",
        /**
         * 에디터 래퍼의 너비가 변경된 후 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_WRAP_WIDTH_CHANGE, function() {
         *	});
         */
        __CANVAS_WRAP_WIDTH_CHANGE: 'canvas.wrap.width.change',
        /**
         * 에디터의 높이가 변경된 후 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(height) {
         *		//height - 변경된 높이
         *	});
         */
        __CANVAS_HEIGHT_CHANGE: 'canvas.height.change',
        /**
         * wysiwyg 영역에서 키이벤트나 마우스이벤트가 발생할 경우 발생하는 사용자 정의 이벤트<br/>
         * 주로 툴바 버튼의 상태를 표시할 때에 사용한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
         *	});
         */
        __CANVAS_PANEL_QUERY_STATUS: 'canvas.panel.style.change',
        /**
         * wysiwyg 영역에서 delete 키가 눌렸을 경우 발생하는 사용자 정의 이벤트<br/>
         * 주로 컨텐츠와 동기화를 맞추기 위해 사용한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING, function() {
         *	});
         */
        __CANVAS_PANEL_DELETE_SOMETHING: 'canvas.panel.delkey.press',
        /**
         * Entry Box에 Entry가 추가되었을 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
         *		//생성된 entry 객체를 인자로 받는다.
         *	});
         */
        __ENTRYBOX_ENTRY_ADDED: 'entrybox.entryadded',
        /**
         * wysiwyg 영역에서 backspace 키가 눌렸을 경우 발생하는 사용자 정의 이벤트<br/>
         * 테이블 삭제를 위해 사용한다.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_BACKSPACE_TABLE, function() {
         *	});
         */
        __CANVAS_PANEL_BACKSPACE_TABLE: 'canvas.panel.backspace.table',
        /**
         * Entry Box의 Entry가 수정되었을 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_MODIFIED, function(entry) {
         *		//수정된 entry 객체를 인자로 받는다.
         *	});
         */
        __ENTRYBOX_ENTRY_MODIFIED: 'entrybox.entrymodified',
        /**
         * Entry Box에서 Entry가 제거되었을 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
         *		//삭제될 entry 객체를 인자로 받는다.
         *	});
         */
        __ENTRYBOX_ENTRY_REMOVED: 'entrybox.entryremoved',
        /**
         * Entry Box에서 모든 Entry가 제거되었을 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED, function() {
         *	});
         */
        __ENTRYBOX_ALL_ENTRY_REMOVED: 'entrybox.removed.all.perfectly',
        /**
         * Entry Box에서 Entry의 추가/수정/삭제로 capacity가 변경 될 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_CAPACITY_UPDATE, function(capacity) {
         *	});
         */
        __ENTRYBOX_CAPACITY_UPDATE: 'entrybox.capacity.update',
        /**
         * Attach Box가 보여질 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_SHOW, function() {
         *	});
         */
        __ATTACHBOX_SHOW: 'attachbox.show',
        /**
         * Attach Box가 감춰질 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_HIDE, function() {
         *	});
         */
        __ATTACHBOX_HIDE: 'attachbox.hide',
        /**
         * fullscreen 상태에서 Attach Box가 보여질 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_SHOW, function() {
         *	});
         */
        __ATTACHBOX_FULLSCREEN_SHOW: 'attachbox.fullscreen.show',
        /**
         * fullscreen 상태에서 Attach Box가 감춰질 때 발생하는 사용자 정의 이벤트
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_HIDE, function() {
         *	});
         */
        __ATTACHBOX_FULLSCREEN_HIDE: 'attachbox.fullscreen.hide',
        /**
         * 에디터 페이지를 벗어나기 전에 발생하는 사용자 정의 이벤트
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_BEFORE_UNLOAD, function() {
         *	});
         */
        __CANVAS_BEFORE_UNLOAD: 'canvas.unload',
        /**
         * 각 첨부가 추가될 때 발생하는 사용자 정의 이벤트<br/>
         * entry가 생성되고 본문에 삽입이 완료되고 호출된다.
         * 실제로는 entry 부분이 첨부의 Identity(image, movie, media...)로 대체된다.
         * @abstract
         * @example
         * 	canvas.observeJob('canvas.movie.added', function(entry) {
         *		//생성된 entry 객체를 인자로 받는다.
         *	});
         */
        __CANVAS_ENTRY_ADDED: 'canvas.entry.added',
        /**
         * 툴을 이용해 wysiwyg에 요소가 삽입이 될 때 발생하는 사용자 정의 이벤트
         * @abstract
         * @example
         * 	toolbar.observeJob('cmd.textbox.added', function(node) {
         *		//필요에 따라 만들어진 요소 엘리먼트
         *	});
         */
        __COMMAND_NODE_ADDED: 'cmd.entry.added',
        /**
         * 왼쪽 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_LEFT: 'align.left',
        /**
         * 가운데 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_CENTER: 'align.center',
        /**
         * 오른쪽 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_RIGHT: 'align.right',
        /**
         * 양쪽 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_FULL: 'align.full',
        /**
         * 이미지 왼쪽 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_IMG_LEFT: 'align.img.left',
        /**
         * 이미지 가운데 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_IMG_CENTER: 'align.img.center',
        /**
         * 이미지 왼쪽흐름 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_IMG_FLOAT_LEFT: 'align.img.floatleft',
        /**
         * 이미지 오른쪽흐름 정렬을 실행하고서 발생하는 사용자 정의 이벤트
         * @private
         */
        __CMD_ALIGN_IMG_FLOAT_RIGHT: 'align.img.floatright',
        /**
         * 툴바의 축소를을 실행하고 발생하는 사용자 정의 이벤트
         */
        __CMD_ADVANCED_FOLD: 'toolbar.advanced.fold',
        /**
         * 툴바의 확장을 실행하고 발생하는 사용자 정의 이벤트
         */
        __CMD_ADVANCED_SPREAD: 'toolbar.advanced.spread',
        /**
         * table 의 border 를 조정하는 세가지 속성중에 한가지가 변경될 때 발생함.
         * border 의 세가지 속성: cellslinecolor, cellslineheight, cellslinestyle.
         * @private
         */
        __TOOL_CELL_LINE_CHANGE: 'tool.cell.line.change',
        /**
         * 에디터 로딩할 때 현재 모드와 config의 모드가 다를 때 발생하는 사용자 정의 이벤트
         * @private
         */
        __CANVAS_MODE_INITIALIZE: 'canvas.mode.initialize',
        /**
         * 에디터 로딩할 때 컨텐츠를 초기화한 후 발생하는 사용자 정의 이벤트
         * @private
         */
        __CANVAS_DATA_INITIALIZE: 'canvas.load.data',
        /**
         * Attach Box의 ENTRY의 상태가 변경될 때 발생하는 사용자 정의 이벤트
         * @private
         */
        __ENTRYBOX_ENTRY_REFRESH: 'entrybox.entryrefresh',
        /**
         * 정보첨부가 삽입될 때 발생하는 사용자 정의 이벤트
         * @private
         */
        __PASTE_SEARCHRESULT: 'trex.paste.info',
        /**
         * 에디터에서 런타임에러가 났을 때 발생하는 사용자 정의 이벤트
         * @private
         */
        __RUNTIME_EXCEPTION: "editor.runtime.exception",
        /**
         * 에디터 장애 로그를 남길 때 발생하는 사용자 정의 이벤트<br/>
         * 로그를 전송한 후 실행 된다.
         * @private
         */
        __REPORT_TO_MAGPIE: "editor.report.magpie",
        /**
         * 자동저장 리스트를 열 때 발생하는 사용자 정의 이벤트
         * @private
         */
        __SHOULD_CLOSE_MENUS: "editor.shouldclosemenus",
        /**
         * wysiwyg 영역에서 발생하는 이미지의 더블클릭 이벤트<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_IMAGE_PLACEHOLDER_DBLCLICK, function(ev) {
         *	});
         */
        __CANVAS_IMAGE_PLACEHOLDER_DBLCLICK: 'canvas.image.placeholder.dbclick',
        /**
         * 툴바의 레이어형 메뉴가 화면에 표시되면 호출.
         */
        __MENU_LAYER_SHOW: 'menu.layer.show',
        /**
         * 툴바의 레이어형 메뉴가 화면에 사라지면 호출.
         */
        __MENU_LAYER_HIDE: 'menu.layer.hide',
        /**
         * 툴바의 레이어형 메뉴의 크기가 변경되면 호출.
         */
        __MENU_LAYER_CHANGE_SIZE: 'menu.layer.change.size'

    };
})(Trex);

/** @namespace */
var TrexEvent = {
    /**
     * fires observer for target element
     * @param {Object} el
     * @param {Object} handles
     */
    fire: function(el, handles) {
        if (el && el.tagName) {
            var fn = handles[el.tagName.toLowerCase()];
            if (fn) {
                fn(el, handles);
            } else {
                TrexEvent.propagateToParent(el, handles);
            }
        } else {
            // console.log("Not Supported Type : " + el);
        }
    },
    propagateToParent: function(element, handles) {
        var _el = element.parentNode;
        if (_el && _el.tagName && _el.tagName.toLowerCase) {
            var fn = handles[_el.tagName.toLowerCase()];
            if (fn) {
                fn(_el, handles);
            } else {
                TrexEvent.propagateToParent(_el, handles);
            }
        }
    },
    stopPropagation: function() {}
};

var textboxOption = function(data, padding, bgcolor, border) {
    return {
        data: data,
        style: {
            padding: padding,
            backgroundColor: bgcolor,
            border: border
        }
    };
};
Trex.__CONFIG_COMMON = {
    thumbs: {
        options: [
            { color: "#FF0000" }, { color: "#FF5E00" }, { color: "#FFBB00" }, { color: "#FFE400" }, { color: "#ABF200" }, { color: "#1FDA11" }, { color: "#00D8FF" }, { color: "#0055FF" }, { color: "#0900FF" }, { color: "#6600FF" }, { color: "#FF00DD" }, { color: "#FF007F" }, { color: "#000000" }, { color: "#FFFFFF" },
            { color: "#FFD8D8" }, { color: "#FAE0D4" }, { color: "#FAECC5" }, { color: "#FAF4C0" }, { color: "#E4F7BA" }, { color: "#CEFBC9" }, { color: "#D4F4FA" }, { color: "#D9E5FF" }, { color: "#DAD9FF" }, { color: "#E8D9FF" }, { color: "#FFD9FA" }, { color: "#FFD9EC" }, { color: "#F6F6F6" }, { color: "#EAEAEA" },
            { color: "#FFA7A7" }, { color: "#FFC19E" }, { color: "#FFE08C" }, { color: "#FAED7D" }, { color: "#CEF279" }, { color: "#B7F0B1" }, { color: "#B2EBF4" }, { color: "#B2CCFF" }, { color: "#B5B2FF" }, { color: "#D1B2FF" }, { color: "#FFB2F5" }, { color: "#FFB2D9" }, { color: "#D5D5D5" }, { color: "#BDBDBD" },
            { color: "#F15F5F" }, { color: "#F29661" }, { color: "#F2CB61" }, { color: "#E5D85C" }, { color: "#BCE55C" }, { color: "#86E57F" }, { color: "#5CD1E5" }, { color: "#6699FF" }, { color: "#6B66FF" }, { color: "#A366FF" }, { color: "#F261DF" }, { color: "#F261AA" }, { color: "#A6A6A6" }, { color: "#8C8C8C" },
            { color: "#CC3D3D" }, { color: "#CC723D" }, { color: "#CCA63D" }, { color: "#C4B73B" }, { color: "#9FC93C" }, { color: "#47C83E" }, { color: "#3DB7CC" }, { color: "#4174D9" }, { color: "#4641D9" }, { color: "#7E41D9" }, { color: "#D941C5" }, { color: "#D9418D" }, { color: "#747474" }, { color: "#5D5D5D" },
            { color: "#980000" }, { color: "#993800" }, { color: "#997000" }, { color: "#998A00" }, { color: "#6B9900" }, { color: "#2F9D27" }, { color: "#008299" }, { color: "#003399" }, { color: "#050099" }, { color: "#3D0099" }, { color: "#990085" }, { color: "#99004C" }, { color: "#4C4C4C" }, { color: "#353535" },
            { color: "#670000" }, { color: "#662500" }, { color: "#664B00" }, { color: "#665C00" }, { color: "#476600" }, { color: "#22741C" }, { color: "#005766" }, { color: "#002266" }, { color: "#030066" }, { color: "#290066" }, { color: "#660058" }, { color: "#660033" }, { color: "#212121" }, { color: "#000000" }
        ],
        transparent: {
            color: "transparent",
            border: "#999999",
            image: "#iconpath/ic_transparent4.gif?open&v=2",
            thumb: "#iconpath/txt_transparent.gif?open&v=2",
            thumbImage: "#iconpath/color_transparent_prev.gif?open&v=2"
        }
    },
    textbox: {
        options: [
            textboxOption('txc-textbox1', '10px', '#ffffff', '1px solid #f7f7f7'),
            textboxOption('txc-textbox2', '10px', '#eeeeee', '1px solid #eeeeee'),
            textboxOption('txc-textbox3', '10px', '#fefeb8', '1px solid #fefeb8'),
            textboxOption('txc-textbox4', '10px', '#fedec7', '1px solid #fedec7'),
            textboxOption('txc-textbox5', '10px', '#e7fdb5', '1px solid #e7fdb5'),
            textboxOption('txc-textbox6', '10px', '#dbe8fb', '1px solid #dbe8fb'),

            textboxOption('txc-textbox7', '10px', '#ffffff', '1px dashed #cbcbcb'),
            textboxOption('txc-textbox8', '10px', '#eeeeee', '1px dashed #c1c1c1'),
            textboxOption('txc-textbox9', '10px', '#fefeb8', '1px dashed #f3c534'),
            textboxOption('txc-textbox10', '10px', '#fedec7', '1px dashed #fe8943'),
            textboxOption('txc-textbox11', '10px', '#e7fdb5', '1px dashed #9fd331'),
            textboxOption('txc-textbox12', '10px', '#dbe8fb', '1px dashed #79a5e4'),

            textboxOption('txc-textbox13', '10px', '#ffffff', '1px solid #cbcbcb'),
            textboxOption('txc-textbox14', '10px', '#eeeeee', '1px solid #c1c1c1'),
            textboxOption('txc-textbox15', '10px', '#fefeb8', '1px solid #f3c534'),
            textboxOption('txc-textbox16', '10px', '#fedec7', '1px solid #fe8943'),
            textboxOption('txc-textbox17', '10px', '#e7fdb5', '1px solid #9fd331'),
            textboxOption('txc-textbox18', '10px', '#dbe8fb', '1px solid #79a5e4'),

            textboxOption('txc-textbox19', '10px', '#ffffff', '3px double #cbcbcb'),
            textboxOption('txc-textbox20', '10px', '#eeeeee', '3px double #c1c1c1'),
            textboxOption('txc-textbox21', '10px', '#fefeb8', '3px double #f3c534'),
            textboxOption('txc-textbox22', '10px', '#fedec7', '3px double #fe8943'),
            textboxOption('txc-textbox23', '10px', '#e7fdb5', '3px double #9fd331'),
            textboxOption('txc-textbox24', '10px', '#dbe8fb', '3px double #79a5e4')
        ]
    }
};

/**
 * 에디터 전반적인 설정을 관리하는 클래스로 각 함수를 static 하게 접근할 수 있다.
 *
 * @class
 */
var TrexConfig = function() {
    //preset < daumx < project < page
    var __IS_SETUP = _FALSE;
    var __POST_PROCESSOR = [];
    var __TREX_PARAM = {};
    var __TREX_CONFIGURE = {
        wrapper: "tx_trex_container",
        form: 'tx_editor_form',
        txIconPath: "images/icon/editor/",
        txDecoPath: "images/deco/contents/",
        params: [],
        events: {
            preventUnload: _TRUE,
            useHotKey: _TRUE
        },
        save: {},
        adaptor: {},
        toolbar: {},
        sidebar: {
            attachbox: {},
            embeder: {},
            attacher: {},
            searcher: {}
        },
        contextmenu: {},
        plugin: {}
    };

    var _createAnchors = function() {
        return {
            "Tool": __TREX_CONFIGURE.toolbar,
            "Sidebar": __TREX_CONFIGURE.sidebar,
            "Plugin": __TREX_CONFIGURE.plugin,
            "Adaptor": __TREX_CONFIGURE.adaptor,
            "Save": __TREX_CONFIGURE.save,
            "Attacher": __TREX_CONFIGURE.sidebar.attacher,
            "Embeder": __TREX_CONFIGURE.sidebar.embeder,
            "Searcher": __TREX_CONFIGURE.sidebar.searcher,
            "ContextMenu": __TREX_CONFIGURE.contextmenu
        };
    };

    var _addParameter = function(tname, pname) {
        if (__IS_SETUP) {
            throw new Error("configure is already setup (addParameter)")
        }
        __TREX_PARAM[tname] = pname;
    };

    var _trexConfig = /** @lends TrexConfig */ {
        /**
         * url을 에디터 설정값과 주어진 파라미터 값으로 변환하여 넘겨준다.
         * @function
         * @param {String} url - url
         * @param {Object} params - 키,값 쌍으로 이루어진 데이터
         * @returns {String} 변환된 url
         * @example
         * 		TrexConfig.getUrl("#host#path/pages/trex/image.html?username=#username", {
         * 			'username': 'daumeditor'
         * 		});
         */
        getUrl: function(url, params) {
            if (typeof url !== 'string') { return url; };
            var loader = _WIN['EditorJSLoader'] || opener && opener['EditorJSLoader'] || (PopupUtil && PopupUtil.getOpener()['EditorJSLoader']);
            url = url.replace(/#host#path\/pages\//g, loader.getPageBasePath());
            url = url.replace(/#host/g, __TREX_CONFIGURE["txHost"]);
            url = url.replace(/#path\/?/g, __TREX_CONFIGURE["txPath"]);
            url = url.replace(/#imageeditorpath/g, __TREX_CONFIGURE["imageEditorPath"]);
            
            for (var _name in __TREX_PARAM) {
                url = url.replace(new RegExp("#".concat(_name), "g"), __TREX_CONFIGURE[__TREX_PARAM[_name]]);
            }

            if (params) {
                for (var name in params) {
                    url = url.replace(new RegExp("#".concat(name), "g"), params[name]);
                }
            }
            return url;
        },
        /**
         * 팝업창을 띄울때 옵션을 문자열로 만들어 넘겨준다.
         * @function
         * @param {Object} features - 키,값 쌍으로 이루어진 데이터
         * @returns {String} 옵션 문자열
         * @example
         * 		TrexConfig.getPopFeatures({ left:250, top:65, width:797, height:644 });
         */
        getPopFeatures: function(features) {
            if (features == _NULL) return _NULL;
            if (typeof(features) === "string") { //redefine
                return features;
            }
            var popFeatures = [];
            ["toolbar", "location", "directories", "menubar"].each(function(name) {
                popFeatures.push(name + "=" + (features[name] || "no"));
            });
            ["scrollbars", "resizable"].each(function(name) {
                popFeatures.push(name + "=" + (features[name] || "yes"));
            });
            ["width", "height"].each(function(name) {
                popFeatures.push(name + "=" + (features[name] || "500"));
            });
            ["left", "top"].each(function(name) {
                popFeatures.push(name + "=" + (features[name] || "100"));
            });
            return popFeatures.join(",");
        },
        /**
         * 컨텐츠 삽입용 이미지의 상위 url을 넘겨준다. <br/>
         * txDecoPath 값이 셋팅된 경우는 해당 url을 넘겨준다.
         * @function
         * @param {String} url - url
         * @param {String} subpath - 하위 디렉터리 (optional)
         * @returns {String} 변환된 컨텐츠 삽입용 이미지url
         */
        getDecoPath: function(url) {
            return url.replace(/#decopath\/?/, this.getUrl(__TREX_CONFIGURE["txDecoPath"]));
        },
        /**
         * 에디터에서 사용되는 이미지의 상위 url을 넘겨준다. <br/>
         * txIconPath 값이 셋팅된 경우는 해당 url을 넘겨준다.
         * @function
         * @param {String} url - url
         * @param {String} subpath - 하위 디렉터리 (optional)
         * @returns {String} 에디터에서 사용되는 이미지url
         */
        getIconPath: function(url) {
            return url.replace(/#iconpath\/?/, this.getUrl(__TREX_CONFIGURE["txIconPath"]));
        },
        /**
         * 에디터 로딩이 완료되면 설정값을 셋업시키는 함수로
         * postprocessing로 등록된 함수들을 실행하며
         * 이후에는 설정값을 추가할 수 없다.
         * @private
         * @function
         * @param {Object} config - new Editor() 할 때 입력한 설정값
         * @returns {Object} 셋업된 설정값
         */
        setup: function(config) {
            $tx.deepcopy(__TREX_CONFIGURE, config);

            __TREX_CONFIGURE.params.each(function(name) {
                _addParameter(name, name);
            });
            __POST_PROCESSOR.each(function(fn) {
                fn(__TREX_CONFIGURE);
            });

            __IS_SETUP = _TRUE;

            this.setupVersion();
            return __TREX_CONFIGURE;
        },
        setupVersion: function() {
            // 다른 곳에서 txVersion 을 사용할 수도 있기에 호환을 위해 txVersion 추가
            __TREX_CONFIGURE.txVersion = Editor.version;
        },
        /**
         * 파라미터를 추가한다.<br/>
         * 파라미터란 getUrl 할 때 기본으로 변환할 키,값들을 정의해놓은 데이터
         * @function
         * @param {String} tname - url에 포함될 id
         * @param {String} pname - 설정값에 존재하는 id
         * @example
         * 		TrexConfig.addParameter('host', 'txHost');
         */
        addParameter: function(tname, pname) {
            _addParameter(tname, pname);
        },
        /**
         * 주어진 설정값을 deep copy로 복사한다.
         * @function
         * @param {Object} config - 주어진 설정값
         */
        clone: function(config) {
            return $tx.deepcopy({}, config);
        },
        /**
         * 주어진 설정값에 새로운 설정값들을 deep copy로 복사한다.
         * @function
         * @param {Object} config - 첫번째 인자는 주어진 설정값, 그 이후는 새로운 설정값들
         * @example
         * 		TrexConfig.merge(config, { 'id': 'tx_happy' }, { 'options': [1,2,3] });
         */
        merge: function() {
            var _config = {};
            $A(arguments).each(function(source) {
                $tx.deepcopy(_config, source);
            });
            return _config;
        }
    };

    /**
     * 주어진 설정값을 root 설정값에 추가한다.
     * @name add
     * @memberOf TrexConfig
     * @function
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    _trexConfig["add"] = function(config, postprocessing) {
        if (__IS_SETUP) {
            throw new Error("configure is already setup (mergeConfig)")
        }
        $tx.deepcopy(__TREX_CONFIGURE, config);
        if (postprocessing) {
            __POST_PROCESSOR.push(postprocessing);
        }
    };
    /**
     * 주어진 키로 설정값을 리턴한다.
     * @name get
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키
     */
    _trexConfig["get"] = function(key) {
        return __TREX_CONFIGURE[key];
    };

    /**
     * 주어진 키로 주어진 설정값을 root/toolbar 아래에 추가한다.
     * @name addTool
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/sidebar 아래에 추가한다.
     * @name addSidebar
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/plugin 아래에 추가한다.
     * @name addPlugin
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/adaptor 아래에 추가한다.
     * @name addAdaptor
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/save 아래에 추가한다.
     * @name addSave
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/sidebar/attacher 아래에 추가한다.
     * @name addAttacher
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/sidebar/embeder 아래에 추가한다.
     * @name addEmbeder
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/sidebar/searcher 아래에 추가한다.
     * @name addSearcher
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    /**
     * 주어진 키로 주어진 설정값을 root/contextmenu 아래에 추가한다.
     * @name addContextMenu
     * @memberOf TrexConfig
     * @function
     * @param {String} key - 주어진 키값
     * @param {Object} config - 주어진 설정값
     * @param {Function} postprocessing - 에디터가 로딩된 후 처리할 함수 (optional)
     */
    var _addConfig = function(key, config, postprocessing) {
        if (__IS_SETUP) {
            throw new Error("configure is already setup (mergeConfig)")
        }
        this[key] = this[key] || {};
        $tx.deepcopy(this[key], config);
        if (postprocessing) {
            __POST_PROCESSOR.push(postprocessing);
        }
    };

    /**
     * 주어진 키로 root/toolbar[key]의 설정값을 리턴한다.
     * @name getTool
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/sidebar[key]의 설정값을 리턴한다.
     * @name getSidebar
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/adaptor[key]의 설정값을 리턴한다.
     * @name getAdaptor
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/save[key]의 설정값을 리턴한다.
     * @name getSave
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/sidebar/attacher[key]의 설정값을 리턴한다.
     * @name getAttacher
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/sidebar/embeder[key]의 설정값을 리턴한다.
     * @name getEmbeder
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/sidebar/searcher[key]의 설정값을 리턴한다.
     * @name getSearcher
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    /**
     * 주어진 키로 root/contextmenu[key]의 설정값을 리턴한다.
     * @name getContextMenu
     * @memberOf TrexConfig
     * @function
     * @param {String,Object} key - 주어진 키
     */
    var _getConfig = function(key) {
        return this[key];
    };

    var _anchors = _createAnchors();
    for (var _name in _anchors) {
        _trexConfig["add" + _name] = _addConfig.bind(_anchors[_name]);
        _trexConfig["get" + _name] = _getConfig.bind(_anchors[_name]);
    }

    return _trexConfig;

}();

_WIN.TrexConfig = TrexConfig;

var TrexMessage = function() {
    var __MESSAGES = {};

    function decorateIconPath(message) {
        return (message.indexOf("#iconpath") > -1) ?
            TrexConfig.getIconPath(message) : message;
    }

    function decorateDecoPath(message) {
        return (message.indexOf("#decopath") > -1) ?
            TrexConfig.getDecoPath(message) : message;
    }

    return {
        getMsg: function(msgid) {
            var message = __MESSAGES[msgid] || "";
            return decorateIconPath(decorateDecoPath(message));
        },

        addMsg: function(messages) {
            $tx.deepcopy(__MESSAGES, messages);
        },

        printAll: function() {
            for (var name in __MESSAGES) {
                if (__MESSAGES.hasOwnProperty(name)) {
                    // console.log(name + '=' + __MESSAGES[name]);
                }
            }
        }
    };
}();

_WIN.TXMSG = TrexMessage.getMsg;
_WIN.TrexMessage = TrexMessage;

var EditorConfigBuilder = function(defaultConfigObject /* optional */ ) {
    this.config = defaultConfigObject || {};
};

EditorConfigBuilder.prototype.set = function(path, value) {
    var splitedPath = path.split(".");
    var lastKey = splitedPath[splitedPath.length - 1];

    var curObj = this.config;
    for (var i = 0; i < splitedPath.length - 1; i++) {
        var key = splitedPath[i];
        if (!curObj[key]) {
            curObj[key] = {};
        }
        curObj = curObj[key];
    }

    if ($tx.isPrimitiveType(value)) {
        curObj[lastKey] = value;
    } else {
        if (!curObj[lastKey]) {
            curObj[lastKey] = {};
        }
        $tx.deepcopy(curObj[lastKey], value);
    }
};

EditorConfigBuilder.prototype.getConfig = function() {
    return this.config;
};

_WIN.EditorConfigBuilder = EditorConfigBuilder;

Trex.MarkupTemplate = {};

(function() {
    var __TEMPLATES = {};
    Trex.define(Trex.MarkupTemplate, {
        add: function(name, template) {
            __TEMPLATES[name] = template;
        },
        get: function(name) {
            if (!__TEMPLATES[name]) {
                return {
                    evaluate: function() { return ""; },
                    evaluateToDom: function() { return ""; }
                };
            }
            if (typeof(__TEMPLATES[name]) == 'string') {
                var _template = __TEMPLATES[name].replace(/@[\w\.]+/g, function(full) {
                    return TXMSG(full);
                });
                __TEMPLATES[name] = new Template(_template);
            }
            return __TEMPLATES[name];
        },
        splitList: function(rows, cols, items) {
            var _matrix = { 'row': [] };
            var _total = items.length;
            var _matrix_row = _matrix.row;
            for (var row = 0; row < rows; row++) {
                _matrix_row.push({ 'col': [] });
                var _matrix_col = _matrix_row.last().col;
                for (var col = 0; col < cols; col++) {
                    var _item = {
                        'image': '',
                        'data': '&nbsp;',
                        'klass': ''
                    };
                    if (row * cols + col < _total) {
                        if (typeof(items[row * cols + col]) == 'string') {
                            _item.data = items[row * cols + col];
                        } else {
                            _item = Object.extend(_item, items[row * cols + col]);
                        }
                    }
                    _matrix_col.push(_item);
                }
            }
            return _matrix;
        }
    });
})();


/** @namespace */
var $tom = {};

(function() {
    var __TRANSLATIONS = {
        '%body': ['body'],
        '%text': ['#text', 'br'],
        '%element': ['#element'],
        '%control': ['img', 'object', 'hr', 'table', 'button', 'iframe'], //['input','select','textarea','label','br'],
        '%inline': ['span', 'font', 'u', 'i', 'b', 'em', 'strong', 'big', 'small', 'a', 'sub', 'sup', 'span'], //['tt','dfn','code','samp','kbd','var','cite','abbr','acronym','img','object','br','script','map','q','bdo','input','select','textarea','label','button'],
        '%block': ['p', 'div', 'ul', 'ol', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre', 'dl', 'hr', 'table', 'button'], //['noscript','blockquote','form','fieldset','address'], !button
        '%paragraph': ['p', 'li', 'dd', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'td', 'th', 'div', 'caption'], //!button
        '%wrapper': ['div', 'ul', 'ol', 'dl', 'pre', 'xmp', 'table', 'button', 'blockquote'], // FTDUEDTR-1412
        '%innergroup': ['li', 'dd', 'dt', 'td', 'th'],
        '%outergroup': ['ul', 'ol', 'dl', 'tr', 'tbody', 'thead', 'tfoot', 'table'],
        '%tablegroup': ['td', 'th', 'tr', 'tbody', 'thead', 'tfoot', 'table'],
        '%listgroup': ['li', 'ul', 'ol'],
        '%datagroup': ['dd', 'dt', 'dl'],
        '%listhead': ['ul', 'ol']
    };

    var __TRANSLATIONS_MAP = {}; //for caching
    for (var _ptrn in __TRANSLATIONS) {
        __TRANSLATIONS_MAP[_ptrn] = {};
        if (__TRANSLATIONS[_ptrn]) {
            $A(__TRANSLATIONS[_ptrn]).each(function(tag) {
                __TRANSLATIONS_MAP[_ptrn][tag] = _TRUE;
            });
        }
    }

    function createMap(patterns) {
        var _map = {};
        var _patterns = patterns.split(",");
        _patterns.each(function(pattern) {
            if (__TRANSLATIONS_MAP[pattern]) {
                for (var _part in __TRANSLATIONS_MAP[pattern]) {
                    _map[_part] = _TRUE;
                }
            } else {
                _map[pattern] = _TRUE;
            }
        });
        return _map;
    }

    var Translator = Trex.Class.create({
        initialize: function(patterns) {
            this.patterns = patterns;
            this.map = createMap(patterns);
        },
        hasParts: function() {
            return (this.patterns.length > 0);
        },
        include: function(partPtrn) {
            var _partMap = createMap(partPtrn);
            for (var _part in _partMap) {
                if (this.map[_part]) {
                    return _TRUE;
                }
            }
            return _FALSE;
        },
        memberOf: function(wholePtrn) {
            var _wholeMap = createMap(wholePtrn);
            for (var _part in this.map) {
                if (_wholeMap[_part]) {
                    return _TRUE;
                }
            }
            return _FALSE;
        },
        extract: function(wholePtrn) {
            var _wholeMap = createMap(wholePtrn);
            var _matches = [];
            for (var _part in this.map) {
                if (_wholeMap[_part]) {
                    _matches.push(_part);
                }
            }
            return $tom.translate(_matches.join(","));
        },
        getExpression: function() {
            if (!this.exprs) {
                var _exprs = [];
                for (var _part in this.map) {
                    _exprs.push(_part);
                }
                this.exprs = _exprs.join(",");
            }
            return this.exprs;
        }
    });

    var __TRANSLATOR_CACHES = {}; //for caching
    Object.extend($tom, {
        translate: function(pattern) {
            if (!__TRANSLATOR_CACHES[pattern]) {
                __TRANSLATOR_CACHES[pattern] = new Translator(pattern);
            }
            return __TRANSLATOR_CACHES[pattern];
        }
    });

})();

Object.extend($tom, {
    __POSITION: {
        __START_OF_TEXT: -1,
        __MIDDLE_OF_TEXT: 0,
        __END_OF_TEXT: 1,
        __EMPTY_TEXT: -2
    }
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * node가 HTMLElement이면 true를 아니면 false를 반환한다.
     * @function
     */
    isElement: function(node) {
        return node && node.nodeType == 1;
    },
    /**
     * node가 <body> 요소이면 true를 반환한다.
     * @function
     */
    isBody: function(node) {
        return $tom.isElement(node) && node.tagName == "BODY";
    },
    /**
     * node가 아래에 나열된 block 요소이면 true 를 반환한다.
     * 'p','div','ul','ol','h1','h2','h3','h4','h5','h6','pre','dl','hr','table','button'
     * @function
     */
    isBlock: function(node) {
        return $tom.kindOf(node, '%block');
    },
    /**
     * node가 아래에 나열된 요소이면 true 를 반환한다.
     * 'p','li','dd','dt','h1','h2','h3','h4','h5','h6','td','th','div','caption'
     * @function
     */
    isParagraph: function(node) {
        return $tom.kindOf(node, '%paragraph');
    },
    /**
     * node가 텍스트이거나 <br> 요소이면 true 를 반환한다.
     * @function
     */
    isText: function(node) {
        return $tom.kindOf(node, '%text');
    },
    /**
     * node가 아래에 나열된 요소이면 true를 반환한다.
     * 'img','object','hr','table','button'
     * @function
     */
    isControl: function(node) {
        return $tom.kindOf(node, '%control');
    },
    /**
     * element가 tagName면 true를 반환한다.
     * @function
     */
    isTagName: function(element, tagName) {
        tagName = tagName.toUpperCase();
        return element && element.tagName === tagName;

    },
    getOwnerDocument: function(node) {
        return node.ownerDocument || node.document;
    },
    /**
     * node의 이름을 반환한다.
     * @function
     */
    getName: function(node) {
        return ((node && node.nodeType == 1) ? node.nodeName.toLowerCase() : "");
    },
    /**
     * node의 text content 를 반환한다.
     * @function
     */
    getText: function(node) {
        return node.textContent || node.text || node.innerText || "";
    },
    /**
     * 요소의 nodeType 1이면 child 노드의 길이를, nodeType 3이면 nodeValue의 길이를 반환한다.
     * @function
     */
    getLength: function(node) {
        if (!node) {
            return 0;
        }
        if (node.nodeType == 1) {
            return node.childNodes.length;
        } else if (node.nodeType == 3) {
            return node.nodeValue.length;
        }
        return 0;
    },
    /**
     * node가 같은 레벨의 요소 중 몇 번째인지 인덱스값을 반환한다.
     * @function
     */
    indexOf: function(node) {
        if (!node) {
            return -1;
        }
        var _pNode = node.parentNode;
        for (var i = 0, len = _pNode.childNodes.length, childNodes = _pNode.childNodes; i < len; i++) {
            if (childNodes[i] == node) {
                return i;
            }
        }
        return -1;
    },
    /**
     * node가 textNode이면 공백을 제거한 nodeValue의 내용이 존재하면 true를 반환한다.
     * @function
     */
    hasContent: function(node, ignoreZWNBS) {
        if (!node || node.nodeType != 3) {
            return _TRUE;
        }

        var _text = $tom.removeMeaninglessSpace(node.nodeValue);
        if (ignoreZWNBS) {
            _text = _text.replace(Trex.__WORD_JOINER_REGEXP, "");
        }
        return (_text != "");
    },
    removeEmptyTextNode: function(textNode) {
        if (textNode && textNode.nodeType == 3 && !textNode.nodeValue) {
            $tom.remove(textNode);
        }
    },
    hasUsefulChildren: function(node, ignoreZWNBS) {
        if (!node) {
            return _FALSE;
        }
        var _inner = $tom.removeMeaninglessSpace(node.innerHTML);
        if (ignoreZWNBS) {
            _inner = _inner.replace(Trex.__WORD_JOINER_REGEXP, "");
        }
        if (!_inner) {
            return _FALSE;
        }
        if (_inner.stripTags()) {
            return _TRUE;
        }
        if (_inner.search(/<(img|br|hr)\s?[^>]*>/i) > -1) {
            return _TRUE;
        }
        if (_inner.search(/<span\sid="?tx_(start|end)_marker"?><\/span>/i) > -1) {
            return _TRUE;
        }
        return _FALSE;
    },
    /**
     * node에 의미있는 데이터가 있는지 확인한다.
     * @function
     */
    hasData: function(node, ignoreStuff) {
        if (!node) {
            return _FALSE;
        }

        var _inner = '';
        if (node.nodeType == 1) {
            _inner = node.innerHTML;
        } else {
            _inner = node.nodeValue;
        }
        _inner = $tom.removeMeaninglessSpace(_inner);
        if (_inner.trim() == '') { // #PCCAFEQA-11
            return _FALSE;
        }
        if (_inner.stripTags() != '') {
            return _TRUE;
        }
        if (ignoreStuff) {
            return _FALSE;
        }
        if (_inner.search(/<br\s?\/?>/i) > -1) {
            return _TRUE;
        }
        return _FALSE;
    },
    /**
     * 주어진 스트링에서 의미없는 스페이스를 제거하는 함수.
     * @function
     */
    removeMeaninglessSpace: function(str) {
        /* /\s/ == /[\f\n\r\t\v\u2028\u2029\u00a0]/ */
        return str.replace(/(^[\f\n\r\t\v\u2028\u2029]*)|([\f\n\r\t\v\u2028\u2029]*$)/g, "");
    }
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * $tom.find, $tom.collect, $tom.collectAll 에서 공통적으로 호출되는 함수.
     * @function
     * @example
     *   var result1 = $tom.search(["td,th"], dFindy, _NULL);
     *   var result2 = $tom.search([context, "td,th"], dFindy, _NULL);
     *   var results = $tom.search([context, "td,th"], dGetties, []);
     */
    search: function(args, searchFunction, defaultValue) {
        var context = (args.length == 1) ? _DOC : args[0];
        var pattern = args[args.length - 1];

        var invalidArgument = (!pattern ||
            !context ||
            !context.nodeType ||
            typeof pattern != "string");
        if (invalidArgument) {
            return defaultValue;
        }

        var translator = $tom.translate(pattern);
        return searchFunction(context, translator.getExpression());
    },
    /**
     * css selector 로 요소를 찾아서 반환하는데 인자 node의 상위에 있는 요소를 찾는다.
     * @function
     * @example
     *  var _elNode = $tom.find(node, "table.txc-layout-wz");
     */
    find: function() {
        return this.search(arguments, dFindy, _NULL);
    },
    /**
     * css selector 로 요소를 찾아서 반환하는데 인자 node의 하위에 있는 요소를 찾는다.
     * @function
     * @example
     *  var _elInput = $tom.collect(this.elMenu, 'textarea');
     */
    collect: function() {
        return this.search(arguments, dGetty, _NULL);
    },
    /**
     * css selector로 요소를 찾아서 반환하는데 인자 node의 하위에 있는 요소를 찾고 모든 요소를 배열에 담아서 반환한다.
     * @function
     * @example
     *  var _elItemList = $tom.collectAll(this.elMenu, "li a");
     */
    collectAll: function() {
        return this.search(arguments, dGetties, []);
    }
});

(function() {
    function makeFilter(pattern) {
        if (pattern) {
            if (typeof(pattern) === 'function') {
                return pattern;
            } else {
                var _translator = $tom.translate(pattern);
                return function(node) {
                    if (node.nodeType == 1) {
                        if (_translator.include('#element')) {
                            return _TRUE;
                        } else {
                            return dChecky(node, _translator.getExpression());
                        }
                    } else {
                        return _translator.include('#text');
                    }
                };
            }
        } else {
            return _NULL;
        }
    }

    var nodePatternCache = {};

    function findNodePattern(pattern) {
        pattern = pattern || "#element,#text";

        if (nodePatternCache[pattern]) {
            return nodePatternCache[pattern];
        }
        var filter = new NodePattern(pattern);
        nodePatternCache[pattern] = filter;
        return filter;
    }

    var NodePattern = Trex.Class.create({
        initialize: function(pattern) {
            this.pattern = pattern;
            this.translator = $tom.translate(pattern);
            // for better performance
            this.hasClassPattern = pattern.indexOf(".") >= 0;
            this.hasIdPattern = pattern.indexOf("#") >= 0;
            this.matchesText = this.translator.include("#text");
            this.matchesElement = this.translator.include("#element");
        },
        test: function(node) {
            var nodeType = node.nodeType;
            var translatorMap = this.translator.map;
            if (nodeType == 1) {
                if (this.matchesElement) {
                    return _TRUE;
                }
                var tagName = node.tagName.toLowerCase();

                // early matching for performance
                if (translatorMap[tagName]) {
                    return _TRUE;
                }

                var checkPattern = [];
                if (this.hasClassPattern && node.className) {
                    node.className.split(/\s/).each(function(className) {
                        checkPattern.push("." + className);
                        checkPattern.push(tagName + "." + className);
                    });
                }
                if (this.hasIdPattern && node.id) {
                    var id = node.id;
                    checkPattern.push("#" + id);
                    checkPattern.push(tagName + "#" + id);
                }
                for (var i = 0; i < checkPattern.length; i++) {
                    if (translatorMap[checkPattern[i]]) {
                        return _TRUE;
                    }
                }
                return _FALSE;
            } else if (nodeType == 3) {
                return this.matchesText;
            }
        }
    });

    Object.extend($tom, /** @lends $tom */ {
        tagName: function(node, tagName) {
            if (!node) {
                return _NULL;
            }
            return node.tagName;
        },
        /**
         * node가 pattern에 맞는 요소이면 true를 반환한다.
         * @function
         * @param node
         * @param pattern css selector rule
         * @example
         *  $tom.kindOf(node, "img.txc-image") // node가 txc-image라는 이름의 class속성을 가진 img 요소이면 true
         */
        // 더 이상 사용하지 않는 dChecky를 없애자.
        kindOf: function(node, pattern) {
            if (!node || !pattern) {
                return _FALSE;
            }
            var filter = findNodePattern(pattern);
            return filter.test(node);
        },
        kindOf_old: function(node, pattern) {
            if (!node || !pattern) {
                return _FALSE;
            }
            return makeFilter(pattern)(node);
        },
        /* has filter */
        /**
         * pattern에 맞는 descendant의 상위요소를 찾아서 반환한다.
         * @function
         */
        ancestor: function(descendant, pattern) {
            if (!descendant || !descendant.parentNode) {
                return _NULL;
            }
            var filter = findNodePattern(pattern);
            var _node = descendant.parentNode;
            while (_node) {
                if ($tom.isBody(_node)) {
                    return _NULL;
                }
                if (filter.test(_node)) {
                    break;
                }
                _node = _node.parentNode;
            }
            return _node;
        },
        findAncestor: function(node, matched, mustStop) {
            while (!mustStop(node)) {
                if (matched(node)) {
                    return node;
                }
                node = node.parentNode;
            }
            return _NULL;
        },
        /**
         * pattern에 맞는 descendant의 하위요소를 찾아서 반환한다.
         * @function
         */
        descendant: function(ancestor, pattern) {
            var _nodes = $tom.descendants(ancestor, pattern, _TRUE);
            if (_nodes.length == 0) {
                return _NULL;
            }
            return _nodes[0];
        },
        /**
         * pattern에 맞는 descendant의 모든 하위요소를 찾아서 반환한다.
         * @function
         */
        descendants: function(ancestor, pattern, single) {
            single = single || _FALSE;
            if (!ancestor || !ancestor.firstChild) {
                return [];
            }
            var _found = _FALSE;
            var filter = findNodePattern(pattern);
            var _nodes = [];
            var _gets = function(parent) {
                if (single && _found) {
                    return;
                }
                if (!$tom.first(parent)) {
                    return;
                }
                var _chilren = $tom.children(parent);
                for (var i = 0, len = _chilren.length; i < len; i++) {
                    if (filter.test(_chilren[i])) {
                        _nodes.push(_chilren[i]);
                        _found = _TRUE;
                    } else {
                        _gets(_chilren[i]);
                    }
                }
            };
            _gets(ancestor);
            return _nodes;
        },
        /**
         * node의 자식요소 중 pattern에 맞는 모든 요소를 찾아서 반환한다.
         * @function
         */
        children: function(node, pattern) {
            var _nodes = [];
            if (!node || !node.firstChild) {
                return _nodes;
            }
            var filter = findNodePattern(pattern);
            var _node = $tom.first(node);
            while (_node) {
                if (filter.test(_node)) {
                    _nodes.push(_node);
                }
                _node = _node.nextSibling;
            }
            return _nodes;
        },
        /**
         * node의 nextSibling 요소 중 pattern에 맞는 요소를 찾아서 반환한다.
         * @function
         */
        next: function(node, pattern) {
            if (!node || !node.nextSibling) {
                return _NULL;
            }
            var filter = findNodePattern(pattern);
            var _node = node.nextSibling;
            while (_node) {
                if ($tom.hasContent(_node)) {
                    if (filter.test(_node)) {
                        break;
                    }
                }
                _node = _node.nextSibling;
            }
            return _node;
        },
        /**
         * node의 previousSibling 요소 중 pattern에 맞는 요소를 찾아서 반환한다.
         * @function
         */
        previous: function(node, pattern) {
            if (!node || !node.previousSibling) {
                return _NULL;
            }
            var filter = findNodePattern(pattern);
            var _node = node.previousSibling;
            while (_node) {
                if ($tom.hasContent(_node)) {
                    if (filter.test(_node)) {
                        break;
                    }
                }
                _node = _node.previousSibling;
            }
            return _node;
        },
        /**
         * pattern에 맞는 node의 첫번째 자식요소를 찾아서 반환한다.
         * @function
         */
        first: function(node, pattern) {
            if (!node || !node.firstChild) {
                return _NULL;
            }
            var filter = findNodePattern(pattern);
            var _node = node.firstChild;
            while (_node) {
                if ($tom.hasContent(_node)) {
                    if (filter.test(_node)) {
                        break;
                    }
                }
                _node = _node.nextSibling;
            }
            return _node;
        },
        /**
         * pattern에 맞는 node의 마지막 자식요소를 찾아서 반환한다.
         * @function
         */
        last: function(node, pattern) {
            if (!node || !node.lastChild) {
                return _NULL;
            }
            var filter = findNodePattern(pattern);
            var _node = node.lastChild;
            while (_node) {
                if ($tom.hasContent(_node)) {
                    if (filter.test(_node)) {
                        break;
                    }
                }
                _node = _node.previousSibling;
            }
            return _node;
        },
        /**
         *
         * @function
         */
        extract: function(parent, child, pattern) {
            var _nodes = [];
            if (!parent || !child || !pattern) {
                return _nodes;
            }
            var filter = findNodePattern(pattern);
            var _found = _FALSE;
            var _node = parent.firstChild;
            while (_node) {
                if ($tom.include(_node, child)) {
                    _found = _TRUE;
                }
                if (filter.test(_node)) {
                    _nodes.push(_node);
                } else {
                    if (_found) {
                        break;
                    } else {
                        _nodes = [];
                    }
                }
                _node = _node.nextSibling;
            }
            return _found ? _nodes : [];
            //			return _nodes;
        },
        /* has no filter */
        /**
         * node의 parent node를 반환한다.
         * @function
         */
        parent: function(node) {
            if (!node || !node.parentNode) {
                return _NULL;
            }
            return node.parentNode;
        },
        /**
         * node를 포함하고 있는 body 요소를 반환한다.
         * @function
         */
        body: function(node) {
            if (!node || !node.parentNode) {
                return _NULL;
            }
            var _node = node.parentNode;
            while (_node) {
                if ($tom.isBody(_node)) {
                    return _node;
                }
                _node = _node.parentNode;
            }
            return _NULL;
        },
        /**
         * ancestor의 하위에서 처음 나오는 텍스트 노드를 찾아서 반환한다.
         * @function
         */
        top: function(ancestor, all) {
            all = all || _FALSE;
            var _node = ancestor;

            while ($tom.first(_node)) {
                _node = $tom.first(_node);
            }
            if (all) {
                return _node;
            } else {
                if ($tom.kindOf(_node, "#tx_start_marker,#tx_end_marker")) {
                    _node = _node.nextSibling || _node.parentNode;
                } else if ($tom.kindOf(_node, '%control')) {
                    _node = _node.parentNode;
                }
                return _node;
            }
        },
        /**
         * ancestor의 하위에서 마지막에 나오는 텍스트 노드를 찾아서 반환한다.
         * @function
         */
        bottom: function(ancestor, all) {
            all = all || _FALSE;
            var _node = ancestor;
            while ($tom.last(_node)) {
                _node = $tom.last(_node);
            }
            if (all) {
                return _node;
            } else {
                if ($tom.kindOf(_node, "#tx_start_marker,#tx_end_marker")) {
                    _node = _node.previousSibling || _node.parentNode;
                } else if ($tom.kindOf(_node, '%control')) {
                    _node = _node.parentNode;
                }
                return _node;
            }
        },
        /**
         * child가 parent에 포함되어 있는 요소이면 true를 반환한다.
         * @function
         */
        include: function(parent, child) {
            if (!parent || !child) {
                return _FALSE;
            }
            if (parent == child) {
                return _TRUE;
            }
            var _node = child;
            while (_node) {
                if ($tom.isBody(_node)) {
                    return _FALSE;
                } else if (_node == parent) {
                    return _TRUE;
                }
                _node = _node.parentNode;
            }
            return _FALSE;
        },
        /**
         * node, offset 이전 커서의 위치를 반환한다.
         * @function
         */
        prevNodeUntilTagName: function(node, offset, tagName) {
            tagName = tagName.toUpperCase();
            if (offset === 0)
                node = node.previousSibling;
            else {
                node = node.childNodes[offset - 1];
            }
            while (node && node.lastChild) {
                if (node.tagName === tagName)
                    break;
                node = node.lastChild;
            }
            return node;
        },
        /**
         * node 다음 content를 반환한다.
         * @function
         */
        nextContent: function(node, filter) {
            do {
                var _node = $tom.next(node, filter);
                if (_node)
                    return _node;
                node = $tom.parent(node);
            } while (node && !$tom.isBody(node));
            return null;
        }
    });

})();



Object.extend($tom, /** @lends $tom */ {
    /**
     * parent요소의 첫번째 자식노드로 child를 삽입한다.
     * @function
     */
    insertFirst: function(parent, child) {
        if (!parent || !child) {
            return;
        }
        if (parent.firstChild) {
            parent.insertBefore(child, parent.firstChild);
        } else {
            parent.appendChild(child);
        }
        return child;
    },
    /**
     * target 요소 전 위치에 source 요소를 삽입한고 source 요소를 반환한다.
     * @function
     */
    insertAt: function(source, target) {
        if (!source || !target) {
            return;
        }
        target.parentNode.insertBefore(source, target);
        return source;
    },
    /**
     * target 요소 다음 위치에 source 요소를 삽입한고 source 요소를 반환한다.
     * @function
     */
    insertNext: function(source, target) {
        if (!source || !target) {
            return;
        }
        var nextSibling = target.nextSibling;
        if (nextSibling) {
            nextSibling.parentNode.insertBefore(source, nextSibling);
        } else {
            target.parentNode.appendChild(source);
        }
        return source;
    },
    /**
     * parent 요소에 child 요소를 붙인 후 child 요소를 반환한다.
     * @function
     */
    append: function(parent, child) {
        if (!parent || !child) {
            return;
        }
        parent.appendChild(child);
        return child;
    },
    /**
     * node 를 제거한다.
     * @function
     */
    remove: function(node) {
        if (!node) {
            return;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node = _NULL;
    },
    /**
     * node의 innerHTML로 html를 넣고 node를 반환한다.
     * @function
     */
    html: function(node, html) {
        if (!node) {
            return;
        }
        node.innerHTML = html || "";
        return node;
    },
    /**
     * node의 내용을 지운다.
     * @function
     */
    clean: function(node) {
        return $tom.html(node);
    },
    /**
     * node안에 해당 html를 채워넣고 node를 반환한다.
     * @function
     */
    stuff: function(node, html) {
        if (!node) {
            return node;
        }
        if ($tom.hasUsefulChildren(node, _TRUE)) {
            return node;
        }
        if (node.lastChild) {
            var _node = node;
            while (_node.lastChild) {
                _node = _node.lastChild;
            }
            $tom.insertNext(html, _node);
        } else {
            $tom.append(node, html);
        }
        return node;
    }
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * child가 없는 listhead라면 삭제한다
     * @param node
     */
    removeListIfEmpty: function(node) {
        while ($tom.kindOf(node, "%listhead") && node.childNodes.length == 1 && $tom.kindOf(node.firstChild, "%listhead")) {
            node = node.firstChild;
        }

        while ($tom.kindOf(node, "%listhead") && node.childNodes.length == 0) {
            var tempNode = node.parentNode;
            $tom.remove(node);
            node = tempNode;
        }
    }
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * sNode의 자식노드들을 dNode의 child로 삽입 하는데 sInx, eInx는 자식노드의 시작, 끝 인덱스번호다.
     * @function
     * @param sNode
     * @param dNode
     * @param sInx
     * @param eInx
     */
    moveChild: function(sNode, dNode, sInx, eInx) {
        if (!sNode || !dNode) {
            return;
        }
        sInx = Math.min(Math.max(sInx || 0), sNode.childNodes.length);
        eInx = Math.min(Math.max(eInx || sNode.childNodes.length), sNode.childNodes.length);
        if (sInx >= eInx) {
            return;
        }

        var _inx = sInx;
        while (_inx++ < eInx && sInx < sNode.childNodes.length) {
            dNode.appendChild(sNode.childNodes[sInx]);
        }
    },
    /**
     * node의 자식노드를 node의 부모노드에 붙인다.
     * @function
     */
    moveChildToParent: function(node) {
        if (!node) {
            return;
        }
        while (node.firstChild) {
            node.parentNode.insertBefore(node.firstChild, node);
        }
    }
});

/*
 * Create, Destroy, Change
 */
Object.extend($tom, /** @lends $tom */ {
    /**
     * source를 target로 교체하고 target를 반환한다.
     * @function
     */
    replace: function(source, target) {
        if (!source || !target) {
            return _NULL;
        }
        if ($tom.getName(source) == $tom.getName(target)) {
            $tom.remove(target);
            return source;
        } else {
            // FTDUEDTR-1248
            var children = [],
                childNodes = source.childNodes,
                len = childNodes.length;
            for (var i = 0; i < len; i++) {
                children.push(childNodes[i]);
            }
            for (i = 0; i < len; i++) {
                var child = children[i];
                if (child.lastChild === source) {
                    var cloneChild = $tom.clone(child);
                    $tom.moveChild(child, cloneChild);
                    child.innerHTML = "";
                    target.appendChild(cloneChild);
                } else {
                    target.appendChild(child);
                }
            }
            $tom.insertAt(target, source);
            $tom.remove(source);
            return target;
        }
    },
    /**
     * node를 복사 후 반환한다.
     * @function
     */
    clone: function(node, deep) {
        var cloneNode = node.cloneNode(!!deep);
        if (node.nodeType == 1) {
            cloneNode.removeAttribute("id");
        }
        return cloneNode;
    }
});

/*
 * Wrap, Unwrap
 */
Object.extend($tom, /** @lends $tom */ {
    /**
     * wNode 아래에 pNodes를 붙여서 pNodes를 wNode로 감싼다.
     * @function
     * @return wNode
     */
    wrap: function(wNode, pNodes) { //NOTE: quote, quotenodesign, textbox 등에서 사용됨, actually using 'div', 'blockquote'
        if (!wNode || !pNodes) {
            return _NULL;
        }
        if (pNodes instanceof Array == _FALSE) {
            pNodes = [].concat(pNodes);
        }

        $tom.insertAt(wNode, pNodes[0]);
        pNodes.each((function(pNode) {
            $tom.append(wNode, pNode);
        }));
        return wNode;
    },
    /**
     * node를 제거하고 node의 자식노드는 node의 상위에 붙인다.
     * @function
     */
    unwrap: function(node) {
        if (!node) {
            return _NULL;
        }
        var _nNode = $tom.first(node);
        if ($tx.msie_nonstd) {
            node.removeNode(); // IE에서는 이게 더 빠름
        } else {
            $tom.moveChildToParent(node);
            $tom.remove(node);
        }
        return _nNode;
    }
});


Object.extend($tom, /** @lends $tom */ {
    /**
     * @private
     * @function
     */
    divideText: function(node, offset) {
        if (!$tom.isText(node)) {
            return node;
        }
        if (offset <= 0 || offset >= node.length) { //나눌필요가 있을까?
            return node;
        }
        var _newNode = node.cloneNode(_FALSE);
        node.deleteData(offset, node.length - offset);
        _newNode.deleteData(0, offset);
        $tom.insertNext(_newNode, node);
        return _newNode;
    },
    /**
     * node의 offset번째 child를 기준으로 두 개로 분리한다.
     */
    divideNode: function(node, offset) {
        if (!$tom.isElement(node)) {
            return _NULL;
        }
        /*if(offset <= 0 || offset >= node.childNodes.length) { //나눌필요가 있을까?
        	return node;
        }*/
        var _lastOffset = node.childNodes.length - offset;
        var _newNode = node.cloneNode(_FALSE);
        for (var i = 0; i < _lastOffset; i++) {
            $tom.insertFirst(_newNode, node.lastChild);
        }
        $tom.insertNext(_newNode, node);
        return _newNode;
    },
    /**
     * divideNode와 비슷한데, node를 clone할 때에 style, attribute를 모두 복사하게 된다.
     * divideNode 사용에 대한 legacy 때문에 따로 만들었으며, 사용법이 확인된 이후에는 두 개가 합쳐질 필요가 있다.
     * 예를 들어 style을 복사하는 책임을 caller에게 넘기는 방식이나, 파라미터로 선택할 수 있도록 해서...
     */
    splitAt: function(node, index) {
        if (!$tom.isElement(node)) {
            return;
        }
        var clonedNode = $tom.clone(node);
        $tom.moveChild(node, clonedNode, index + 1, node.childNodes.length);
        $tom.insertNext(clonedNode, node);
        return clonedNode;
    },
    /**
     * stopAncestor은 dividedPoint의 ancestor 이어야 함
     * stopAncestor와 dividedPoint 사이에 table이 없어야 함
     */
    divideTree: function(stopAncestor, dividedPoint) {
        var currentNode = dividedPoint,
            offset, parent;
        do {
            parent = currentNode.parentNode;
            offset = $tom.indexOf(currentNode);
            currentNode = $tom.divideNode(parent, offset);
        } while (currentNode.previousSibling != stopAncestor);
        return currentNode;
    },
    /**
     * @private
     * @function
     */
    divideParagraph: function(node) {
        var _node = node;
        var _offset = $tom.indexOf(node);

        var _divided = _node;
        while (_node) {
            if ($tom.isBody(_node)) {
                break;
            } else if ($tom.kindOf(_node, 'td,th,%wrapper,%outergroup')) {
                break;
            } else if ($tom.kindOf(_node, "#tx_start_marker,#tx_end_marker")) {
                _offset = $tom.indexOf(_node);
            } else if ($tom.isControl(_node)) {
                _offset = $tom.indexOf(_node);
            } else if ($tom.isText(_node)) { //text
                _node = $tom.divideText(_node, _offset);
                _offset = $tom.indexOf(_node);
            } else { //%inline, %paragraph
                _node = $tom.divideNode(_node, _offset);
                _offset = $tom.indexOf(_node);
                _divided = _node;
                if ($tom.kindOf(_node, 'p,li,dd,dt,h1,h2,h3,h4,h5,h6')) {
                    break;
                }
            }
            _node = _node.parentNode;
        }
        return _divided;
    },
    wrapInlinesWithP: function(inline, ancestorBlock) {
        var ownerDocument = $tom.getOwnerDocument(inline);
        var inlineNodes = $tom.extract(ancestorBlock || ownerDocument.body, inline, '%text,%inline,%control');
        // caret은 곧 사라지기 때문에P로 감쌀 필요가 없다
        if (this.hasOnlySavedCaret(inlineNodes, inline)) {
            return _NULL;
        }
        var newParagraph = ownerDocument.createElement("p");
        $tom.wrap(newParagraph, inlineNodes);
        return newParagraph;
    },
    hasOnlySavedCaret: function(inlines, inline) {
        var validInlines = inlines.findAll(function(node) {
            return node.nodeType != 3 || node.nodeValue.trim() != "";
        });
        return this.isGoogRangeCaret(inline) && validInlines.length == 1 && validInlines[0] == inline;
    },
    isGoogRangeCaret: function(node) {
        return node && /goog_[0-9]+/.test(node.id);
    }
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * name의 하위요소로 들어올 요소이름 반환
     * @function
     * @example
     *  $tom.paragraphOf("table") // 'td'를 반환한다.
     */
    paragraphOf: function(name) {
        if (!name) {
            return 'p';
        }
        var _translator = $tom.translate(name);
        if (_translator.memberOf('ul,ol')) {
            return 'li';
        } else if (_translator.memberOf('dl')) {
            return 'dd';
        } else if (_translator.memberOf('tr,tbody,thead,tfoot,table')) {
            return 'td';
        } else {
            return 'p';
        }
    },
    /**
     * 'span' 을 반환한다.
     * @function
     */
    inlineOf: function() {
        return 'span';
    },
    /**
     * 요소의 name을 받아서 상위요소가 되는 요소이름을 반환한다.
     * @function
     * @example
     *  $tom.outerOf("td") // "table"을 반환한다.
     */
    outerOf: function(name) {
        if (!name) {
            return 'span';
        }
        var _translator = $tom.translate(name);
        if (_translator.memberOf('li')) {
            return 'ol';
        } else if (_translator.memberOf('dd,dt')) {
            return 'dl';
        } else if (_translator.memberOf('td,th,tr')) {
            return 'table';
        } else {
            return 'p';
        }
    }
});

(function() {
    var __IGNORE_NAME_FLAG = 0;

    var UnitCalculate = Trex.Class.create({
        $const: {
            __FONT_SIZE_BASIS: 9,
            __REG_EXT_NUMBER: new RegExp("[0-9\.]+"),
            __REG_EXT_UNIT: new RegExp("px|pt|em")
        },
        initialize: function() {
            this.unitConverter = { //1em = 9pt
                "px2em": 1 / 12,
                "px2pt": 9 / 12,
                "em2px": 12, // 12 : 1
                "em2pt": 9, // 9 : 1
                "pt2px": 12 / 9,
                "pt2em": 1 / 9
            };
        },
        calculate: function(strA, strB) {
            if (strA == _NULL || strA.length == 0) {
                strA = "0em";
            }
            if (strB == _NULL || strB.length == 0) {
                strB = "0em";
            }

            var _sign = this.extractSign(strB);

            var _unitA = this.extractUnit(strA);
            var _unitB = this.extractUnit(strB); //basis unit

            var _numA = this.extractNumber(strA).toNumber();
            var _numB = this.extractNumber(strB).toNumber();
            if (_unitA != _unitB) { //different unit
                if (this.unitConverter[_unitA + "2" + _unitB]) {
                    _numA *= this.unitConverter[_unitA + "2" + _unitB];
                }
            }
            var _result = 0;
            if (_sign == "-") {
                _result = Math.max(_numA - _numB, 0);
            } else {
                _result = (_numA + _numB);
            }
            _result = (Math.round(_result * 10) / 10);
            if (_result == 0) {
                return _NULL;
            } else {
                return _result + _unitB;
            }
        },
        needCalculation: function(str) {
            if (str == _NULL || typeof str != "string") {
                return _FALSE;
            } else {
                return (str.charAt(0) == '+' || str.charAt(0) == '-');
            }
        },
        extractSign: function(str) {
            var _sign = "+";
            if (str.charAt(0) == '+' || str.charAt(0) == '-') {
                _sign = str.charAt(0);
            }
            return _sign;
        },
        extractNumber: function(str) {
            var _num = 0;
            var _match;
            if ((_match = str.match(UnitCalculate.__REG_EXT_NUMBER)) != _NULL) {
                _num = _match[0];
            }
            if (str.indexOf("%") > -1) { //%
                _num = _num / 100;
            }
            return _num;
        },
        extractUnit: function(str) {
            var _unit = "em";
            var _match;
            if ((_match = str.match(UnitCalculate.__REG_EXT_UNIT)) != _NULL) {
                _unit = _match[0];
            }
            return _unit;
        }
    });
    var _unitCalculator = new UnitCalculate();

    var __ATTRIBUTE_TRANSLATIONS = {
        colspan: "colSpan",
        rowspan: "rowSpan",
        valign: "vAlign",
        datetime: "dateTime",
        accesskey: "accessKey",
        tabindex: "tabIndex",
        enctype: "encType",
        maxlength: "maxLength",
        readonly: "readOnly",
        longdesc: "longDesc",
        cellPadding: "cellPadding",
        cellSpacing: "cellSpacing",
        more: "more",
        less: "less",
        style: "style"
    };

    Object.extend($tom, /** @lends $tom */ {
        /**
         * node에 인자로 받은 attributes 속성을 세팅한다.
         * @function
         * @param {Element} node
         * @param {JSON} attributes
         * @example
         *  $tom.applyAttributes(inNode, {
         *		'style': { 'fontSize': null },
         *		'size': null
         *	});
         */
        applyAttributes: function(node, attributes) {
            if (!$tom.isElement(node)) {
                return;
            }
            for (var _name in attributes) {
                if (_name == "style") {
                    $tom.applyStyles(node, attributes[_name]);
                } else {
                    $tom.setAttribute(node, _name, attributes[_name]);
                }
            }
        },
        /**
         * node에 인자로 받은 attributes 속성을 제거한다.
         * @function
         */
        removeAttributes: function(node, attributes) {
            if (!$tom.isElement(node)) {
                return;
            }
            for (var _name in attributes) {
                if (_name == "style") {
                    $tom.removeStyles(attributes[_name])
                } else {
                    node.removeAttribute(_name, __IGNORE_NAME_FLAG);
                }
            }
        },
        /**
         * node에서 attrName을 이름으로 갖는 속성의 값을 반환
         * @function
         * @example
         *  $tx("tx_image").getAttribute("class") // class속성의 값 반환
         */
        getAttribute: function(node, attrName) {
            if (!$tom.isElement(node)) {
                return _NULL;
            }
            if (node && node.getAttribute) {
                return node.getAttribute(__ATTRIBUTE_TRANSLATIONS[attrName] || attrName);
            } else {
                return _NULL;
            }
        },
        /**
         * node에 attrName를 이름으로, attrValue를 값으로 갖는 속성을 세팅한다.
         * @function
         */
        setAttribute: function(node, attrName, attrValue) {
            if (!$tom.isElement(node)) {
                return;
            }
            if (attrValue == _NULL || attrValue.length == 0 || attrValue == 0) {
                node.removeAttribute(attrName, __IGNORE_NAME_FLAG);
            } else {
                if (__ATTRIBUTE_TRANSLATIONS[attrName]) {
                    node.setAttribute(__ATTRIBUTE_TRANSLATIONS[attrName], attrValue);
                } else {
                    try {
                        node[attrName] = attrValue;
                    } catch (e) {
                        // console.log(e);
                        node.setAttribute(__ATTRIBUTE_TRANSLATIONS[attrName] || attrName, attrValue);
                    }
                }
            }
        },
        // TODO : refactoring 뭔가 복잡하다.
        setStyles: function(node, styles, overwrite) {
            var nodeCssText = node.style.cssText;
            var canSetStyle;
            var styleToSet = Object.extend({}, styles);
            if (styleToSet.font) {
                if (overwrite) {
                    node.style.font = styleToSet.font; // 이 부분에서 chrome, opera는 font의 css 속성이 분해된 형태로 적용된다.
                } else if (node.style.cssText.indexOf("font:") == -1) {
                    node.style.cssText = 'font: ' + styleToSet.font + '; ' + node.style.cssText;
                }
                delete styleToSet.font;
            }
            for (var styleName in styleToSet) {
                var styleValue;
                if (_unitCalculator.needCalculation(styleToSet[styleName])) {
                    styleValue = _unitCalculator.calculate(node.style[styleName], styleToSet[styleName]);
                } else {
                    styleValue = styleToSet[styleName];
                }
                if (styleValue == _NULL) {
                    styleValue = "";
                }

                if (styleName == 'float') {
                    styleName = $tx.msie ? 'styleFloat' : 'cssFloat';
                }
                canSetStyle = (!node.style[styleName] && (styleName.indexOf("font") != 0 || nodeCssText.indexOf("font:") == -1)) || overwrite;
                var newTextDecoration = (styleName == "textDecoration") && !node.style[styleName].include(styleValue);
                if (canSetStyle) {
                    node.style[styleName] = styleValue;
                } else if (newTextDecoration) {
                    node.style[styleName] += " " + styleValue;
                }
            }
            $tom._clearUselessStyle(node);
        },
        /**
         * node에 styles에서 지정한 스타일을 적용한다.
         * @function
         * @example
         *  $tom.applyStyles(node, {
         * 		'width': width
         *  });
         */
        applyStyles: function(node, styles) {
            this.setStyles(node, styles, _TRUE);
        },
        /**
         * node의 style 속성값을 적용하되, 이미 존재하는 속성은 유지된다.
         * @param node
         * @param styles
         */
        addStyles: function(node, styles) {
            this.setStyles(node, styles, _FALSE);
        },
        /**
         * node에서 styles인자에서 지정한 스타일 속성값을 제거한다.
         * @function
         */
        removeStyles: function(node, styles) {
            // FTDUEDTR-1166
            var cssText = node.style.cssText;
            var orignalCssText = cssText;
            for (var _name in styles) {
                _name = _name.replace(/([A-Z])/g, "-$1");
                cssText = cssText.replace(new RegExp("(^| )" + _name + "\\s*:[^;]+;? ?", "ig"), "");
            }
            if (orignalCssText != cssText) {
                node.style.cssText = cssText;
                $tom._clearUselessStyle(node);
            }
        },
        _clearUselessStyle: function(node) {
            var _attrValue = $tom.getAttribute(node, "style");
            if (!_attrValue) { //remove needless style
                node.removeAttribute("style", __IGNORE_NAME_FLAG);
            }
        },
        /**
         * node에서 style 속성값 텍스트를 모두 반환한다.
         * @function
         */
        getStyleText: function(node) {
            return node.style.cssText;
        },
        /**
         * node의 style 속성값을 value로 넣는다. 기존에 있는 값은 덮어쓰여진다.
         * @function
         * @param {Element} node
         * @param {String} value style 속성에 바로 세팅할 텍스트 값을 넣어야 함
         * @example
         *  $tom.setStyleText($tx("tx_article_category"), "width:50px;height:10px")
         */
        setStyleText: function(node, value) {
            node.style.cssText = value;
            !value && $tom._clearUselessStyle(node);
        }
    });
})();

Object.extend($tom, /** @lends $tom */ {
    /**
     * @private
     * @function
     */
    goInto: function(node, toTop) {
        if (!node || !node.scrollIntoView) {
            return;
        }
        node.scrollIntoView(toTop);
    },
    getWindow: function(doc) {
        return doc.defaultView || doc.parentWindow;
    },
    /**
     * 수직 스크롤 위치값을 반환한다.
     * @function
     * @example
     *  $tom.getScrollTop(document)
     */
    getScrollTop: function(doc) {
        if (!doc) {
            return 0;
        }
        var win = this.getWindow(doc);
        var prop = 'pageYOffset';
        return (prop in win) ? win[prop] : (doc.documentElement.scrollTop || doc.body.scrollTop || 0);
    },
    /**
     * 수직 스크롤 값을 셋팅한다.
     * @function
     * @param {Element} doc
     * @param {Number} scrollTop 수직 스크롤 값
     */
    setScrollTop: function(doc, scrollTop) {
        if (!doc) {
            return;
        }
        if (doc.documentElement.scrollTop) {
            doc.documentElement.scrollTop = scrollTop;
        } else {
            doc.body.scrollTop = scrollTop;
        }
    },
    /**
     * 수평 스크롤 위치값을 반환한다.
     * @function
     */
    getScrollLeft: function(doc) {
        if (!doc) {
            return 0;
        }
        return (doc.documentElement.scrollLeft || doc.body.scrollLeft);
    },
    /**
     * 수평 스크롤 값을 셋팅한다.
     * @function
     * @param {Element} doc
     * @param {Number} scrollLeft 수평 스크롤 값
     */
    setScrollLeft: function(doc, scrollLeft) {
        if (!doc) {
            return;
        }
        if (doc.documentElement.scrollLeft) {
            doc.documentElement.scrollLeft = scrollLeft;
        } else {
            doc.body.scrollLeft = scrollLeft;
        }
    },
    /**
     * element요소의 left, top, width, height 값을 계산하여 반환한다.
     * @function
     * @return {
     * 		x: 0,
     * 		y: 0,
     * 		width: 0,
     * 		height: 0
     * 	}
     */
    getPosition: function(element, cumulative) {
        if (!element) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
        }
        cumulative = !!cumulative;
        element = $tx(element);
        var pos = (cumulative) ? $tx.cumulativeOffset(element) : $tx.positionedOffset(element);
        var dim;
        var display = element.style.display;
        if (display != 'none' && display != _NULL) { //Safari bug
            dim = {
                width: element.offsetWidth,
                height: element.offsetHeight
            };
        } else {
            var els = element.style;
            var originalVisibility = els.visibility;
            var originalPosition = els.position;
            var originalDisplay = els.display;
            els.visibility = 'hidden';
            els.position = 'absolute';
            els.display = 'block';
            var originalWidth = element.clientWidth;
            var originalHeight = element.clientHeight;
            els.display = originalDisplay;
            els.position = originalPosition;
            els.visibility = originalVisibility;
            dim = {
                width: originalWidth,
                height: originalHeight
            };
        }
        return {
            x: pos[0],
            y: pos[1],
            width: dim.width,
            height: dim.height
        };
    },
    /**
     * node 요소의 width값을 반환한다.
     * inline style이 px값으로 유효하지 않으면 offset으로 대체한다.
     * @function
     */
    getWidth: function(node) {
        var width = node.style["width"];
        if (width.isPx()) {
            return width.parsePx();
        }
        return node.offsetWidth;
    },
    /**
     * node 요소 스타일속성의 width 값을 세팅한다.
     * @function
     */
    setWidth: function(node, width) {
        $tom.applyStyles(node, {
            'width': width
        });
    },
    /**
     * node 요소의 height값을 반환한다.
     * inline style이 px값으로 유효하지 않으면 offset으로 대체한다.
     * @function
     */
    getHeight: function(node) {
        var height = node.style["height"];
        if (height.isPx()) {
            return height.parsePx();
        }
        return node.offsetHeight;
    },
    /**
     * node 요소 스타일속성의 height 값을 세팅한다.
     * @function
     */
    setHeight: function(node, height) {
        $tom.applyStyles(node, {
            'height': height
        });
    },
    /**
     * @private
     * @function
     */
    replacePngPath: function(node) {
        if ($tx.msie6) {
            if (_DOC.location.href.indexOf("http://") > -1) {
                return;
            }
            try {
                var _orgFilter = $tx.getStyle(node, 'filter');
                var _orgSrc = /src='([^']+)'/.exec(_orgFilter)[1];
                if (!_orgSrc || _orgSrc == 'none') {
                    return;
                } else if (_orgSrc.indexOf("http://") > -1) {
                    return;
                }

                var _docPathSlices = _DOC.location.href.split("/");
                _docPathSlices.push("css");
                _docPathSlices.pop();
                _orgSrc = _orgSrc.replace(/\.\.\//g, function() {
                    _docPathSlices.pop();
                    return "";
                });

                var _newSrc = _docPathSlices.join("/") + "/" + _orgSrc;
                node.style.filter = _orgFilter.replace(/src='([^']+)'/, "src='" + _newSrc + "'");
            } catch (e) { alert(e) }
        }
    }
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * 편집영역에서 기본 빈 문단에 해당하는 content
     * @constant
     */
    EMPTY_BOGUS: ($tx.msie_quirks || $tx.msie && $tx.msie_ver < 11 ? "&nbsp;" : "<br>")
});

Object.extend($tom, /** @lends $tom */ {
    /**
     * 편집영역에서 기본 빈 문단에 해당하는 HTML
     * @constant
     */
    EMPTY_PARAGRAPH_HTML: "<p>" + $tom.EMPTY_BOGUS + "</p>"
});

_WIN.$tom = $tom;

(function(Trex) {
    /**
     * @namespace
     * @name Trex.Util
     */
    Trex.Util = /** @lends Trex.Util */ {
        _dispElIds: [],
        getDispElId: function() {
            var _genId;
            do {
                _genId = "tx_entry_" + (Math.floor(Math.random() * 90000) + 10000) + "_"; //id: 10000~99999
            } while (Trex.Util._dispElIds.contains(_genId));
            Trex.Util._dispElIds.push(_genId);
            return _genId;
        },
        generateKey: function() {
            return parseInt(Math.random() * 100000000);
        },
        toStyleString: function(styles) {
            var _str = [];
            for (var _name in styles) {
                if (styles[_name]) {
                    _str.push(_name.replace(/([A-Z])/g, "-$1").toLowerCase());
                    _str.push(":");
                    _str.push(styles[_name]);
                    _str.push(";");
                }
            }
            return _str.join("");
        },
        toAttrString: function(attrs) {
            var _str = [];
            for (var _name in attrs) {
                if (attrs[_name]) {
                    _str.push(" " + _name + "=\"" + attrs[_name] + "\"");
                }
            }
            return _str.join("");
        },
        getMatchValue: function(reg, html, inx) {
            var _matchs;
            if ((_matchs = reg.exec(html)) != _NULL) {
                return _matchs[inx];
            } else {
                return _NULL;
            }
        },
        getAttachmentType: function(mimeType) {
            mimeType = (mimeType || "").toLowerCase();

            var imageMimeTypes = ['image/jpg', 'image/jpeg', 'image/png', 'image/tiff',
                'image/gif', 'image/bmp', 'image/x-jg', 'image/ief', 'image/pict',
                'jpg', 'bmp', 'gif', 'png'
            ];

            if (imageMimeTypes.contains(mimeType)) {
                return 'image';
            }
            return 'file';
        },
        /**
         * 확장자에 따는 thumbnail 이미지 url을 가져온다.
         * @param {Object} ext
         */
        thumburl: function(ext) {
            ext = (ext || "").toLowerCase();
            switch (ext) {
                case "doc":
                case "docx":
                    return getIconPath("#iconpath/pn_word.gif");
                case "xls":
                case "xlsx":
                    return getIconPath("#iconpath/pn_xls.gif");
                case "ppt":
                case "pptx":
                    return getIconPath("#iconpath/pn_ppt.gif");
                case "pdf":
                    return getIconPath("#iconpath/pn_pdf.gif");
                case "txt":
                    return getIconPath("#iconpath/pn_txt.gif");
                case "hwp":
                    return getIconPath("#iconpath/pn_hwp.gif");
                case "zip":
                case "alz":
                    return getIconPath("#iconpath/pn_zip.gif");
                case "mp3":
                case "wav":
                case "ogg":
                case "wma":
                case "mp4":
                case "ape":
                case "ra":
                case "ram":
                    return getIconPath("#iconpath/pn_mp3.gif");
                case "avi":
                case "mpeg":
                case "wmv":
                case "asf":
                    return getIconPath("#iconpath/pn_movie.gif");
                case "swf":
                    return getIconPath("#iconpath/pn_swf.gif");
                case "htm":
                case "html":
                    return getIconPath("#iconpath/pn_html.gif");
                case "jpg":
                case "gif":
                case "png":
                case "bmp":
                    return getIconPath("#iconpath/pn_etc.gif");
                default:
                    return getIconPath("#iconpath/pn_etc.gif");
            }
        },
        /**
         * 확장자에 따는 preview 이미지 url을 가져온다.
         * @param {Object} ext
         */
        prevurl: function(ext) {
            ext = (ext || "").toLowerCase();
            switch (ext) {
                case "doc":
                case "docx":
                    return getIconPath("#iconpath/p_word_s.gif");
                case "xls":
                case "xlsx":
                    return getIconPath("#iconpath/p_xls_s.gif");
                case "ppt":
                case "pptx":
                    return getIconPath("#iconpath/p_ppt_s.gif");
                case "pdf":
                    return getIconPath("#iconpath/p_pdf_s.gif");
                case "txt":
                    return getIconPath("#iconpath/p_txt_s.gif");
                case "hwp":
                    return getIconPath("#iconpath/p_hwp_s.gif");
                case "zip":
                case "alz":
                    return getIconPath("#iconpath/p_zip_s.gif");
                case "mp3":
                case "wav":
                case "ogg":
                case "wma":
                case "mp4":
                case "ape":
                case "ra":
                case "ram":
                    return getIconPath("#iconpath/p_mp3_s.gif");
                case "avi":
                case "mpeg":
                case "wmv":
                case "asf":
                    return getIconPath("#iconpath/p_movie_s.gif");
                case "swf":
                    return getIconPath("#iconpath/p_swf_s.gif");
                case "htm":
                case "html":
                    return getIconPath("#iconpath/p_html_s.gif");
                case "jpg":
                    return getIconPath("#iconpath/p_jpg_s.gif");
                case "gif":
                    return getIconPath("#iconpath/p_gif_s.gif");
                case "png":
                case "bmp":
                    return getIconPath("#iconpath/p_png_s.gif");
                default:
                    return getIconPath("#iconpath/p_etc_s.gif");
            }
        },
        getMatchedClassName: function(element, classes) {
            var matched = _FALSE;
            var _class = "";
            for (var i = 0; i < classes.length; i++) {
                _class = classes[i];
                if ($tx.hasClassName(element, _class)) {
                    matched = _class;
                    break;
                }
            }
            return matched;
        },
        getAllAttributesFromEmbed: function(embedSrc) {
            var map = {};
            embedSrc = embedSrc.replace(/<embed|>/ig, "");
            try {
                var regSplit = /(\w+)=((?:\")[^\"]+(?:\"|$)|(?:')[^']+(?:'|$)|(?:[^\"'][^ \n]+($| |\n)))/ig;
                var result;
                while ((result = regSplit.exec(embedSrc)) != _NULL) {
                    map[result[1].trim().toLowerCase()] = result[2].replace(/^(\"|')/i, "").replace(/(\"|')$/i, "").trim();
                }
            } catch (e) {}

            return map;
        },
        getAllAttributes: function(source) {
            var _map = {};
            var _matchsAttr;

            var _reg = /style="(?:\s*|(?:[^"]*(?:;\s*)))width\s*:\s*([0-9]+)px[^"]*"/ig;
            while ((_matchsAttr = _reg.exec(source)) != _NULL) {
                _map["width"] = _matchsAttr[1];
            }
            _reg = /style="(?:\s*|(?:[^"]*(?:;\s*)))height\s*:\s*([0-9]+)px[^"]*"/ig;
            while ((_matchsAttr = _reg.exec(source)) != _NULL) {
                _map["height"] = _matchsAttr[1];
            }
            _reg = new RegExp("\\s+([a-zA-Z\-]+)=\"([^\"]*)\"", "g");
            while ((_matchsAttr = _reg.exec(source)) != _NULL) {
                if (!_map[_matchsAttr[1].toLowerCase()]) {
                    _map[_matchsAttr[1].toLowerCase()] = _matchsAttr[2];
                }
            }
            _reg = new RegExp("\\s+([a-zA-Z\-]+)='([^']*)'", "g");
            while ((_matchsAttr = _reg.exec(source)) != _NULL) {
                if (!_map[_matchsAttr[1].toLowerCase()]) {
                    _map[_matchsAttr[1].toLowerCase()] = _matchsAttr[2];
                }
            }
            _reg = new RegExp("\\s+([a-zA-Z\-]+)=([^\\s>]*)", "g");
            while ((_matchsAttr = _reg.exec(source)) != _NULL) {
                if (!_map[_matchsAttr[1].toLowerCase()]) {
                    _map[_matchsAttr[1].toLowerCase()] = _matchsAttr[2];
                }
            }
            return _map;
        }
    };

    /**
     * @namespace
     * @name Trex.HtmlCreator
     */
    Trex.HtmlCreator = {
        /**
         * Create Table Markup String
         *
         *  @example
         *  var items =[
         *  		{
         *  			klass: 'klassName',
         *  			image: 'image url', // can be omitted
         *  			data: 'data'
         *  		}
         *  	]
         *
         *	var tableMarkup = Trex.HtmlCreator.createTableMarkup(row, col, item);
         *
         * @param {int} rows
         * @param {int} cols
         * @param {Object} items
         *
         */
        createTableMarkup: function(rows, cols, items) {
            var _html = [];
            _html.push('<table unselectable="on">');
            _html.push('<tbody>');

            var _total = items.length;
            var _item;
            for (var row = 0; row < rows; row++) {
                _html.push('<tr>');
                for (var col = 0; col < cols; col++) {
                    if (row * cols + col < _total) {
                        _item = items[row * cols + col];
                        if (_item.image) {
                            var imageUrl = TrexConfig.getIconPath(_item.image); //글상자 > 직접선택 > 선스타일 이미지.
                            _html.push('<td class="tx-menu-list-item"><a href="javascript:;"><span class="' + (_item.klass || '') + '"><img src="' + imageUrl + '" data="' + _item.data + '"/></span></a></td>');
                        } else {
                            _html.push('<td class="tx-menu-list-item"><a href="javascript:;"><span class="' + (_item.klass || '') + '">' + _item.data + '</span></a></td>');
                        }
                    } else {
                        _html.push('<td class="tx-menu-list-item"><a href="javascript:;"><span class="">&nbsp;</span></a></td>');
                    }
                }
                _html.push('</tr>');
            }
            _html.push('</tbody>');
            _html.push('</table>');
            return _html.join("\n");
        }
    };

    Trex.String = {
        escapeQuot: function(str) {
            return str.replace(new RegExp('"', "g"), "&quot;").replace(new RegExp("'", "g"), "&#39;");
        },
        unescapeQuot: function(str) {
            return str.replace(new RegExp("&quot;", "gi"), '"').replace(new RegExp("&#39;", "g"), "'");
        },
        htmlspecialchars: function(str) {
            return Trex.String.escapeQuot(str.replace(new RegExp("&", "g"), "&amp;").replace(new RegExp("<", "g"), "&lt;").replace(new RegExp(">", "g"), "&gt;"));
        },
        unHtmlspecialchars: function(str) {
            return Trex.String.unescapeQuot(str.replace(new RegExp("&amp;", "gi"), "&").replace(new RegExp("&lt;", "gi"), "<").replace(new RegExp("&gt;", "gi"), ">"));
        },
        parseAttribute: function(elStr, attrName) {
            var regAttribute1 = new RegExp("(^|\\W)" + attrName + '="([^"]*)"', "gi");
            var regAttribute2 = new RegExp("(^|\\W)" + attrName + "='([^']*)'", "gi");
            var regAttribute3 = new RegExp("(^|\\W)" + attrName + "=([^\\s>]*)", "gi");
            var result;
            if (result = regAttribute1.exec(elStr)) {
                return result[2];
            } else if (result = regAttribute2.exec(elStr)) {
                return result[2];
            } else if (result = regAttribute3.exec(elStr)) {
                return result[2];
            } else {
                return "";
            }
        },
        changeAttribute: function(elStr, attrName, currentValue, value) {
            var regAttribute1 = new RegExp("(^|\\W)(" + attrName + '=")' + currentValue + '(")', "gi");
            var regAttribute2 = new RegExp("(^|\\W)(" + attrName + "=')" + currentValue + "(')", "gi");
            var regAttribute3 = new RegExp("(^|\\W)(" + attrName + "=)" + currentValue, "gi");
            var regAttribute4 = new RegExp("<([\\w]+\\s*)", "gi");
            var _exists = _FALSE;
            if (elStr.search(regAttribute1) > -1) {
                _exists = _TRUE;
                elStr = elStr.replace(regAttribute1, "$1$2" + value + "$3");
            }
            if (elStr.search(regAttribute2) > -1) {
                _exists = _TRUE;
                elStr = elStr.replace(regAttribute2, "$1$2" + value + "$3");
            }
            if (elStr.search(regAttribute3) > -1) {
                _exists = _TRUE;
                elStr = elStr.replace(regAttribute3, "$1$2" + value);
            }
            if (!_exists) {
                elStr = elStr.replace(regAttribute4, "<$1" + attrName + '=' + value + ' ');
            }
            return elStr;
        }
    };

    /*---- Trex.Validator ------------------------------------------------------*/
    Trex.Validator = Trex.Class.create({
        initialize: function() {},
        strip: function(content) {
            return content.stripTags().replace(/&nbsp;/g, "").replace(Trex.__WORD_JOINER_REGEXP, "").trim();
        },
        exists: function(content) {
            if (!content) {
                return _FALSE;
            }
            if (this.strip(content) == "") {
                if (content.search(/<(img|iframe|object|embed|table|hr|script|TXDB)/i) < 0) {
                    return _FALSE;
                }
            }
            return _TRUE;
        },
        equals: function(content, text) {
            if (!content || !text) {
                return _FALSE;
            }
            if (content.search(/<(img|iframe|object|embed|table|hr|script|TXDB)/i) < 0) {
                if (this.strip(content) == this.strip(text)) {
                    return _TRUE;
                }
            }
            return _FALSE;
        }
    });

    /*---- Trex.Repeater ------------------------------------------------------*/
    Trex.Repeater = Trex.Class.create({
        initialize: function(execHandler) {
            this.execHandler = execHandler;
        },
        start: function(term) {
            if (this.tItv) {
                this.clear();
            }
            this.tItv = _WIN.setInterval(this.onTimer.bind(this), term);
        },
        clear: function() {
            _WIN.clearInterval(this.tItv);
            this.tItv = _NULL;
        },
        onTimer: function() {
            if (this.execHandler != _NULL) {
                this.execHandler();
            }
        }
    });

    /*---- Trex.Timer ------------------------------------------------------*/
    Trex.Timer = Trex.Class.create({
        initialize: function(execHandler) {
            this.execHandler = execHandler;
        },
        start: function(term) {
            _WIN.setTimeout(this.onTimer.bind(this), term);
        },
        onTimer: function() {
            if (this.execHandler != _NULL) {
                this.execHandler();
            }
        }
    });

    /**
     * Trex.Paging Class
     * paging을 위한 class. Ajax나 fileter 등을 통한 dynamic data바인딩은 고려되지 않음. static array로만 사용이 가능
     * @class
     * @param {Array} data
     * @param {Object} config
     */
    Trex.Paging = Trex.Class.create({
        $const: {
            DEFAULT_PAGE_SIZE: 5,
            DEFAULT_BLOCK_SIZE: 10
        },
        initialize: function(data, config) {
            this.data = data;
            this.currentpage = config.initPage || 1;
            this.totalrow = config.totalrow || this.getTotalRow();
            this.pagesize = config.pagesize || Trex.Paging.DEFAULT_PAGE_SIZE;
            this.blocksize = config.blocksize || Trex.Paging.DEFAULT_PAGE_SIZE;
            this.totalpage = Math.ceil(this.totalrow / this.pagesize);
            this.totalblock = Math.ceil(this.totalpage / this.blocksize);
        },
        getNextPage: function() {
            return (this.currentpage < this.totalpage) ? this.currentpage + 1 : 0;
        },
        getPrevPage: function() {
            return (this.currentpage > 1) ? this.currentpage - 1 : 0;
        },
        getNextBlock: function() {
            var _currentblock = Math.ceil(this.currentpage / this.blocksize);
            return (_currentblock < this.totalblock) ? _currentblock * this.blocksize + 1 : 0
        },
        getPrevBlock: function() {
            var _currentblock = Math.ceil(this.currentpage / this.blocksize);
            return (_currentblock > 1) ? (_currentblock - 2) * this.blocksize + 1 : 0;
        },
        getPageList: function() {
            var pages = [];
            var _startBlock = Math.ceil(this.currentpage / this.blocksize) - 1;
            var _startPage = (_startBlock * this.blocksize + 1);
            var _endPage = Math.min(this.totalpage, (_startPage + this.blocksize - 1));
            for (var i = _startPage; i <= _endPage; i++) {
                pages.push(i);
            }

            return pages;
        },
        movePage: function(page) {
            this.currentpage = page || this.currentpage;
        },
        getOnePageData: function() {
            var result = [];
            var _start = (this.currentpage - 1) * this.pagesize;
            var _end = Math.min(this.currentpage * this.pagesize, this.totalrow);
            for (var i = _start; i < _end; i++) {
                result.push(this.data[i]);
            }

            return result;
        },
        getTotalRow: function() {
            return this.data.length;
        }
    });

    /**
     * Trex.Slidebar Class
     * slidebar 위젯. 마크업, CSS에 의존성이 있다.
     * @class
     * @param {Object} config
     */
    Trex.Slidebar = Trex.Class.create({
        initialize: function(config) {
            /* config = {
             * 		handler: function, 슬라이드가 동작할때 실행될 함수
             * 		elContext: 슬라이드가 제어될 영역, div등의 element
             * 		knoWidth: knob element의 크기
             * 		barSize: 슬라이드 element의 크기
             * 		min: 최소값(논리적인 값, default 0)
             *  	max: 최대값(논리적인 값, default 100)
             *  	interval: 한번 클릭이나 마우스 드래그로 이동하는 값(논리적인 값, default 5)
             * 		defaultValue: 초기 knob이 위치할 값
             * }
             */
            this.elContext = config.el;
            this.knobWidth = config.knobWidth;
            this.isDisabled = _FALSE;
            this.handler = function(value) {
                if (!this.isDisabled && typeof config.handler == "function") {
                    config.handler(value);
                }
            };

            this.logicObj = {
                'interval': config.interval || 5,
                'min': config.min || 0,
                'max': config.max || 100
            };
            this.physicObj = {
                'min': 0,
                'width': config.barSize || 100
            };
            this.physicObj.max = this.physicObj.width - this.knobWidth;
            this.physicObj.interval = this.logicObj.interval * this.physicObj.max / this.logicObj.max;

            this.startPos = 0;
            this.startX = 0;
            this.isDrag = _FALSE;
            this.result = 0;

            var elMenu = $tom.collect(this.elContext, "dd.tx-slide");
            // 양끝단에 min값과 max값이 표시 될 수도 있다.
            $tom.collect(elMenu, "span.tx-slide-min").innerHTML = "";
            $tom.collect(elMenu, "span.tx-slide-max").innerHTML = "";

            /* default 값 셋팅하는 부분이 필요하다? */
            this.bindEvent();
            this.setKnobPosition(config.defaultValue || config.min || 0);
        },
        regenerate: function(value) {
            value = parseInt(value * this.physicObj.width / this.logicObj.max);
            this.setKnobPosition(value);
        },
        bindEvent: function() {
            var elMenu = $tom.collect(this.elContext, "dd.tx-slide");
            var elPrev = $tom.collect(elMenu, "a.tx-slide-prev");
            var elNext = $tom.collect(elMenu, "a.tx-slide-next");
            var elBar = $tom.collect(elMenu, "div.tx-slide-bar");
            var elKnob = this.elKnob = $tom.collect(elMenu, "div.tx-slide-knob");

            $tx.observe(elKnob, "mousedown", function(ev) {
                this.isDrag = _TRUE;
                this.startPos = this.getKnobPosition();
                this.startX = ev.clientX;
                $tx.stop(ev);
            }.bind(this));

            $tx.observe(elKnob, "mouseup", function() {
                this.isDrag = _FALSE;
            }.bind(this));

            $tx.observe(this.elContext, "mousemove", function(ev) {
                if (this.isDrag) {
                    this.setKnobPosition(this.startPos + ev.clientX - this.startX);
                    $tx.stop(ev);
                    this.handler(this.result);
                }
            }.bind(this));

            $tx.observe(elPrev, "click", function(ev) {
                var count = Math.round(this.physicObj.interval) - 1;
                var that = this;
                var moveLeft = function() {
                    var pos = that.getKnobPosition();
                    that.setKnobPosition(pos - 1);
                    if (count-- > 0) {
                        setTimeout(moveLeft, 10);
                    } else {
                        that.handler(that.result);
                    }
                };
                moveLeft();
                $tx.stop(ev);
            }.bind(this));

            $tx.observe(elNext, "click", function(ev) {
                var count = Math.round(this.physicObj.interval);
                var that = this;
                var moveRight = function() {
                    var pos = that.getKnobPosition();
                    that.setKnobPosition(pos + 1);
                    if (--count > 0) {
                        setTimeout(moveRight, 10);
                    } else {
                        that.handler(that.result);
                    }
                };
                moveRight();
                $tx.stop(ev);
            }.bind(this));

            $tx.observe(this.elContext, "mouseup", function() {
                if (this.isDrag) {
                    this.isDrag = _FALSE;
                }
            }.bind(this));
            $tx.observe(elKnob, "click", function(ev) {
                $tx.stop(ev);
            }.bind(this));

            $tx.observe(elBar, "click", function(ev) {
                if (!this.isDrag) {
                    var x = ev.layerX || ev.x;
                    this.setKnobPosition(x - this.knobWidth / 2);
                    this.handler(this.result);
                }
            }.bind(this));
        },
        getKnobPosition: function() {
            var pos = $tx.getStyle(this.elKnob, "left");
            return pos.parsePx();
        },
        setKnobPosition: function(value) {
            value = (value < this.physicObj.max) ? value : this.physicObj.max;
            value = (value > this.physicObj.min) ? value : this.physicObj.min;
            $tx.setStyle(this.elKnob, { left: value.toPx() });

            this.result = Math.round(value * this.logicObj.interval / this.physicObj.interval);
        },
        setDisable: function() {
            this.isDisabled = _TRUE;
        },
        setEnable: function() {
            this.isDisabled = _FALSE;
        },
        getDisabled: function() {
            return this.isDisabled;
        }
    });


    /**
     * Trex.DynamicSizer Class
     * table의 가로세로 사이즈를 마우로 제어할 수 있는 위젯.
     * @class
     * @param {Object} config
     */
    Trex.DynamicSizer = Trex.Class.create({
        initialize: function(config) {
            /* config = {
             * 		el: //다이나믹 사이저가 실릴 영역
             * 		clickHandler : 클릭됐을때
             * 		moveHandler: 사이즈가 변경됐을 때
             */
            this.config = config;
            this.wrapper = config.el;
            this.elEventContext = tx.div({ className: "tx-dynamic-sizer-context" });
            this.currentSize = { row: 0, col: 0 };
            this.dynamicSizingEnabled = _TRUE;

            if (!config.moveHandler) {
                config.moveHandler = function() {}
            }
            if (!config.clickHandler) {
                config.clickHandler = function() {}
            }

            this.wrapper.appendChild(this.elEventContext);
            this.previewTable = new Trex.DynamicSizer.PreviewTable({
                parentEl: this.elEventContext,
                mouseOverHandler: this.changeSize.bind(this),
                mouseClickHandler: this.selectSize.bind(this)
            });
        },
        clear: function() {
            this.dynamicSizingEnabled = _TRUE;
            this.changeSize(0, 0);
        },
        changeSize: function(row, col) {
            if (this.dynamicSizingEnabled) {
                this.currentSize.row = row;
                this.currentSize.col = col;

                this._changeSelectionSize(row, col);
                this.config.moveHandler(row, col);
            }
        },
        _changeSelectionSize: function(row, col) {
            this.previewTable.moveSelectionPos(row, col);
        },
        toggleDynamicSizing: function() {
            this.dynamicSizingEnabled = !this.dynamicSizingEnabled;
            if (this.dynamicSizingEnabled) {
                this.selection.enableResize();
            } else {
                this.selection.disableResize();
            }
        },
        selectSize: function(ev) {
            this.config.clickHandler(ev, this.currentSize);
        },
        getCurruentSize: function() {
            return this.currentSize;
        }
    });

    Trex.DynamicSizer.PreviewTable = Trex.Class.create({
        $const: {
            DEFAULT_TD_STYLE: {},
            DEFAULT_TABLE_PROPERTY: {
                cellpadding: "0",
                cellspacing: "1"
            },
            MAX_SIZE: { COL: 10, ROW: 10 }
        },
        initialize: function(config) {
            this.config = config;
            this.elTable = _NULL;

            this.elTable = this.generateTable("tx-event");
            this.elSelection = tx.div({ className: "tx-selection" }, this.generateTable("tx-selection"));
            var tablePanel = this.generateTable("tx-panel");

            this.eventBinding();
            config.parentEl.appendChild(this.elTable);
            config.parentEl.appendChild(this.elSelection);
            config.parentEl.appendChild(tablePanel);

            var pos = $tom.getPosition(this.elTable);
            var PROPERTY = Trex.DynamicSizer.PreviewTable.MAX_SIZE;
            this.cellSize = {
                width: Math.round((pos.width - pos.x) / PROPERTY.COL),
                height: (pos.height - pos.y) / PROPERTY.ROW
            }
        },
        generateTable: function(className) {
            var tbody = tx.tbody();
            var PROPERTY = Trex.DynamicSizer.PreviewTable;
            for (var i = 0; i < PROPERTY.MAX_SIZE.ROW; i++) {
                var tr = tx.tr();
                for (var j = 0; j < PROPERTY.MAX_SIZE.COL; j++) {
                    var td = tx.td(tx.div({
                        style: PROPERTY.DEFAULT_TD_STYLE
                    }));
                    td = this.setCoordToAttr(td, j + 1, i + 1);
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
            var table = tx.table(PROPERTY.DEFAULT_TABLE_PROPERTY);
            $tx.addClassName(table, className || "");
            table.appendChild(tbody);
            return table;
        },
        moveSelectionPos: function(row, col) {
            var width = (col * this.cellSize.width).toPx();
            var height = (row * this.cellSize.height).toPx();
            $tx.setStyle(this.elSelection, { width: width, height: height });
        },
        setCoordToAttr: function(element, col, row) {
            element.setAttribute("col", col);
            element.setAttribute("row", row);
            return element;
        },
        getCoordFromAttr: function(element) {
            return {
                col: element.getAttribute("col") || 0,
                row: element.getAttribute("row") || 0
            }
        },
        eventBinding: function() {
            // 외부에서 받은 event핸들러들로 binding시킴
            this.mouseOverHandler = this.config.mouseOverHandler;
            this.mouseClickHandler = this.config.mouseClickHandler;
            var self = this;
            var _mouseOverHandler = function(ev) {
                var element = $tx.element(ev) || {};
                var tagName = (element.tagName || "").toUpperCase();
                if (element && tagName == "TD") {
                    var coord = self.getCoordFromAttr(element);
                    self.mouseOverHandler(coord.row, coord.col);
                }
                $tx.stop(ev);
            };
            var _mouseClickHandler = function(ev) {
                self.mouseClickHandler(ev);
            };
            $tx.observe(this.elTable, "mouseover", _mouseOverHandler);
            $tx.observe(this.elTable, "click", _mouseClickHandler);
        }
    });

    /*---- Trex.ImageScale ------------------------------------------------------*/
    Trex.ImageScale = Trex.Class.create({
        initialize: function(data, handler) {
            if (!data.imageurl) {
                return;
            }
            if (data.actualwidth) {
                return;
            }
            var _loadHandler = function(width, height) {
                data.actualwidth = width;
                data.actualheight = height;
                if (handler) {
                    handler(width, height);
                }
            };

            setTimeout(function() {
                var _tmpImage = new Image();
                _tmpImage.onerror = function() {
                    _tmpImage = _NULL;
                };
                if (_tmpImage.onreadystatechange) { //IE
                    _tmpImage.onreadystatechange = function() {
                        if (this.readyState == "complete") {
                            _loadHandler(this.width, this.height);
                            _tmpImage = _NULL;
                        }
                    };
                } else {
                    _tmpImage.onload = function() {
                        _loadHandler(this.width, this.height);
                        _tmpImage = _NULL;
                    };
                }
                _tmpImage.src = data.imageurl;
            }, 10);
        }
    });

    function getIconPath(virtualPath) {
        var realPath = TrexConfig.getIconPath(virtualPath);
        return realPath + "";
    }

})(Trex);


/**
 * @fileoverview
 * Class Trex.ImageResizer를 포함하고 있다.
 *
 * @author iamdanielkim
 *
 */

/**
 * img element에 원하는 width, height로 변경된 image를 loading한다.
 *
 *
 * @example
 *  var imageResizer = new Trex.ImageResizer(el, config);
 *  imageResizer.execResize(imageurl);
 *
 * @constructor
 * @param {Object} elImage
 * @param {Object} config
 */
Trex.ImageResizer = Trex.Class.create({
    initialize: function(elImage, config) {
        var _elImage = elImage;

        var _maxWidth = config.maxWidth || 200;
        var _maxHeight = config.maxHeight || 200;
        var _defImgUrl = config.defImgUrl;
        var _loadHandler = config.onComplete || function() {};

        function doResize(imgEl, imgurl) {
            var _resizedHeight, _resizedWidth;
            var _originWidth = imgEl.width;
            var _originHeight = imgEl.height;
            if (_originWidth == _maxWidth && _originHeight == _maxHeight) {
                _resizedWidth = _maxWidth;
                _resizedHeight = _maxHeight;
            } else if (_originWidth < _maxWidth && _originHeight < _maxHeight) {
                _resizedWidth = _originWidth;
                _resizedHeight = _originHeight;
            } else {
                _resizedHeight = _maxHeight;
                _resizedWidth = Math.floor(_maxHeight * (_originWidth / _originHeight));
                if (_resizedWidth > _maxWidth) {
                    _resizedWidth = _maxWidth;
                    _resizedHeight = Math.floor(_maxWidth * (_originHeight / _originWidth));
                }
            }
            _elImage.width = _resizedWidth;
            _elImage.height = _resizedHeight;
            _elImage.src = imgurl;
            _loadHandler(_resizedWidth, _resizedHeight);
        }

        /**
         * resize를 실행한다.
         *
         * @memberOf Trex.ImageResizer.prototype
         * @param {Object} imgurl
         */
        this.execResize = function(imgurl) {
            var _tmpImage = new Image();
            _tmpImage.onerror = function() {
                _elImage.width = _maxWidth;
                _elImage.height = _maxHeight;
                _elImage.src = _defImgUrl;
                _tmpImage = _NULL;
            };

            if (_tmpImage.onreadystatechange) { //IE
                _tmpImage.onreadystatechange = function() {
                    if (this.readyState == "complete") {
                        doResize(_tmpImage, imgurl);
                    }
                };
            } else {
                _tmpImage.onload = function() {
                    doResize(_tmpImage, imgurl);
                }
            }
            _tmpImage.src = imgurl;
        };
    }
});


/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.TableUtil = {
    /**
     * isDaumTable
     * @param {Element} table
     * @return {boolean}
     */
    isDaumTable: function(table) {
        return $tx.hasClassName(table, "txc-table");
    },
    /**
     * cloneNodeForEmptyTd
     * @param {Element} node
     */
    cloneNodeForEmptyTd: function(node) {
        var newNode;
        newNode = node.cloneNode(_FALSE);
        Trex.TableUtil.emptyTd(newNode);
        return newNode;
    },
    emptyTd: function(node) {
        //node.innerHTML = "<p><br></p>";
        node.innerHTML = $tom.EMPTY_PARAGRAPH_HTML;
    },
    /**
     * splitWidthByColSpan
     * @param {Element} td
     */
    splitWidthByColSpan: function(td) {
        var styleWidth;
        if (1 < td.colSpan && td.style.width) {
            styleWidth = parseInt(td.style.width, 10);
            $tom.setStyles(td, {
                width: Math.floor(styleWidth / td.colSpan) + "px"
            }, _TRUE);
        }
    },
    /**
     * splitHeightByRowSpan
     * @param {Element} td
     */
    splitHeightByRowSpan: function(td) {
        var styleHeight;
        if (1 < td.rowSpan && td.style.height) {
            styleHeight = parseInt(td.style.height, 10);
            $tom.setStyles(td, {
                height: Math.floor(styleHeight / td.rowSpan) + "px"
            }, _TRUE);
        }
    },
    /**
     * collapseCaret
     * @param {Trex.Canvas.WysiwygPanel} wysiwygPanel
     * @param {Element} node
     */
    collapseCaret: function(wysiwygPanel, node) {
        var range;
        try {
            range = wysiwygPanel.getProcessor().createGoogRangeFromNodes(node, 0, node, 0);
            range.select();
        } catch (ignore) {}
        //td space bug from create textnode.
        //wysiwygPanel.getProcessor().moveCaretTo(node);
    },
    collapseLastCaret: function(wysiwygPanel, node) {
        var range;
        try {
            var d = node.length ? node.length : node.childNodes.length;
            range = wysiwygPanel.getProcessor().createGoogRangeFromNodes(node, d, node, d),
                range.select()
        } catch (e) {}
    },
    /**
     * getClosestByTagNames
     * @param {Array} tagNames
     * @param {Element} el
     * @return {Element}
     */
    getClosestByTagNames: function(tagNames, el) {
        var tagName;
        if (el && typeof el.tagName === "string") {
            tagName = el.tagName.toLowerCase();
            if (tagName !== "body") {
                if (tagNames.contains(tagName)) {
                    return el;
                } else {
                    return arguments.callee(tagNames, el.parentNode);
                }
            }
        }
        return _NULL;
    },
    /**
     * getTableIndexerFromTd
     * @param {Element} td
     * @return {Trex.TableUtil.Indexer}
     */
    getTableIndexerFromTd: function(td) {
        var currentTable;
        currentTable = Trex.TableUtil.getClosestByTagNames(["table"], td);
        return new Trex.TableUtil.Indexer(currentTable);
    }
};
//////////////////////////////////////////////////////////
/**
 * Trex.TableUtil.Boundary class
 * @param {Object} indexs (optional)
 */
Trex.TableUtil.Boundary = Trex.Class.create({
    initialize: function(indexs) {
        this.top = -1;
        this.left = -1;
        this.bottom = -1;
        this.right = -1;
        if (indexs) {
            this.set(indexs);
        }
    },
    /**
     * getTop
     * @return {number} start row index
     */
    getTop: function() {
        return this.top;
    },
    /**
     * getLeft
     * @return {number} start col index
     */
    getLeft: function() {
        return this.left;
    },
    /**
     * getBottom
     * @return {number} end row index
     */
    getBottom: function() {
        return this.bottom;
    },
    /**
     * getRight
     * @return {number} end col index
     */
    getRight: function() {
        return this.right;
    },
    /**
     * setTop
     * @param {number} index
     */
    setTop: function(index) {
        this.top = index;
    },
    /**
     * setLeft
     * @param {number} index
     */
    setLeft: function(index) {
        this.left = index;
    },
    /**
     * setBottom
     * @param {number} index
     */
    setBottom: function(index) {
        this.bottom = index;
    },
    /**
     * setRight
     * @param {number} index
     */
    setRight: function(index) {
        this.right = index;
    },
    /**
     * set
     * @param {Object} indexs
     */
    set: function(indexs) {
        if ("top" in indexs) {
            this.setTop(indexs.top);
        }
        if ("left" in indexs) {
            this.setLeft(indexs.left);
        }
        if ("bottom" in indexs) {
            this.setBottom(indexs.bottom);
        }
        if ("right" in indexs) {
            this.setRight(indexs.right);
        }
    },
    /**
     * isValid
     * @return {boolean}
     */
    isValid: function() {
        if (this.top === -1) {
            return _FALSE;
        }
        if (this.left === -1) {
            return _FALSE;
        }
        if (this.bottom === -1) {
            return _FALSE;
        }
        if (this.right === -1) {
            return _FALSE;
        }
        return _TRUE;
    },
    /**
     * addBoundary
     * @param {number} rowIndex
     * @param {number} colIndex
     * @return {boolean} changed
     */
    addBoundary: function(rowIndex, colIndex) {
        var changedStart, changedEnd;
        changedStart = this.addStartBoundary(rowIndex, colIndex);
        changedEnd = this.addEndBoundary(rowIndex, colIndex);
        return changedStart || changedEnd;
    },
    /**
     * merge
     * @param {Trex.TableUtil.Boundary} boundary
     * @return {boolean} changed
     */
    merge: function(boundary) {
        var changedStart, changedEnd;
        changedStart = this.addStartBoundary(boundary.top, boundary.left);
        changedEnd = this.addEndBoundary(boundary.bottom, boundary.right);
        return changedStart || changedEnd;
    },
    /**
     * addStartBoundary
     * @private
     * @param {number} rowIndex
     * @param {number} colIndex
     * @return {boolean} changed
     */
    addStartBoundary: function(rowIndex, colIndex) {
        var changed;
        changed = _FALSE;
        if (this.top === -1 || rowIndex < this.top) {
            this.top = rowIndex;
            changed = _TRUE;
        }
        if (this.left === -1 || colIndex < this.left) {
            this.left = colIndex;
            changed = _TRUE;
        }
        return changed;
    },
    /**
     * addEndBoundary
     * @private
     * @param {number} rowIndex
     * @param {number} colIndex
     * @return {boolean} changed
     */
    addEndBoundary: function(rowIndex, colIndex) {
        var changed;
        changed = _FALSE;
        if (this.bottom === -1 || this.bottom < rowIndex) {
            this.bottom = rowIndex;
            changed = _TRUE;
        }
        if (this.right === -1 || this.right < colIndex) {
            this.right = colIndex;
            changed = _TRUE;
        }
        return changed;
    }
});

//////////////////////////////////////////////////////////
// Indexer 는 사람에게 보이는대로의 index 로 table 을
// 조작하는데 도움을 준다. DOM 에서는 rowSpan 과
// colSpan 때문에 보이는 index 와 일치하지 않기 때문임.
/**
 * Trex.TableUtil.Indexer class
 * @param {Element} table
 */
Trex.TableUtil.Indexer = Trex.Class.create({
    initialize: function(table) {
        this.indexData = _NULL;
        this.customIndexData = _NULL;
        this.table = _NULL;

        this.resetIndex();
        this.setTable(table);
        this.makeIndex();
    },
    /**
     * getRowSize
     * @return {number}
     */
    getRowSize: function() {
        return this.indexData.length;
    },
    /**
     * getColSize
     * @return {number}
     */
    getColSize: function() {
        if (0 < this.indexData.length) {
            return this.indexData[0].length;
        }
        return 0;
    },
    /**
     * getTd
     * rowIndex 와 colIndex 에 매칭되는 td 를 가져온다.
     * @param {number} rowIndex
     * @param {number} colIndex
     * @return {Elememt} td
     */
    getTd: function(rowIndex, colIndex) {
        if (this.indexData[rowIndex]) {
            if (this.indexData[rowIndex][colIndex]) {
                return this.indexData[rowIndex][colIndex];
            }
        }
        return _NULL;
    },
    /**
     * getTdArr
     * Boundary 에 포함되는 td 들을 가져온다.
     * @param {Trex.TableUtil.Boundary} boundary
     * @return {Array} tdArr [td, td, ...] (order by top-left)
     */
    getTdArr: function(boundary) {
        var result, rowIndex, cells, colIndex;
        result = [];
        rowIndex = boundary.top;
        while (rowIndex <= boundary.bottom) {
            cells = this.indexData[rowIndex];
            colIndex = boundary.left;
            while (colIndex <= boundary.right) {
                if (result.contains(cells[colIndex]) === _FALSE) {
                    result.push(cells[colIndex]);
                }
                colIndex += 1;
            }
            rowIndex += 1;
        }
        return result;
    },
    /**
     * KEDITOR
     * getTrArr
     * Boundary에 포함되는 tr[td]들을 가져온다.
     */
    getTrArr: function(boundary, isAllTrArr) {
        var result = [],
            rowIndex, cells, colIndex;
        //result = [];
        /**
         * selectedTr :[
         *  {
         * 		index:number,
         * 		cells:[
         * 			{
         * 				index:number,
         * 				cell: null | {index, rowIndex, colSpan, rowSpan, cColSpan, cell:object}
         * 			}
         * 		]
         * 	}
         *  ...
         * ]
         * allTr : [
         * 	{
         * 		index:number,
         * 		cells: [
         * 			null | {index, rowIndex, colSpan, rowSpan, cColSpan, cell:object}
         * 		]
         * 	}
         * 	...
         * ]
         */
        var allTr = null;
        if (isAllTrArr) allTr = this.getAllTrArr();
        rowIndex = boundary.top;
        while (rowIndex <= boundary.bottom) {
            cells = isAllTrArr ? allTr[rowIndex].cells : this.indexData[rowIndex];
            colIndex = boundary.left;
            var cols = [];
            while (colIndex <= boundary.right) {
                var cell = cells[colIndex];
                cols.push({ index: colIndex, cell: cell });
                colIndex += 1;
            }
            if (cols.length > 0) result.push({ index: rowIndex, cells: cols });
            rowIndex += 1;
        }
        return { selectedTr: result, allTr: allTr };
    },
    getAllTrArr: function() {
        if (this.customIndexData) return this.customIndexData;
        var rows = [],
            cells;
        for (var rowIdx = 0; rowIdx < this.indexData.length; rowIdx++) {
            cells = this.indexData[rowIdx];
            var cols = [];
            for (var colIdx = 0; colIdx < cells.length; colIdx++) {
                var cell = cells[colIdx];
                cols.push(cell ? {
                    index: colIdx,
                    rowIndex: rowIdx,
                    colSpan: cell.colSpan || 1,
                    rowSpan: cell.rowSpan || 1,
                    cColSpan: cell.colSpan || 1,
                    cell: cell
                } : null);
            }
            rows.push({ index: rowIdx, cells: cols });
        }
        for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
            for (var colIdx = 0; colIdx < rows[rowIdx].cells.length; colIdx++) {
                if (rows[rowIdx].cells[colIdx] == null) continue;
                var colSpan = rows[rowIdx].cells[colIdx].colSpan;
                var rowSpan = rows[rowIdx].cells[colIdx].rowSpan;

                for (var ri = 0; ri < rowSpan; ri++) {
                    for (var ci = (ri == 0 ? 1 : 0); ci < colSpan; ci++) {
                        rows[rowIdx + ri].cells[colIdx + ci] = null;
                    }
                }
                // 각 row의 해당 cell colspan값이 똑같은지 여부
                if (rowIdx == 0 && colSpan > 1) {
                    var is_all = true;
                    for (var i = 0; i < rows.length; i++) {
                        if (!(rows[i].cells[colIdx] && rows[i].cells[colIdx].colSpan == colSpan)) {
                            is_all = false;
                            break;
                        }
                        i += (rows[i].cells[colIdx].rowSpan || 1) - 1;
                    }
                    if (is_all) {
                        for (var i = 0; i < rows.length; i++) {
                            if (rows[i].cells[colIdx]) rows[i].cells[colIdx].cColSpan = 1;
                        }
                    }
                }
            }
        }
        return this.customIndexData = rows;
    },
    /**
     * getTdArrHasTop
     * 해당하는 row index 를 top 으로 가지는 cell 들을 가져온다.
     * @param {number} index
     * @return {Array} tdArr [td, td, ...] (order by left-top)
     */
    getTdArrHasTop: function(index) {
        var result, currentCell, adjoiningCell, len, i;
        result = [];
        len = this.getColSize();
        for (i = 0; i < len; i += 1) {
            currentCell = this.getTd(index, i);
            adjoiningCell = this.getTd(index - 1, i);
            this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
        }
        return result;
    },
    /**
     * getTdArrHasBottom
     * 해당하는 row index 를 bottom 으로 가지는 cell 들을 가져온다.
     * @param {number} index
     * @return {Array} tdArr [td, td, ...] (order by left-top)
     */
    getTdArrHasBottom: function(index) {
        var result, currentCell, adjoiningCell, len, i;
        result = [];
        len = this.getColSize();
        for (i = 0; i < len; i += 1) {
            currentCell = this.getTd(index, i);
            adjoiningCell = this.getTd(index + 1, i);
            this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
        }
        return result;
    },
    /**
     * getTdArrHasLeft
     * 해당하는 row index 를 left 로 가지는 cell 들을 가져온다.
     * @param {number} index
     * @return {Array} tdArr [td, td, ...] (order by left-top)
     */
    getTdArrHasLeft: function(index) {
        var result, currentCell, adjoiningCell, len, i;
        result = [];
        len = this.getRowSize();
        for (i = 0; i < len; i += 1) {
            currentCell = this.getTd(i, index);
            adjoiningCell = this.getTd(i, index - 1);
            this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
        }
        return result;
    },
    /**
     * getTdArrHasRight
     * 해당하는 row index 를 right 로 가지는 cell 들을 가져온다.
     * @param {number} index
     * @return {Array} tdArr [td, td, ...] (order by left-top)
     */
    getTdArrHasRight: function(index) {
        var result, currentCell, adjoiningCell, len, i;
        result = [];
        len = this.getRowSize();
        for (i = 0; i < len; i += 1) {
            currentCell = this.getTd(i, index);
            adjoiningCell = this.getTd(i, index + 1);
            this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
        }
        return result;
    },

    /**
     * getBoundary
     * td 에 해당하는 boundary 를 구한다.
     * @param {Elememt} td
     * @return {Trex.TableUtil.Boundary} boundary
     */
    getBoundary: function(td) {
        var result, rows, rowLen, rowIndex, cells, cellLen, colIndex;
        result = new Trex.TableUtil.Boundary();
        rows = this.indexData;
        rowLen = rows.length;
        for (rowIndex = 0; rowIndex < rowLen; rowIndex += 1) {
            cells = rows[rowIndex];
            if (cells) {
                cellLen = cells.length;
                for (colIndex = 0; colIndex < cellLen; colIndex += 1) {
                    if (cells[colIndex] === td) {
                        result.addBoundary(rowIndex, colIndex);
                    }
                }
            }
        }
        return result;
    },
    /**
     * reload
     * 인덱스 갱신(테이블이 변경되었을 때).
     */
    reload: function() {
        this.resetIndex();
        this.makeIndex();
    },
    /**
     * uniquePushWhenDifferent
     * currentCell 과 adjoiningCell 이 다르면 currentCell 를 tdArr 에 중복없이 push 한다.
     * @private
     * @param {Array} tdArr
     * @param {Element} currentCell
     * @param {Element} adjoiningCell
     */
    uniquePushWhenDifferent: function(tdArr, currentCell, adjoiningCell) {
        if (currentCell !== adjoiningCell) {
            if (tdArr.contains(currentCell) === _FALSE) {
                tdArr.push(currentCell);
            }
        }
    },
    /**
     * resetIndex
     * @private
     */
    resetIndex: function() {
        this.indexData = [];
        this.customIndexData = _NULL;
    },
    /**
     * setTable
     * @private
     * @param {Element} table
     */
    setTable: function(table) {
        this.table = table;
    },
    /**
     * makeIndex
     * rowSpan 과 colSpan 을 펼친 형태의 array 에 table cell 들을 매칭시킨다.
     * @private
     */
    makeIndex: function() {
        var rows, rowLen, rowIndex, row, cells, cellLen, colIndex, cell;
        rows = this.table.rows;
        rowLen = rows.length;
        for (rowIndex = 0; rowIndex < rowLen; rowIndex += 1) {
            row = rows[rowIndex];
            cells = row.cells;
            cellLen = cells.length;
            for (colIndex = 0; colIndex < cellLen; colIndex += 1) {
                cell = cells[colIndex];
                this.addCellIndex(rowIndex, cell);
            }
        }
    },
    /**
     * addCellIndex
     * 만들고 있는 indexData 에 해당 cell 에 대한 index 를 추가한다.
     * @private
     * @param {number} rowIndex
     * @param {Element} cell
     */
    addCellIndex: function(rowIndex, cell) {
        var viewIndexOfCell, row, rowSpan, calculatedRowIndex, col, colSpan;
        viewIndexOfCell = this.getNextCellIndex(this.indexData[rowIndex]);
        rowSpan = cell.rowSpan;
        for (row = 0; row < rowSpan; row += 1) {
            calculatedRowIndex = rowIndex + row;
            if (!this.indexData[calculatedRowIndex]) {
                this.indexData[calculatedRowIndex] = [];
            }
            colSpan = cell.colSpan;
            for (col = 0; col < colSpan; col += 1) {
                this.indexData[calculatedRowIndex][viewIndexOfCell + col] = cell;
            }
        }
    },
    /**
     * getNextCellIndex
     * arr 를 순환하면서 처음으로 만난 빈 요소의 index 를 반환한다.
     * arr 가 없으면 0 을 반환, 빈 요소가 없으면 length 를 반환한다.
     * @private
     * @param {Array} arr
     * @return {number} cell index
     */
    getNextCellIndex: function(arr) {
        var i, len;
        if (!arr) {
            return 0;
        }
        len = arr.length;
        for (i = 0; i < len; i += 1) {
            if (!arr[i]) {
                break;
            }
        }
        return i;
    }
});

/**
 * XmlHttpRequest객체를 생성하고 이 객체를 이용해 ajax request를 수행한다.
 * @class
 */
Trex.I.XHRequester = Trex.Faculty.create( /** @lends Trex.I.XHRequester */ {
    /**
     * 브라우져에 맞는 XmlHttpRequest 객체를 생성해서 리턴한다.
     * @private
     * @return {Object} XmlHttpRequest object
     */
    createXMLHttp: function() {
        var _xmlHttp = _NULL;
        try {
            if (_WIN.XMLHttpRequest) {
                _xmlHttp = new XMLHttpRequest();
            } else if (_WIN.ActiveXObject) {
                _xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
                if (!_xmlHttp) {
                    _xmlHttp = new ActiveXObject('Microsoft.XMLHTTP');
                }
            }
            return _xmlHttp;
        } catch (e) {
            return _NULL;
        }
    },
    /**
     * ajax call를 수행한다
     * @param {String} method - http request의 방식, "get" 또는 "post"
     * @param {String} url - request를 날릴 url
     * @param {Boolean} async - synchronous 여부
     * @param {Function} successHandler - ajax의 성공시의 핸들러
     * @param {Function} failHandler - ajax 실패시이의 핸들러
     * @example
     * this.sendRequest("get","http://www.daum.net/api",true,function(value){alert(value)}, function(){alert('fail');}
     */
    sendRequest: function(method, url, param, async, successHandler, failHandler) {
        if (url == _NULL && url != "") {
            return _NULL;
        }

        var _response = _NULL;
        var _xmlHttp = this.createXMLHttp();
        if (_xmlHttp == _NULL) {
            return _NULL;
        }

        var handler = function() {
            if (_xmlHttp.status == 200) {
                if (method.toUpperCase() == "HEAD") {
                    _response = successHandler(_xmlHttp.getAllResponseHeaders());
                } else {
                    _response = successHandler(_xmlHttp.responseText);
                }
            } else {
                _response = failHandler(_xmlHttp.status);
            }
            _xmlHttp = _NULL;
        };
        try {
            if (async) {
                _xmlHttp.onreadystatechange = function() {
                    if (_xmlHttp.readyState == 4) {
                        handler();
                    }
                };
            }
            if (method.toUpperCase() == "POST") {
                _xmlHttp.open("POST", url, async);
                _xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=utf-8");
                _xmlHttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                //webkit 오류발생
                //				_xmlHttp.setRequestHeader("Content-Length", param.length);
                //				_xmlHttp.setRequestHeader("Connetion","close");
                _xmlHttp.send(param);
            } else {
                if (param && param.length > 0) {
                    url = url + ((url.indexOf("?") > -1) ? "&" : "?") + param;
                }
                _xmlHttp.open(method.toUpperCase(), url, async);
                _xmlHttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                _xmlHttp.send(_NULL);
            }

            if (!async) {
                handler();
            }
            return _response;
        } catch (e) {
            return _NULL;
        }
    }
});

Trex.Responder = {
    callbacks: {},
    process: function( /*bytesLoaded, bytesTotal*/ ) {
        //if(bytesLoaded < 0) {
        // fail
        //} else {
        // progress
        //}
    },
    newKey: function() {
        var _key = "exe_" + Math.floor(Math.random() * 100000);
        if (this[_key]) {
            return this.newKey();
        } else {
            return _key;
        }
    },
    register: function(handler) {
        var _key = this.newKey();
        this.callbacks[_key] = function(response) {
            handler.apply(this, Array.prototype.slice.call(arguments, 0));
            this.callbacks[_key] = _NULL;
        }.bind(this);
        return _key;
    }
};

/**
 * 동적으로 외부의 javascript파일을 include한다.
 * @class
 */
Trex.I.JSRequester = Trex.Faculty.create( /** @lends Trex.I.JSRequester */ {
    /**
     * 특정위치의 스크립트 파일을 include 한다.
     * @param {String} url - http request의 방식, "get" 또는 "post"
     * @param {String} encoding - inlcude할 javascript의 encoding 타입
     * @param {Element} context - 로딩된 스크립트가 표시될 dom element
     * @param {Function} success - ajax의 성공시의 핸들러
     * @example
     * this.importScript("http://www.daum.net/api/movie.js?apikey=1234","utf-8", document, function(){alert("hello");} )
     */
    importScript: function(url, encoding, context, success) {
        if (url == _NULL && url != "") {
            return _NULL;
        }
        encoding = encoding || "utf-8";
        context = context || _DOC;
        try {
            var head = context.getElementsByTagName("head")[0] || context.documentElement;
            var script = context.createElement("script");
            script.type = "text/javascript";
            script.charset = encoding;
            script.src = url;

            var done = _FALSE;
            script.onload = script.onreadystatechange = function() {
                if (!done && (!this.readyState ||
                        this.readyState === "loaded" || this.readyState === "complete")) {
                    done = _TRUE;
                    if (success) {
                        success();
                    }

                    // Handle memory leak in IE
                    script.onload = script.onreadystatechange = _NULL;
                    if (head && script.parentNode) {
                        head.removeChild(script);
                    }
                }
            };
            head.insertBefore(script, head.firstChild);
        } catch (e) {
            // console.log(e)
        }
    }
});

_WIN.$stop = {};
_WIN.$propagate = {};
/**
 * 에디터에 정의된 custom 이벤트들을 발생시키고 등록된 이벤트 핸들러들을 실행시킨다.
 * custom 이벤트를 발생시키거나 혹은 custom 이벤트 발생시 핸들러를 실행시키기 위해서는 이 클래스를 minxin 받아야 한다.
 * @class
 */
Trex.I.JobObservable = Trex.Faculty.create( /** @lends Trex.I.JobObservable */ {
    /**
     * @private
     */
    jobObservers: {},
    /**
     * custom 이벤트가 발생하는지를 관찰하는 observer를 등록한다.
     * @param {String} name - custom 이벤트의 이름
     * @param {Function} observer - custom 이벤트 발생시 실행될 handler
     * @example
     * canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(){alert('canvas의 크기가 변했네요')})
     * cinema.observeJob("cinema_on_paste", function(){alert('영화가 첨부되었네요')})
     */
    observeJob: function(name, observer) {
        if (!this.jobObservers[name]) {
            this.jobObservers[name] = [];
        }
        this.jobObservers[name].push(observer);
    },
    reserveJob: function(name, observer, delay) {
        delay = delay || 500;
        if (!this.jobObservers[name]) {
            this.jobObservers[name] = [];
        }
        var _self = this;
        this.jobObservers[name].push(function() {
            var args = $A(arguments);
            setTimeout(function() {
                observer.apply(_self, args);
            }, delay);
        });
    },
    removeJob: function(name, observe) {
        if (!this.jobObservers[name])
            return;
        if (!observe) {
            this.jobObservers[name].length = 0;
        } else {
            for (var i = 0; i < this.jobObservers[name].length; i++) {
                if (this.jobObservers[name][i] === observe) {
                    this.jobObservers[name].splice(i, 1);
                }
            }
        }

    },
    /**
     * custom 이벤트를 발생시킨다. 이때 발생시킨 이벤트는 observerJob를 통해 등록된 observer들에게 전파된다.
     * @param {String} name - custom 이벤트의 이름
     * @example
     * canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(){alert('canvas의 크기가 변했네요')})
     * cinema.observeJob("cinema_on_paste", function(){alert('영화가 첨부되었네요')})
     */
    fireJobs: function(name) {
        var _self = this;
        var args = $A(arguments).slice(1);
        if (!this.jobObservers[name]) {
            return;
        }
        if (_WIN['DEBUG']) {
            this.jobObservers[name].each(function(observer) {
                observer.apply(_self, args);
            });
        } else {
            try {
                this.jobObservers[name].each(function(observer) {
                    observer.apply(_self, args);
                });
            } catch (e) {
                if (e != $stop) { throw e; }
            }
        }

    }
});

/**
 * 에디터에서 custom key이벤트들을 발생시키고 등록된 이벤트 핸들러들을 실행시킨다.
 * custom key 이벤트를 발생시키거나 혹은 custom key 이벤트 발생시 핸들러를 실행시키기 위해서는 이 클래스를 minxin 받아야 한다.
 * @class
 */
Trex.I.KeyObservable = Trex.Faculty.create( /** @lends Trex.I.KeyObservable */ {
    /**
     * @private
     */
    keyObservers: {},
    /**
     * custom 이벤트가 발생하는지를 관찰하는 observer를 등록한다.
     * @param {Object} keys - 이벤트가 발생하길 원하는 키의 조합 {ctrlKey:T, altKey:F, shiftKey:T, keyCode:17}
     * @param {Function} observer - 해당 이벤트 발생시 실행될 handler
     * @example
     * canvas.observeKey({ctrlKey:'T', altKey:'F', keyCode:32}, function(){alert('ctrl + 32키가 눌렸네요.')})
     */
    observeKey: function(keys, observer) {
        var _name = function(keys) {
            return (keys.ctrlKey ? 'T' : 'F') + (keys.altKey ? 'T' : 'F') + (keys.shiftKey ? 'T' : 'F') + "_" + keys.keyCode;
        }(keys);
        if (!this.keyObservers[_name]) {
            this.keyObservers[_name] = [];
        }
        this.keyObservers[_name].push(observer);
    },
    /**
     * 사용자가 정의한 custom key event를 발생시킨다. 이때 발생시킨 이벤트는 observerKey를 통해 등록된 observer들에게 전파된다.
     * @param {Object} ev - 사용자가 정의한 key의 pushed 상태 객체
     * @param {Boolean} bubble - 이벤트 전파 여부
     * @example
     * canvas.fireKyes({ctrlKey:'T', altKey:'F', keyCode:32}), function(){alert('영화가 첨부되었네요')})
     */
    fireKeys: function(ev, bubble) {
        var _name = function(ev) {
            return (ev.ctrlKey ? 'T' : 'F') + (ev.altKey ? 'T' : 'F') + (ev.shiftKey ? 'T' : 'F') + "_" + ev.keyCode;
        }(ev);
        if (!this.keyObservers[_name]) {
            return;
        }
        var _self = this;
        var eventStopped = _FALSE;
        var stopEventOnce = function() {
            if (!eventStopped) {
                $tx.stop(ev);
                eventStopped = _TRUE;
            }
        };
        this.keyObservers[_name].each(function(observer) {
            try {
                observer.apply(_self, [ev]);
                if (!bubble) stopEventOnce();
            } catch (e1) {
                if (e1 === $stop) {
                    stopEventOnce();
                } else if (e1 !== $propagate) {
                    // console.log(e1, e1.stack);
                }
            }
        });
    },
    registerKeyEvent: function(el) {
        try {
            $tx.observe(el, 'keydown', this.fireKeys.bind(this), _TRUE);
        } catch (e) {}
    }
});

/**
 * 마우스클릭이나 방향키를 이용해 특정 엘리먼트에 포커스가 갔을 경우 등록된 handler를 실행시킨다.
 * @class
 */
Trex.I.ElementObservable = Trex.Faculty.create( /** @lends Trex.I.ElementObservable */ {
    elementObservers: {},
    /**
     * 선택되길 원하는 element를 등록한다 .
     * @param {Object} layer - 관찰하기를 원하는 element의 tag name과 class name {tag: 'div', klass: 'txc-textbox'}
     * @param {Function} observer - 원하는 엘리먼트가 선택되었을때 실행되길 원하는 handler
     * @example
     * canvas.observeElement({tag:'div', klass: 'txc-textbox'}), function(){alert("div.txc-textbox가 선택되었네요.")})
     */
    observeElement: function(layer, observer) {
        if (layer == _NULL) { //all
            this.observeElement({ tag: "*tx-final-body*" }, observer);
        } else if (layer.length) {
            for (var i = 0; i < layer.length; i++) {
                var item = layer[i];
                this.observeElement(item, observer);
            }
        } else {
            if (!this.elementObservers[layer.tag]) {
                this.elementObservers[layer.tag] = {};
            }
            if (!layer.klass) {
                layer.klass = "*tx-all-class*";
            }
            if (!this.elementObservers[layer.tag][layer.klass]) {
                this.elementObservers[layer.tag][layer.klass] = [];
            }
            this.elementObservers[layer.tag][layer.klass].push(observer);
        }
    },
    /**
     * 특정 element가 선택되었을때 그 element가 선택되길 기다린 observer들에게 알려준다.
     * 해당하는 observer들은 handler를 실행시킨다.
     * @param {Element} node - 선택된 node
     * @example
     * canvas.fireElements(document.body)
     */
    fireElements: function(node) {
        if (!node) {
            return;
        }
        var _node = node;
        var args = $A(arguments).slice(1);

        var _self = this;
        try {
            var _observers;
            if ($tom.kindOf(_node, 'img,hr,table,button,iframe')) {
                _observers = this.collectObserverByElement(_node.nodeName.toLowerCase(), _node.className);
                if (_observers) {
                    _observers.each(function(observer) {
                        observer.apply(_self, [_node].concat(args));
                    });
                }
            } else {
                while (_node) {
                    _observers = this.collectObserverByElement(_node.nodeName.toLowerCase(), _node.className);
                    if (_observers) {
                        _observers.each(function(observer) {
                            observer.apply(_self, [_node].concat(args));
                        });
                    }
                    if ($tom.isBody(_node)) {
                        break;
                    }
                    _node = $tom.parent(_node);
                }
            }

        } catch (e) {
            if (e != $stop) { throw e; }
        }
        this.fireFinally();
    },
    fireFinally: function() {
        var _self = this;
        var args = $A(arguments).slice(1);
        var _observers = this.collectObserverByElement("*tx-final-body*");
        if (_observers) {
            _observers.each(function(observer) {
                observer.apply(_self, [_NULL].concat(args));
            });
        }
    },
    collectObserverByElement: function(tag, klass) {
        if (!this.elementObservers[tag]) {
            return _NULL;
        }

        var _observers = [];
        klass = klass || "";
        if (klass != "") {
            var _classes = klass.split(" ");
            for (var _klass in this.elementObservers[tag]) {
                if (_classes.contains(_klass)) {
                    _observers.push(this.elementObservers[tag][_klass]);
                }
            }
        }
        if (this.elementObservers[tag]["*tx-all-class*"]) {
            _observers.push(this.elementObservers[tag]["*tx-all-class*"]);
        }
        return _observers.flatten();
    }
});

Trex.I.MouseoverObservable = Trex.Faculty.create( /** @lends Trex.I.MouseoverObservable */ {
    mouseoverObservers: {},
    /**
     * 선택되길 원하는 element를 등록한다 .
     * @param {Object} selector - 관찰하기를 원하는 element의 tag name과 class name {tag: 'div', klass: 'txc-textbox'}
     * @param {Function} successObserver - 원하는 엘리먼트가 선택되었을때 실행되길 원하는 handler
     * @param {Function} failObserver
     * @example
     * canvas.observeElement({tag:'div', klass: 'txc-textbox'}), function(){alert("div.txc-textbox가 선택되었네요.")})
     */
    observeMouseover: function(selector, successObserver, failObserver) {
        if (!this.mouseoverObservers[selector]) {
            this.mouseoverObservers[selector] = {
                'success': [],
                'fail': [],
                'flag': _FALSE
            }
        }
        this.mouseoverObservers[selector]['success'].push(successObserver);
        if (failObserver) {
            this.mouseoverObservers[selector]['fail'].push(failObserver);
        }
    },
    fireMouseover: function(node) {
        if (!node) { return; }
        var _node = node;
        var _self = this;

        try {
            for (var i in this.mouseoverObservers) {
                this.mouseoverObservers[i].flag = _FALSE;
            }
            while (_node) {
                var _observers = this.collectMouseoverObserver(_node);
                if (_observers.length > 0) {
                    var _nodePos = this.getPositionByNode(_node);
                    _observers.each(function(observer) {
                        observer.apply(_self, [_node, _nodePos]);
                    });
                }
                if ($tom.isBody(_node)) {
                    break;
                }
                _node = $tom.parent(_node);
            }
        } catch (e) {
            if (e != $stop) { throw e; }
        }
        this.runMouseoverFailHandler();
    },
    runMouseoverFailHandler: function() {
        var _failHandlers = [];
        for (var i in this.mouseoverObservers) {
            if (!this.mouseoverObservers[i].flag) {
                _failHandlers.push(this.mouseoverObservers[i]['fail']);
            }
        }

        _failHandlers.flatten().each(function(handler) {
            handler();
        });
    },
    collectMouseoverObserver: function(node) {
        var _observers = [];
        var klass = node.className || "";
        var tag = node.tagName;

        if (tag) {
            tag = tag.toLowerCase();
            if (this.mouseoverObservers[tag]) {
                _observers.push(this.mouseoverObservers[tag]['success']);
                this.mouseoverObservers[tag]['flag'] = _TRUE;
            }
        }

        if (klass != "") {
            var _classes = klass.split(" ");
            for (var i = 0, len = _classes.length; i < len; i++) {
                var key = tag + "." + _classes[i];
                if (this.mouseoverObservers[key]) {
                    _observers.push(this.mouseoverObservers[key]['success']);
                    this.mouseoverObservers[key]['flag'] = _TRUE;
                }
            }

        }
        return _observers.flatten();
    }
});

/*---- Trex.I.Runnable ------------------------------------------------------*/
Trex.I.Runnable = Trex.Faculty.create({
    isRunning: _FALSE,
    repeater: _NULL,
    threads: [],
    startThread: function(term) {
        if (this.repeater) {
            this.repeater.clear();
        } else {
            this.repeater = new Trex.Repeater(this.runThread.bind(this));
        }
        this.repeater.start(term);
    },
    stopThread: function() {
        this.repeater.clear();
    },
    runThread: function() {
        if (this.isRunning) {
            return;
        }
        if (this.threads.length > 0) {
            this.isRunning = _TRUE;
            (this.threads.shift())();
            this.isRunning = _FALSE;
        }
    },
    putThread: function(thread, important) {
        if (important) {
            this.threads.unshift(thread);
        } else {
            this.threads.push(thread);
        }
    }
});

TrexMessage.addMsg({
    '@menu.pallete.revert': Trex._I18N.g("menu.pallete.revert", "기본색으로"),
    '@adoptor.label': Trex._I18N.g("adoptor.label", "가나다"),
    '@adoptor.transparent': Trex._I18N.g("adoptor.transparent", "투명")
});

Trex.MarkupTemplate.add(
    "menu.colorpallete.text",
    '#{for:items}<li class="tx-menu-list-item" style="background-color:#{color}"><a unselectable="on" style="color:#{text}">#{label}</a></li>#{/for:items}'
);
Trex.MarkupTemplate.add(
    "menu.colorpallete.thumb",
    // TODO forecolor,backcolor에서 <li class="tx-menu-list-item" unselectable="on" style="background-color:#FF0000;border:none;#{if:image!=null}background-image:url(#{image})#{/if:image};"></li> 이렇게 결과가 나온다.
    '#{for:items}<li class="tx-menu-list-item" unselectable="on" style="background-color:#{color};border:none;#{if:image!=null}background-image:url(#{image})#{/if:image};"></li>#{/for:items}'
);
Trex.MarkupTemplate.add(
    "menu.colorpallete.revert",
    '<p class="tx-pallete-revert"><a unselectable="on" href="javascript:;" title="@menu.pallete.revert">@menu.pallete.revert</a></p>'
);
Trex.I.ColorPallete = Trex.Faculty.create({
    isGradeInit: _FALSE,
    isPickerDisplayed: _FALSE,
    onregenerated: function(config, initValue) {
        this.setColorValueAtInputbox(initValue);
    },
    setColorValueAtInputbox: function(initValue) {
        if (!initValue) {
            return;
        }
        if (typeof initValue != "string" && initValue.toString) {
            initValue = initValue.toString();
        }
        var _color = initValue.split("|")[0];
        if (!Trex.Color.getValidColor(_color)) {
            _color = "#000000";
        }
        var _elValueInput = $tom.collect(this.elInner, 'p.tx-pallete-input input');
        var _elColorDisplay = $tom.collect(this.elInner, 'p.tx-pallete-input span');
        if (initValue && _elValueInput && _elColorDisplay) {
            _elValueInput.value = _color;
            _elColorDisplay.style.backgroundColor = _color;
        }
    },
    hookEvent: function(config) {
        var _elMenu = this.elMenu;
        var _elInner = this.elInner = $tom.collect(_elMenu, 'div.tx-menu-inner');

        var _elPreset = $tom.collect(_elInner, 'ul.tx-pallete-text-list');
        if (config.texts) {
            var _textOptions = config.texts.options;
            Trex.MarkupTemplate.get("menu.colorpallete.text").evaluateToDom({
                'items': _textOptions
            }, _elPreset);
            var _elPresetChilds = $tom.collectAll(_elPreset, "li");
            this.addColorClickEvent(_elPresetChilds, _textOptions);
        } else {
            _elInner.removeChild(_elPreset);
            _elPreset = _NULL;
        }

        if (config.thumbs) {
            var _needTrans = !!config.needTrans;
            var _thumbsOptions = [].concat(config.thumbs.options);
            if (_needTrans) { //투명이 필요한 컬러팔레트일 경우 마지막 컬러 삭제
                _thumbsOptions.pop();
                _thumbsOptions.push(Object.extend({}, config.thumbs.transparent));
            }
            var _elThumb = $tom.collect(_elInner, 'ul.tx-pallete-thumb-list');
            Trex.MarkupTemplate.get("menu.colorpallete.thumb").evaluateToDom({
                'items': _thumbsOptions
            }, _elThumb);
            var _elThumbChilds = $tom.collectAll(_elThumb, "li");
            this.addColorClickEvent(_elThumbChilds, _thumbsOptions);
        }

        this.elPicker = $tom.collect(_elInner, "div.tx-pallete-picker");

        var _elButton = $tom.collect(_elInner, 'div.tx-pallete-buttons');
        var _elMore = this.elMore = $tom.collect(_elButton, 'p.tx-pallete-more a');
        $tx.observe(_elMore, "click", this.togglePicker.bind(this));

        if (config.needRevert) {
            $tom.insertFirst(_elButton, Trex.MarkupTemplate.get("menu.colorpallete.revert").evaluateAsDom({}));
            $tx.observe($tom.collect(_elButton, 'p.tx-pallete-revert a'), "click", function(ev) {
                this.onSelect(ev, _NULL);
                this.hide();
            }.bind(this));
        }

        var _elPickerEnter = $tom.collect(this.elInner, "p.tx-pallete-input");
        this.elPreview = $tom.collect(_elPickerEnter, "span");
        var _elInput = this.elInput = $tom.collect(_elPickerEnter, "input");
        var _elEnter = this.elEnter = $tom.collect(_elPickerEnter, "a");
        var _self = this;
        $tx.observe(_elInput, "blur", function() {
            _self.lastValue = _elInput.value;
        });
        $tx.observe(_elEnter, "click", this.onColorEnter.bind(this));
    },
    addColorClickEvent: function(elItemList, textOptions) {
        for (var i = 0, end = elItemList.length; i < end; i++) {
            var _item = elItemList[i];
            var _option = textOptions[i]; // both elItemList.length and textOptions.length must be equal.
            $tx.observe(_item, "click", this.onSelect.bindAsEventListener(this, _option.color + (_option.text ? '|' + _option.text : '')));
        }
    },
    _generatePicker: function() {
        var _elPicker = this.elPicker;
        var _elPickerBox = $tom.collect(_elPicker, "div.tx-pallete-pickerbox");
        $tx.observe(_elPickerBox, "mouseout", this.onMouseOut.bind(this));

        var _elChromaBar = this.elChromaBar = $tom.collect(_elPickerBox, "div.tx-chromabar");
        $tom.replacePngPath(_elChromaBar);
        $tx.observe(_elChromaBar, 'mousedown', this.onChromDown.bindAsEventListener(this));
        $tx.observe(_elChromaBar, 'mousemove', this.onChromMove.bindAsEventListener(this));
        $tx.observe(_elChromaBar, 'mouseup', this.onChromUp.bindAsEventListener(this));

        this.elHueBar = $tom.collect(_elPickerBox, "div.tx-huebar");
        var _elHueBar = this.elHueBar;

        this.hueDownHandler = this.onHueDown.bindAsEventListener(this);
        this.hueMoveHandler = this.onHueMove.bindAsEventListener(this);
        this.hueUpHandler = this.onHueUp.bindAsEventListener(this);
        this.hueClickHandler = this.onHueClick.bindAsEventListener(this);
        $tx.observe(_elHueBar, 'mousedown', this.hueDownHandler);
        $tx.observe(_elHueBar, 'click', this.hueClickHandler);

        this.nColWidth = 150;
        this.nColHeight = 120;
        this.nHueHeight = 120;

        this.mRGB = { r: 0, g: 0, b: 0 };
        this.mHSV = { h: 0, s: 100, v: 100 };

        // 초기화
        this.setHueColor('FF0000');
    },
    reinitGrade: function() {
        var posParent = $tx.cumulativeOffset(this.elMenu);
        var position = $tx.positionedOffset(this.elChromaBar);
        this.iChromPos = {
            x: (posParent[0] + position[0]),
            y: (posParent[1] + position[1])
        };
        position = $tx.positionedOffset(this.elHueBar);
        this.iHuePos = {
            x: (posParent[0] + position[0]),
            y: (posParent[1] + position[1])
        };
    },
    onColorEnter: function(ev) {
        var color;
        if (this.elInput.value == TXMSG("@adoptor.transparent")) {
            color = "transparent";
        } else {
            color = Trex.Color.getValidColor(this.elInput.value);
        }
        if (color !== _NULL) {
            this.onSelect(ev, color);
        }
        this.hide();
    },
    previewColor: function(color) {
        this.changeColor(color);
    },
    onMouseOut: function() {
        if (this.lastValue !== _NULL && this.lastValue !== _UNDEFINED && this.mousedownDetected) {
            this.changeColor(this.lastValue);
        }
    },
    changeColor: function(color) {
        color = Trex.Color.getHexColor(color);
        this.elPreview.style.backgroundColor = color;
        if (color == "transparent") {
            this.elInput.value = TXMSG("@adoptor.transparent");
        } else {
            this.elInput.value = color;
        }
    },
    enterColor: function() {
        if (this.elInput.value == TXMSG("@adoptor.transparent")) {
            this.changeColor("transparent");
        } else if (this.elInput.value.length == 7) {
            var color = Trex.Color.getValidColor(this.elInput.value);
            if (color !== _NULL) {
                this.changeColor(color);
            }
        }
    },
    togglePicker: function(ev) {
        var _elMore = this.elMore;
        var _elPicker = this.elPicker;
        if (this.isPickerDisplayed) {
            _elMore.className = 'tx-more-down';
            $tx.hide(_elPicker);
        } else {
            _elMore.className = 'tx-more-up';
            $tx.show(_elPicker);
            if ($tx.msie6) {
                _elPicker.style.padding = "1px";
                setTimeout(function() {
                    _elPicker.style.padding = "0px";
                }, 0);
            }
            if (!this.isGradeInit) {
                this._generatePicker();
                this.isGradeInit = _TRUE;
                this.reinitGrade(); //position
            }
        }
        this.isPickerDisplayed = !this.isPickerDisplayed;
        $tx.stop(ev);
    },
    getChromCoords: function(ev) {
        var nPosX = (ev.clientX - this.iChromPos.x) + _DOC_EL.scrollLeft;
        var nPosY = (ev.clientY - this.iChromPos.y) + _DOC_EL.scrollTop;

        nPosX = Math.min(this.nColWidth, Math.max(0, nPosX));
        nPosY = Math.min(this.nColHeight, Math.max(0, nPosY));
        return { x: nPosX, y: nPosY };
    },
    getHueCoords: function(ev) {
        var y = ev.offsetY || ev.layerY;
        return Math.min(this.nHueHeight, Math.max(0, y));
    },
    getColorByEvent: function(x, y) {
        var s = (x / (this.nColWidth)) * 100;
        var v = (1 - y / (this.nColHeight)) * 100;

        var nMargin = 3;
        s = Math.floor(Math.min(Math.max(s, 0), 100));
        if (s < nMargin) {
            s = 0;
        } else if (s > 100 - nMargin) {
            s = 100;
        }
        v = Math.floor(Math.min(Math.max(v, 0), 100));
        if (v < nMargin) {
            v = 0;
        } else if (v > 100 - nMargin) {
            v = 100;
        }

        this.mHSV.s = s;
        this.mHSV.v = v;
        this.mRGB = this.hsv2rgb(this.mHSV.h, this.mHSV.s, this.mHSV.v);

        return this.rgb2hex(this.mRGB.r, this.mRGB.g, this.mRGB.b);
    },
    onChromDown: function() {
        this.mousedownDetected = _TRUE;
    },
    onChromMove: function(ev) {
        if (this.mousedownDetected) {
            var iPos = this.getChromCoords(ev);
            var color = this.getColorByEvent(iPos.x, iPos.y);
            this.previewColor(color);
        }
    },
    onChromUp: function(ev) {
        var iPos = this.getChromCoords(ev);
        var color = this.getColorByEvent(iPos.x, iPos.y);
        this.previewColor(color);
        this.lastValue = color;
        this.mousedownDetected = _FALSE;
    },
    getHueByEvent: function(y) {
        var h = parseInt((y / (this.nHueHeight)) * 360);
        this.mHSV.h = Math.floor(Math.min(Math.max(h, 0), 360));
        var mHueRgb = this.hsv2rgb(this.mHSV.h, 100, 100);
        return this.rgb2hex(mHueRgb.r, mHueRgb.g, mHueRgb.b);
    },
    setHueColor: function(sHueHex) {
        this.elChromaBar.style.backgroundColor = sHueHex;
    },
    onHueDown: function() {
        $tx.observe(_DOC, 'mousemove', this.hueMoveHandler);
        $tx.observe(_DOC, 'mouseup', this.hueUpHandler);
    },
    onHueMove: function(ev) {
        var y = this.getHueCoords(ev);
        var color = this.getHueByEvent(y);
        this.setHueColor(color);
    },
    onHueClick: function(ev) {
        var y = this.getHueCoords(ev);
        var color = this.getHueByEvent(y);
        this.setHueColor(color);
    },
    onHueUp: function() {
        $tx.stopObserving(_DOC, 'mousemove', this.hueMoveHandler);
        $tx.stopObserving(_DOC, 'mouseup', this.hueUpHandler);
    },
    hex2rgb: function(str) {
        this.mRGB.r = (this.toDec(str.substr(0, 1)) * 16) + this.toDec(str.substr(1, 1));
        this.mRGB.g = (this.toDec(str.substr(2, 1)) * 16) + this.toDec(str.substr(3, 1));
        this.mRGB.b = (this.toDec(str.substr(4, 1)) * 16) + this.toDec(str.substr(5, 1));
        return this.mRGB;
    },
    toDec: function(sHex) {
        var sHexChars = "0123456789ABCDEF";
        return sHexChars.indexOf(sHex.toUpperCase());
    },
    rgb2hex: function(r, g, b) {
        r = r.toString(16);
        if (r.length == 1) {
            r = '0' + r;
        }
        g = g.toString(16);
        if (g.length == 1) {
            g = '0' + g;
        }
        b = b.toString(16);
        if (b.length == 1) {
            b = '0' + b;
        }
        return '#' + r + g + b;
    },
    hsv2rgb: function(h, s, v) {

        h %= 360;
        s /= 100;
        v /= 100;

        var r = 0,
            g = 0,
            b = 0;

        if (s === 0) {
            r = Math.floor(v * 255);
            g = Math.floor(v * 255);
            b = Math.floor(v * 255);
        } else {
            var nH = h / 60;
            var nI = Math.floor(nH);
            var nV1 = v * (1 - s);
            var nV2 = v * (1 - s * (nH - nI));
            var nV3 = v * (1 - s * (1 - (nH - nI)));

            var nR = 0,
                nG = 0,
                nB = 0;

            if (nI === 0) {
                nR = v;
                nG = nV3;
                nB = nV1;
            } else if (nI == 1) {
                nR = nV2;
                nG = v;
                nB = nV1;
            } else if (nI == 2) {
                nR = nV1;
                nG = v;
                nB = nV3;
            } else if (nI == 3) {
                nR = nV1;
                nG = nV2;
                nB = v;
            } else if (nI == 4) {
                nR = nV3;
                nG = nV1;
                nB = v;
            } else if (nI == 5) {
                nR = v;
                nG = nV1;
                nB = nV2;
            }

            r = Math.floor(nR * 255);
            g = Math.floor(nG * 255);
            b = Math.floor(nB * 255);
        }
        return { r: r, g: g, b: b };
    },
    rgb2hsv: function(r, g, b) {
        var nR = (r / 255);
        var nG = (g / 255);
        var nB = (b / 255);

        var h = 0,
            s = 0,
            v = 0;

        var nMin = Math.min(nR, nG, nB);
        var nMax = Math.max(nR, nG, nB);
        var nDiff = nMax - nMin;

        v = nDiff;

        if (nDiff === 0) {
            h = 0;
            s = 0;
        } else {
            s = nDiff / nMax;
            var nDiffR = (((nMax - nR) / 6) + (nDiff / 2)) / nDiff;
            var nDiffG = (((nMax - nG) / 6) + (nDiff / 2)) / nDiff;
            var nDiffB = (((nMax - nB) / 6) + (nDiff / 2)) / nDiff;

            if (nR == nMax) {
                h = nDiffB - nDiffG;
            } else if (nG == nMax) {
                h = (1 / 3) + nDiffR - nDiffB;
            } else if (nB == nMax) {
                h = (2 / 3) + nDiffG - nDiffR;
            }
            if (h < 0) {
                h += 1;
            }
            if (h > 1) {
                h -= 1;
            }
        }
        return { h: h, s: s, v: v };
    }
});


/*---- Trex.Color ------------------------------------------------------*/
Trex.Color = {
    getHexColor: function(color) {
        color = color.trim();
        if (color.indexOf("rgb") < 0) {
            if (color.length > 0 && (color.indexOf("-moz-use") > -1 || color == "transparent")) {
                return "transparent";
            } else {
                return color;
            }
        }

        if (/rgba\s?\((0,\s?){3}0\)/i.test(color)) {
            return "transparent";
        }

        var aColor = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*\d*\)/i);
        if (!aColor) {
            return color;
        }
        aColor.shift();
        if (aColor.length < 3) {
            return color;
        }

        var nCh;
        var sHexColor = "#";
        for (var h = 0; h < 3; h++) {
            nCh = parseInt(aColor[h].trim()).toString(16).toUpperCase();
            if (nCh.length == 1) {
                sHexColor = sHexColor.concat("0" + nCh);
            } else if (nCh.length > 2) {
                sHexColor = sHexColor.concat("FF");
            } else {
                sHexColor = sHexColor.concat("" + nCh);
            }
        }
        return sHexColor;
    },
    getValidColor: function(color) {
        if (color === _NULL || color == "transparent") {
            return "transparent";
        }
        var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
        if (m === _NULL || color.length > 8) {
            return _NULL;
        }
        if (m[1].length == 3) {
            return "#" + m[1] + m[1];
        } else {
            return "#" + m[1];
        }
    },
    getOptColor: function(color, opacity) {
        if (!color || color.length != 7 || color.charAt(0) != '#') {
            return "#e5e5e5";
        }
        color = color.substring(1, 7).toLowerCase();
        opacity = isNaN(opacity) ? 100 : opacity;
        var _optColor = "#";
        var _sch, _och;
        for (var h = 0; h < 3; h++) {
            _sch = parseInt(color.substr(h * 2, 2), 16);
            _och = Math.round(Math.floor((255 - _sch) * (1 - opacity * 0.01) + _sch * (opacity * 0.02))).toString(16);
            if (_och.length == 1) {
                _optColor += "0" + _och;
            } else if (_och.length > 2) {
                _optColor += "ff";
            } else {
                _optColor += _och;
            }
        }
        return _optColor;
    }
};


Trex.I.CookieBaker = Trex.Faculty.create({
    cookieName: _NULL,
    cookieValue: _NULL,
    initCookie: function(name, maxCnt) {
        this.cookieName = name;
        this.cookieValue = function() {
            var cookies = _DOC.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = cookies[i].replace(/^\s+/, '');
                if (cookie.indexOf(name + '=') == 0) return cookie.substring(name.length + 1);
            }
            return _NULL;
        }() || "";
        this.maxCnt = maxCnt || 3;
    },
    writeCookie: function(value, days) {
        var name = this.cookieName,
            exp;
        if (days) {
            var time = new Date();
            time.setTime(new Date().getTime() + days * 24 * 60 * 60 * 1000);
            exp = '; expires=' + time.toGMTString();
        } else {
            exp = '';
        }
        if (value === _NULL) { //NOTE: #FTDUEDTR-888
            value = '';
        }
        _DOC.cookie = name + "=" + value + exp + "; path=/";
        this.cookieValue = value;
    },
    readCookie: function() {
        if (this.cookieValue === _NULL + '') { //NOTE: #FTDUEDTR-888
            return _NULL;
        }
        return this.cookieValue;
    },
    eraseCookie: function() {
        var name = this.cookieName;
        this.writeCookie(name, "", -1);
    },
    extractOptions: function(options, value) {
        var _optionMap = options.toMap('data');
        var _values = [];
        value.split('|').compact().each(function(data) {
            if (_optionMap[data]) {
                _values.push(_optionMap[data]);
            }
        }.bind(this));
        return _values;
    },
    mergeValues: function(value, data) {
        var _values = value.split('|').compact();
        if (_values.contains(data)) {
            return value;
        }
        if (_values.length >= this.maxCnt) {
            _values.pop();
        }
        _values.unshift(data);
        return _values.join('|');
    }
});


/**
 * @fileoverview
 * 에디터에서 사용되는 button의 모음
 *
 */

Trex.MarkupTemplate.add(
    'button.itsnew', '<em class="tx-itsnew" title="new">new</em>'
);

Trex.MarkupTemplate.add(
    'button.select.text', '<span>#{data}</span>'
);

/**
 * 일반적인 동작의 버튼 객체로, 특화된 버튼은 이 클래스를 상속받아 사용한다.<br/>
 * 해당 엘리먼트는 미리 DOM에 있어야 하며, __borderClasses에 지정된 클래스이름을 가져야한다.
 *
 * @class
 * @param {Object} config
 *
 * @example
 *	<div id="tx_example" class="tx-example tx-btn-lrbg" unselectable="on">
 *		<a title="예제" class="tx-icon" href="javascript:;">예제</a>
 *	</div>
 *
 * 	new Trex.Button({
 * 		id: 'tx_example',
 * 		wysiwygonly: _TRUE,
 * 		sync: false,
 * 		status: false
 * 	});
 */
Trex.Button = Trex.Class.create( /** @lends Trex.Button.prototype */ {
    /** @ignore */
    $const: {
        __borderClasses: {
            'tx-btn-trans': _TRUE,
            'tx-btn-lbg': _TRUE,
            'tx-btn-bg': _TRUE,
            'tx-btn-rbg': _TRUE,
            'tx-btn-lrbg': _TRUE,
            'tx-slt-tlbg': _TRUE,
            'tx-slt-tbg': _TRUE,
            'tx-slt-trbg': _TRUE,
            'tx-slt-blbg': _TRUE,
            'tx-slt-bbg': _TRUE,
            'tx-slt-brbg': _TRUE,
            'tx-slt-31bg': _TRUE,
            'tx-slt-31lbg': _TRUE,
            'tx-slt-31rbg': _TRUE,
            'tx-slt-70lbg': _TRUE,
            'tx-slt-70bg': _TRUE,
            'tx-slt-59bg': _TRUE,
            'tx-slt-42bg': _TRUE,
            'tx-slt-56bg': _TRUE,
            'tx-btn-nlrbg': _TRUE,
            'tx-btn-43lrbg': _TRUE,
            'tx-btn-52lrbg': _TRUE,
            'tx-btn-57lrbg': _TRUE,
            'tx-btn-71lrbg': _TRUE,
            'tx-btn-48lbg': _TRUE,
            'tx-btn-48rbg': _TRUE,
            'tx-btn-30lrbg': _TRUE,
            'tx-btn-46lrbg': _TRUE,
            'tx-btn-67lrbg': _TRUE,
            'tx-btn-49lbg': _TRUE,
            'tx-btn-58bg': _TRUE,
            'tx-btn-46bg': _TRUE,
            'tx-btn-49rbg': _TRUE,
            'tx-btn-widget': _TRUE,
            'tx-btn-widget-tbg': _TRUE,
            'tx-btn-widget-brbg': _TRUE
        },
        addBorderClass: function(className) {
            Trex.Button.__borderClasses[className] = _TRUE;
        },
        getBorderClass: function(el) {
            var _classes = $tx.classNames(el);
            for (var i = 0; i < _classes.length; i++) {
                var _class = _classes[i];
                var _matched = Trex.Button.__borderClasses[_class];
                if (_matched) {
                    return _class;
                }
            }
        }
    },
    /**
     * 상태가 있는지 여부
     */
    hasState: _NULL,
    /**
     * disabled 상태인지 여부
     */
    isDisabled: _NULL,
    /**
     * 메뉴가 있는 버튼의 경우 선택된 값 (ex: font-family tool에서 '궁서'를 선택하면 lastValue는 'Gungsuh,궁서'이다.)
     */
    lastValue: _NULL,
    /**
     * 메뉴가 있는 버튼의 경우 선택된 메뉴항목의 레이블
     */
    lastText: _NULL,
    /**
     * 버튼 dom element
     */
    elButton: _NULL,
    /**
     * 버튼의 아이콘 dom element
     */
    elIcon: _NULL,
    /**
     * 버튼의 배경 이미지 클래스이름
     */
    borderClass: _NULL,
    /**
     * 버튼의 실행 command function
     * @function
     */
    _command: function() {},
    /**
     * 버튼을 실행하면 호출 될 command function을 지정한다.
     * @private
     * @function
     */
    setCommand: function(cmd) {
        this._command = cmd;
    },
    initialize: function(config) { //only superclass
        var _config = this.config = config;
        if (_config.borderClass) {
            Trex.Button.addBorderClass(_config.borderClass);
        }

        this.itsNew = !!_config.itsnew;
        this.hasState = !!_config.status; //pushed status
        this.isDisabled = _FALSE;
        this.lastValue = _config.selectedValue || _NULL;

        if (config.el) {
            this.elButton = config.el;
        } else {
            var _elementId = _config.id || "tx_" + _config.identity;
            this.elButton = $must(_elementId + (_config.initializedId || ""));
        }
        var _elButton = this.elButton;

        var _elIcon = this.elIcon = $tom.collect(_elButton, "a");
        if (!_elIcon) {
            throw new Error("[Exception]Trex.Button : can't find elIcon for button '" + _elementId + "'");
        }
        this.borderClass = Trex.Button.getBorderClass(_elButton);

        if (this.oninitialized) {
            this.oninitialized.bind(this)(_config);
        }
        this.generate();

        if (this.itsNew) {
            $tom.append(_elIcon, Trex.MarkupTemplate.get('button.itsnew').evaluateAsDom({}));
        }

        if (_config.selectedValue && this.setValue) {
            this.setValue(_config.selectedValue);
        }
        if (_config.selectedText && this.setText) {
            this.setText(_config.selectedText);
        }
        if (_config.selectedState && this.setState) {
            this.setState(_config.selectedState);
        }
    },
    /**
     * 버튼의 이벤트에 handler function 을 걸어준다.
     * @function
     */
    generate: function() {
        var _elIcon = this.elIcon;
        this.hdlMouseDown = this.onMouseDown.bindAsEventListener(this);
        this.hdlMouseOver = this.onMouseOver.bindAsEventListener(this);
        this.hdlMouseOut = this.onMouseOut.bindAsEventListener(this);
        this.hdlKeydown = this.onKeyDown.bindAsEventListener(this);
        this.hdlClick = this.onClick.bindAsEventListener(this);

        $tx.observe(_elIcon, 'mousedown', this.hdlMouseDown);
        $tx.observe(_elIcon, 'mouseover', this.hdlMouseOver);
        $tx.observe(_elIcon, 'mouseout', this.hdlMouseOut);
        $tx.observe(_elIcon, 'keydown', this.hdlKeydown);
        $tx.observe(_elIcon, 'click', this.hdlClick);

        if (this.ongenerated) {
            this.ongenerated.bind(this)(this.config);
        }
    },
    /**
     * 버튼에 추가된 이벤트를 제거한다.
     * @function
     */
    removeHandler: function() {
        if (!this.hdlMouseDown) {
            return;
        }
        var _elIcon = this.elIcon;
        $tx.stopObserving(_elIcon, 'mousedown', this.hdlMouseDown);
        $tx.stopObserving(_elIcon, 'mouseover', this.hdlMouseOver);
        $tx.stopObserving(_elIcon, 'mouseout', this.hdlMouseOut);
        $tx.stopObserving(_elIcon, 'keydown', this.hdlKeydown);
        $tx.stopObserving(_elIcon, 'click', this.hdlClick);
    },
    /**
     * 버튼의 border class 이름을 가져온다.
     * @function
     * @returns {String} css class name 또는 'undefined'
     */
    getCurrentBorderClass: function(el) {
        var _classes = $tx.classNames(el);

        for (var i = 0; i < _classes.length; i++) {
            var _class = _classes[i];
            if (_class.indexOf(this.borderClass) != -1) {
                return _class;
            }
        }
        return _UNDEFINED + '';
    },
    /**
     * 버튼의 css class 를 초기상태로 변경한다.
     * @function
     */
    normalState: function() {
        var _currBorderClass = this.getCurrentBorderClass(this.elButton);
        if (_currBorderClass == this.borderClass) {
            return;
        }
        $tx.removeClassName(this.elButton, _currBorderClass);
        $tx.addClassName(this.elButton, this.borderClass);
    },
    /**
     * 버튼의 css class 를 mouse over 상태로 변경한다.
     * @function
     */
    hoveredState: function() {
        var _currBorderClass = this.getCurrentBorderClass(this.elButton);
        $tx.removeClassName(this.elButton, _currBorderClass);
        $tx.addClassName(this.elButton, this.borderClass + '-hovered');
        this.decreaseZindex();
    },
    /**
     * 버튼의 css class 를 눌려있는 상태로 변경한다.
     * @function
     */
    pushedState: function() {
        var _currBorderClass = this.getCurrentBorderClass(this.elButton);
        $tx.removeClassName(this.elButton, _currBorderClass);
        $tx.addClassName(this.elButton, this.borderClass + '-pushed');
    },
    /**
     * 버튼의 현재 상태를 반환한다.
     * @function
     * @return {String} 'normal', 'pushed', 'hovered'
     */
    currentState: function() {
        var _currBorderClass = this.getCurrentBorderClass(this.elButton);
        var cs = "normal";
        if (_currBorderClass.indexOf('-pushed') != -1) {
            cs = "pushed";
        } else if (_currBorderClass.indexOf('-hovered') != -1) {
            cs = "hovered";
        }
        return cs;
    },
    /**
     * 버튼이 눌린 상태인지 아닌지 판단한다.
     * @function
     * @return {boolean} 눌린 상태(pushed)이면 true, 아니면 false
     */
    isPushed: function() {
        return ("pushed" == this.currentState());
    },
    /**
     * 메뉴가 있는 버튼인지 판단한다.
     * @function
     * @return {boolean} 메뉴가 있으면 true, 아니면 false
     */
    hasMenu: function() {
        return this.tool ? !!(this.tool.menu) : _FALSE;
    },
    /**
     * 버튼을 누르면 normal state 또는 pushed state로 변경한다.
     * @function
     */
    onMouseDown: function(ev) {
        if (ev) {
            $tx.stop(ev);
        }
        if (this.isDisabled) {
            return;
        }
        if (this.hasMenu() || this.hasState) {
            if (this._command(ev) === _FALSE) {
                return;
            }
        } else {
            this.evsessionstarted = _TRUE;
        }
        if (this.isPushed()) {
            this.normalState();
        } else {
            this.pushedState();
        }
    },
    /**
     * 마우스 커서를 버튼영역 위에 올리면 hovered state로 변경한다.
     * @function
     */
    onMouseOver: function() {
        if (this.isDisabled || this.isPushed()) {
            return;
        }
        this.hoveredState();
    },
    /**
     * 마우스 커서가 버튼영역 바깥으로 나가면 normal state로 변경한다.
     * @function
     */
    onMouseOut: function() {
        if (this.evsessionstarted) {
            this.normalState();
            this.evsessionstarted = _FALSE;
        }
        if (this.isDisabled || this.isPushed()) {
            return;
        }
        this.normalState();
    },
    /**
     * 버튼을 클릭하면 command function을 실행하고 normal state로 변경한다.
     * @function
     */
    onClick: function(ev) {
        if (ev) {
            $tx.stop(ev);
        }
        if (this.isDisabled) {
            return;
        }
        if (!this.hasState) {
            this._event = ev; // Event가 필요해서.
            this._command();
            this.normalState();
            this.evsessionstarted = _FALSE;
        }
    },
    /**
     * event keyCode가 13이면 onMouseDown(), onClick() 을 실행한다.
     * @function
     */
    onKeyDown: function(ev) {
        if (ev.keyCode === 13) {
            this.onMouseDown(ev);
            this.onClick(ev);
        }
    },
    /**
     * command function 실행 후 lastValue, lastText의 값을 업데이트 한다.
     * @function
     */
    updateAfterCommand: function(value, text) {
        this.setValueAndText(value, text);
        this.normalState();
    },
    /**
     * lastValue, lastText의 값을 설정한다.
     * @function
     */
    setValueAndText: function(value, text) {
        this.setValue(value);
        this.setText(text);
    },
    /**
     * lastValue 값을 설정한다.
     * @function
     */
    setValue: function(value) {
        if (value) {
            this.lastValue = value;
        }
    },
    /**
     * lastText 값을 설정한다.
     * @function
     */
    setText: function(text) {
        this.lastText = text;
    },
    /**
     * lastValue 값을 가져온다.
     * @function
     * @return {String}
     */
    getValue: function() {
        return this.lastValue;
    },
    /**
     * lastText 값을 가져온다.
     * @function
     * @return {String}
     */
    getText: function() {
        return this.lastText;
    },
    /**
     * pushed에서 normal state로 또는 그 반대로 상태를 변경한다.
     * @function
     */
    setState: function(push) {
        if (push) {
            this.pushedState();
        } else {
            this.normalState();
        }
    },
    /**
     * 아이콘 element 의 css class 를 설정한다.
     * @function
     */
    setClassName: function(className) {
        this.elIcon.className = className;
    },
    /**
     * 버튼을 사용불가 상태로 변경한다.
     * @function
     */
    disable: function() {
        if (this.elButton) {
            this.isDisabled = _TRUE;
            $tx.addClassName(this.elButton, "tx-disable");
        }
    },
    /**
     * 버튼을 사용가능 상태로 변경한다.
     * @function
     */
    enable: function() {
        if (this.elButton && !this._btnAlwaysDisabled) {
            this.isDisabled = _FALSE;
            $tx.removeClassName(this.elButton, "tx-disable");
        }
    },
    /**
     * 버튼을 normal state로 변경한다.
     * @function
     */
    release: function() {
        if (this.isDisabled) {
            return;
        }
        if (this.hasMenu() || !this.hasState) {
            this.normalState();
        }
    },
    /**
     * 버튼의 zindex 크게 만든다.
     * @function
     */
    increaseZindex: function() {
        var zIndexValue = 10;
        if ($tom.parent(this.elButton)) {
            $tx.setStyle($tom.parent(this.elButton), { zIndex: zIndexValue });
        }
    },
    /**
     * 버튼의 zindex 작게 만든다.
     * @function
     */
    decreaseZindex: function() {
        var zIndexValue = 4;
        if ($tom.parent(this.elButton)) {
            $tx.setStyle($tom.parent(this.elButton), { zIndex: zIndexValue });
        }
    }
});

/**
 * Trex.Button.Select
 *
 * @extends Trex.Button
 * @class
 */
Trex.Button.Select = Trex.Class.create( /** @lends Trex.Button.Select.prototype */ {
    /** @ignore */
    $extend: Trex.Button,
    /**
     * 버튼에 화살표 버튼이 더 붙어 있을 경우 화살표 버튼에 event handler function 을 걸어준다.
     * @function
     */
    ongenerated: function() {
        Trex.MarkupTemplate.get('button.select.text').evaluateToDom({
            'data': $tom.getText(this.elIcon)
        }, this.elIcon);
        this.elText = $tom.collect(this.elIcon, 'span');

        var _elArrow = $tom.collect(this.elButton, "a.tx-arrow");
        if (_elArrow) {
            $tx.observe(_elArrow, 'mousedown', this.onMouseDown.bindAsEventListener(this));
            $tx.observe(_elArrow, 'mouseover', this.onArrowMouseOver.bindAsEventListener(this));
            $tx.observe(_elArrow, 'mouseout', this.onArrowMouseOut.bindAsEventListener(this));
            $tx.observe(_elArrow, 'click', this.onClick.bindAsEventListener(this));
        }
    },
    /**
     * 메뉴에서 선택된 값의 레이블을 설정한다.
     * @function
     */
    setText: function(text) {
        if (this.customLabelStyle) this.customLabelStyle();
        this.elText.innerText = text;
    },
    /**
     * 마우스 커서를 버튼영역 위에 올리면 hovered state로 변경한다.
     * @function
     */
    onArrowMouseOver: function() {
        if (this.isDisabled || this.isPushed()) {
            return;
        }
        this.hoveredState();
    },
    /**
     * 마우스 커서가 버튼영역 바깥으로 나가면 normal state로 변경한다.
     * @function
     */
    onArrowMouseOut: function() {
        if (this.isDisabled || this.isPushed()) {
            return;
        }
        this.normalState();
    }
});

/**
 * Trex.Button.Splits
 *
 * @extends Trex.Button
 * @class
 */
Trex.Button.Splits = Trex.Class.create( /** @lends Trex.Button.Splits.prototype */ {
    /** @ignore */
    $extend: Trex.Button,
    ongenerated: function() {
        var _elButton = this.elButton;
        var _elArrow = this.elArrow = $tom.collect(_elButton, "a.tx-arrow");
        if (!_elArrow) {
            throw new Error("[Exception]Trex.Button.Splits : not exist element(a.tx-arrow)");
        }
        $tx.observe(_elArrow, 'mousedown', this.onArrowMouseDown.bindAsEventListener(this));
        $tx.observe(_elArrow, 'mouseover', this.onArrowMouseOver.bindAsEventListener(this));
        $tx.observe(_elArrow, 'mouseout', this.onArrowMouseOut.bindAsEventListener(this));
        $tx.observe(_elArrow, 'click', this.onArrowClick.bindAsEventListener(this));
    },
    /**
     * 화살표 버튼의 css class 를 mouse over 상태로 변경한다.
     * @function
     */
    arrowHoveredState: function() {
        var _currBorderClass = this.getCurrentBorderClass(this.elButton);
        $tx.removeClassName(this.elButton, _currBorderClass);
        $tx.addClassName(this.elButton, this.borderClass + '-arrow-hovered');
    },
    /**
     * 화살표 버튼의 css class 를 pushed 상태로 변경한다.
     * @function
     */
    arrowPushedState: function() {
        var _currBorderClass = this.getCurrentBorderClass(this.elButton);
        $tx.removeClassName(this.elButton, _currBorderClass);
        $tx.addClassName(this.elButton, this.borderClass + '-arrow-pushed');
    },
    /**
     * 버튼을 누르면 상태를 변경하고 command를 실행한다. 버튼 옆에 있는 화살표의 상태를 본다.
     * @function
     */
    onMouseDown: function() {
        if (this.isDisabled) {
            return;
        }
        if (this.isPushed()) {
            this._command();
            this.normalState();
            this.commandexecuted = _TRUE;
        } else {
            this.pushedState();
            this.commandexecuted = _FALSE;
            this.evsessionstarted = _TRUE;
        }
    },
    /**
     * tool의 execute를 실행하고 normal state로 변경한다.
     * @function
     */
    onClick: function(ev) {
        if (ev) {
            $tx.stop(ev);
        }
        if (this.isDisabled) {
            return;
        }
        if (!this.commandexecuted) {
            this.tool.execute(this.lastValue, this.lastText);
            this.evsessionstarted = _FALSE;
        } else {
            this.commandexecuted = _FALSE;
        }
        this.normalState();
    },
    /**
     * 화살표를 pushed state 로 변경하거나 normal state로 변경한다.
     * @function
     */
    onArrowMouseDown: function() {
        if (this.isDisabled) {
            return;
        }
        if (this._command() === _FALSE) {
            return;
        }
        if (this.isPushed()) {
            this.normalState();
        } else {
            this.arrowPushedState();
        }
    },
    /**
     * @function
     */
    onArrowClick: function(ev) {
        if (ev) {
            $tx.stop(ev);
        }
        if (this.isDisabled) {
            return;
        }
    },
    /**
     * 화살표 버튼의 css class 를 mouse over 상태로 변경한다.
     * @function
     */
    onArrowMouseOver: function() {
        if (this.isDisabled || this.isPushed()) {
            return;
        }
        this.arrowHoveredState();
    },
    /**
     * 화살표 버튼의 css class 를 normal 상태로 변경한다.
     * @function
     */
    onArrowMouseOut: function() {
        if (this.isDisabled || this.isPushed()) {
            return;
        }
        if (this.commandexecuted) {
            this.commandexecuted = _FALSE;
        }
        this.normalState();
    }
});

/**
 * Trex.Button.Toggle
 *
 * @extends Trex.Button
 * @class
 */
Trex.Button.Toggle = Trex.Class.create( /** @lends Trex.Button.Toggle.prototype */ {
    /** @ignore */
    $extend: Trex.Button,
    /**
     * pushed 또는 normal state로 변경한다.
     * @function
     */
    setValue: function(selected) {
        if (selected) {
            this.pushedState();
        } else {
            this.normalState();
        }
    }
});

/**
 * Trex.Button.Widget
 *
 * @extends Trex.Button.Select
 * @class
 */
Trex.Button.Widget = Trex.Class.create( /** @lends Trex.Button.Widget.prototype */ {
    /** @ignore */
    $extend: Trex.Button.Select,
    /**
     * lastText 값을 설정한다.
     * @function
     */
    setText: function(text) {
        this.elIcon.innerText = text;
        if (this.lastText) {
            $tx.removeClassName(this.elIcon, this.lastText);
        }

        $tx.addClassName(this.elIcon, text);
        this.lastText = text;
    },
    /**
     * 버튼에 menu와 menu handler를 설정한다.
     * @function
     */
    setMenu: function(menu, handler) {
        this.hasState = _TRUE;
        var _button = this;

        menu.setCommand(function() {
            var success = handler.apply(this, arguments);
            _button.updateAfterCommand.apply(_button, arguments);
            return success;
        });

        _button.setCommand(
            function() {
                if (!_button.isPushed()) {
                    var _lastvalue = _button.getValue();
                    menu.show(_lastvalue);
                } else {
                    menu.hide();
                }
                return _TRUE;
            }
        );
    }
});

/**
 * Trex.Button.ColorWidget
 *
 * @extends Trex.Button.Widget
 * @class
 */
Trex.Button.ColorWidget = Trex.Class.create( /** @lends Trex.Button.ColorWidget.prototype */ {
    /** @ignore */
    $extend: Trex.Button.Widget,
    /**
     * lastValue 값을 설정한다.
     * @function
     */
    setValue: function(value) {
        $tx.setStyle(this.elIcon.parentNode, { 'backgroundColor': value });
        this.lastValue = value;
    },
    /**
     * do nothing
     * @function
     */
    setText: function() {
        // do Nothing
    }
});

/**
 * @fileoverview
 * 에디터에서 사용되는 menu의 모음
 */

TrexMessage.addMsg({
    '@menu.pallete.enter': Trex._I18N.g("menu.pallete.enter", "입력"),
    '@menu.pallete.more': Trex._I18N.g("menu.pallete.more", "더보기")
});
/**
 * 일반적인 동작의 메뉴 객체로, 특화된 메뉴는 이 클래스를 상속받아 사용한다.<br/>
 * 해당 엘리먼트는 미리 DOM에 있어야 한다.
 * tool에서 사용된다.
 *
 * @class
 * @param {Object} config
 *
 * @example
 *	Trex.Menu.Example = Trex.Class.create({
 *		$extend: Trex.Menu,
 *		ongenerated: function(config) {
 *			//TODO
 *		},
 *		onregenerated: function(config) {
 *			//TODO
 *		}
 * });
 *
 *	new Trex.Menu({
 *		id: 'tx_example_menu',
 *		options: [
 *			{ label: '옵션1', title: '옵션1', data: 'option1' },
 *			{ label: '옵션2', title: '옵션1', data: 'option2' }
 *		]
 *	});
 */
Trex.Menu = Trex.Class.create( /** @lends Trex.Menu.prototype */ {
    $mixins: [Trex.I.JobObservable],
    isInit: _FALSE,
    isDisplayed: _FALSE,
    _command: function() {},
    /**
     * menu에 command를 설정한다.
     * @private
     * @function
     */
    setCommand: function(cmd) {
        this._command = cmd;
    },
    initialize: function(config) {
        var _config = this.config = config;

        var _elMenu;
        var _initializedId = ((_config.initializedId) ? _config.initializedId : "");
        if (_config.el) {
            _elMenu = _config.el;
            if (!_elMenu) {
                throw new Error("[Exception]Trex.Menu : not exist element(" + _config.el + ")");
            }
        } else {
            var _elementId = _config.id;
            if (!_elementId) {
                if (!_config.identity) {
                    throw new Error("[Exception]Trex.Menu : not exist config - id");
                }
                _elementId = "tx_" + _config.identity + "_menu";
            }
            _elMenu = $tx(_elementId + _initializedId);
            if (!_elMenu) {
                throw new Error("[Exception]Trex.Menu : not exist element(" + _elementId + ")");
            }
        }
        this.elMenu = _elMenu;

        //팝업메뉴
        this.elPopupMenu = $tx('tx_popup_menu' + _initializedId);

        if (_config.top) {
            _elMenu.style.top = _config.top + 'px';
        }
        if (_config.left) {
            _elMenu.style.left = _config.left + 'px';
        }

        if (this.oninitialized) {
            this.oninitialized.bind(this)(config);
        }
        if (this.ongenerated) {
            this.generateHandler = this.ongenerated.bind(this);
        }
        if (this.onregenerated) {
            this.regenerateHandler = this.onregenerated.bind(this);
        }
    },
    /**
     * menu를 DOM을 생성한다.
     * @function
     */
    generate: function(initValue) {
        if (this.generateHandler) {
            var _config = this.config;
            this.generateHandler(_config, initValue);
        }
    },
    /**
     * menu를 재생성한다.
     * @function
     */
    regenerate: function(initValue) {
        if (this.initHandler) {
            this.initHandler();
        }
        if (this.regenerateHandler) {
            var _config = this.config;
            this.regenerateHandler(_config, initValue);
        }
    },
    /**
     * menu option 중에서 유효한 값만 걸러낸다.
     * @function
     */
    getValidOptions: function(config) {
        return config.options.findAll(function(option) {
            return !option.expired;
        });
    },
    /**
     * menu 에서 선택된 항목에 대한 command를 실행한다.
     * @function
     */
    onSelect: function() {
        var args = $A(arguments);
        var ev = args.shift();
        this._command.apply(this, args); //가변적인 arguments를 위해
        this.hide();
        if(ev) $tx.stop(ev);
    },
    /**
     * menu 에서 취소를 누르면 menu 를 닫는다.
     * @function
     */
    onCancel: function() {
        if (this.cancelHandler) {
            this.cancelHandler();
        }
        this.hide();
    },
    /**
     * menu 가 열린 상태인지 확인한다.
     * @function
     * @return {boolean} 열려있으면 true, 아니면 false
     */
    visible: function() {
        return this.isDisplayed;
    },
    /**
     * menu 를 연다. this.generate() 또는 this.regenerate() function을 호출한다.
     * @function
     */
    show: function(initValue) {
        $tx.show(this.elMenu);
        if (this.isInit) {
            this.regenerate(initValue);
        } else {
            if (!!this.config.listseturl) {
                this.lazyGenerate(initValue);
            } else {
                this.generate(initValue);
                this.isInit = _TRUE;
                this.regenerate(initValue);
            }
        }
        if (this.showSpecial) { //NOTE: 메뉴가 보여질 때 추가적으로 실행할 액션, ex) URL넣기에서 focus를 줄 때
            this.showSpecial();
        }
        /**
         * KEDITOR
         * Layer 위치 조정.
         */
        var $popup = $(this.elMenu);
        var left = null,
            $container = null;
        var pli = $popup.closest('li');
        if ($popup.closest('li').length > 0) {
            left = $popup.closest('li').position().left;
            $container = $popup.closest('.tx-toolbar');
        }
        // else if($popup.closest('dd').length > 0){
        // 	left = $popup.closest('dd').position().left;
        // 	$container = $popup.closest('.popup_wrap');
        // 	if($container) left += $container.position().left;
        // }
        if (left != null && $container != null) {
            if (left + $popup.outerWidth() > $container.position().left + $container.outerWidth()) {
                var offset = ($container.position().left + $container.outerWidth()) - (left + $popup.outerWidth() + 10);
                $popup.css('left', offset + 'px');
            } else {
                $popup.css('left', '0');
            }
        }
        this.isDisplayed = _TRUE;
        this.fireJobs(Trex.Ev.__MENU_LAYER_SHOW, {
            detail: {
                menu: this
            }
        });
    },
    lazyGenerate: function(initValue) {
        var _menu = this;
        new(Trex.Class.create({
            $mixins: [Trex.I.JSRequester],
            initialize: function() {
                this.importScript(
                    _menu.config.listseturl,
                    'utf-8',
                    _DOC,
                    function() {
                        _menu.generate();
                        _menu.isInit = _TRUE;
                        _menu.regenerate(initValue);
                    }
                );
            }
        }))();
    },
    /**
     * menu 를 닫는다.
     * @function
     */
    hide: function() {
        $tx.hide(this.elMenu);
        this.isDisplayed = _FALSE;
        this.fireJobs(Trex.Ev.__MENU_LAYER_HIDE, {
            detail: {
                menu: this
            }
        });
    },
    /**
     * menu 를 열거나 닫는다.
     * @function
     */
    toggle: function() {
        if (this.isDisplayed) {
            this.hide();
        } else {
            this.show();
        }
    },
    /**
     * menu 를 닫는다.
     * @function
     */
    release: function(ev) {
        if (!this.isInit) {
            return;
        }
        this.hide(ev);
    }
});

Trex.MarkupTemplate.add(
    'menu.select',
    '<ul class="tx-menu-list" unselectable="on">#{items}</ul>'
);
Trex.MarkupTemplate.add(
    'menu.select.item',
    '<li class="tx-menu-list-item"><a class="#{klass}" href="javascript:;" unselectable="on">#{label}</a></li>'
);

/**
 * Trex.Menu.Select
 * as fontfamily, fontsize
 *
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.Select = Trex.Class.create( /** @lends Trex.Menu.Select.prototype */ {
    /** @ignore */
    $extend: Trex.Menu,
    /**
     * menu를 생성한다.
     * @function
     */
    generate: function() {
        /*
        	[{
        		label: "string",
        		title: "string",
        		data: "string",
        		klass: "string"
        	}]
        */
        var _config = this.config;
        var _optionz = this.getValidOptions(_config);

        var _elList = this.generateList(_optionz);
        $tom.insertFirst(this.elMenu, _elList);

        if (this.generateHandler) {
            this.generateHandler(_config);
        }
        if (this.ongeneratedList) {
            this.generateList = this.ongeneratedList.bind(this);
        }
        if (this.ongeneratedListItem) {
            this.generateListItem = this.ongeneratedListItem.bind(this);
        }
    },

    /**
     * menu 의 list markup 을 만들고 event handler 를 연결한다.
     * @function
     */
    generateList: function(optionz) {
        var _elGroup = Trex.MarkupTemplate.get("menu.select").evaluateAsDom({
            'items': this.generateListItem(optionz)
        });

        var _elItemList = $tom.collectAll(_elGroup, "li a");
        for (var i = 0; i < optionz.length; i++) {
            var _option = optionz[i];
            var _elItem = _elItemList[i];
            $tx.observe(_elItem, "click", this.onSelect.bindAsEventListener(this, _option.data, _option.title));
        }
        return _elGroup;
    },
    /**
     * menu 의 list item markup 생성한다.
     * @function
     * @return {String} HTML markup
     */
    generateListItem: function(option) {
        var result = [];
        for (var i = 0; i < option.length; i++) {
            result.push(Trex.MarkupTemplate.get("menu.select.item").evaluate(option[i]));
        }
        return result.join("");
    },
    /**
     * menu 의 list item 이 선택되었을 때 command 를 실행한다.
     * @function
     */
    onSelect: function() {
        var _args = $A(arguments);
        var _ev = _args.shift();
        this._command.apply(this, _args);
        this.hide();
        if(_ev) $tx.stop(_ev);
    }
});

Trex.MarkupTemplate.add(
    'menu.items', [
        '<table unselectable="on"><tbody>',
        '	#{for:row}<tr>',
        '		#{for:col}<td class="tx-menu-list-item">',
        '<a href="javascript:;"><span class="#{klass}">',
        '#{if:image!=""}<img src="#{image}" data="#{data}"/>#{/if:image}',
        '#{if:image=""}#{data}#{/if:image}',
        '</span></a>',
        '		</td>#{/for:col}',
        '	</tr>#{/for:row}',
        '</tbody></table>'
    ].join("")
);

Trex.MarkupTemplate.add(
    'menu.list', [
        '<div class="tx-menu-inner">',
        '	<div class="tx-menu-list">',
        '   	#{items}',
        '    </div>',
        '</div>'
    ].join("")
);

/**
 * Trex.Menu.List
 * as horizontalrule, lineheight, quote, textbox
 *
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.List = Trex.Class.create( /** @lends Trex.Menu.List.prototype */ {
    /** @ignore */
    $extend: Trex.Menu,
    /**
     * menu를 생성한다.
     * @function
     */
    generate: function() {
        var _config = this.config;
        /*
        	[{
        		data: "string",
        		klass: "string"
        	}]
        */
        var _optionz = this.getValidOptions(_config);
        this.cols = _config.cols || 1;
        this.rows = _config.rows || _optionz.length;

        var _elList = this.generateList(_optionz);
        $tom.insertFirst(this.elMenu, _elList);

        if (this.ongeneratedList) {
            this.generateList = this.ongeneratedList.bind(this);
        }
        if (this.ongeneratedListItem) {
            this.generateListItem = this.ongeneratedListItem.bind(this);
        }

        if (this.generateHandler) {
            this.generateHandler(_config);
        }
    },
    /**
     * menu 의 list markup 을 만들고 mouse event handler 를 연결한다.
     * @function
     */
    generateList: function(options) {
        var _options = Trex.MarkupTemplate.splitList(this.rows, this.cols, options);
        var _elList = Trex.MarkupTemplate.get('menu.list').evaluateAsDom({
            'items': Trex.MarkupTemplate.get('menu.items').evaluate(_options)
        });

        $tx.observe(_elList, "click", this.onSelect.bindAsEventListener(this));
        $tx.observe(_elList, 'mouseover', this.onItemMouseOver.bindAsEventListener(this));
        $tx.observe(_elList, 'mouseout', this.onItemMouseOut.bindAsEventListener(this));

        return _elList;
    },
    /**
     * menu 항목에 mouse over 할 때 hover state 의 style class 를 적용한다.
     * @function
     */
    onItemMouseOver: function(ev) {
        var _el = $tx.findElement(ev, 'span');
        if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
            $tx.addClassName(_el, "tx-item-hovered");
        }
        $tx.stop(ev);
    },
    /**
     * menu 항목에 mouse out 할 때 hover state 의 style class 를 해제한다.
     * @function
     */
    onItemMouseOut: function(ev) {
        var _el = $tx.findElement(ev, 'span');
        if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
            $tx.removeClassName(_el, "tx-item-hovered");
        }
        $tx.stop(ev);
    },
    /**
     * menu 의 항목이 선택되었을 때 command 를 실행한다.
     * @function
     */
    onSelect: function(ev) {
        var _el = $tx.findElement(ev, 'span');
        if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
            var _data;
            if (_el.firstChild && _el.firstChild.nodeType == 1 && _el.firstChild.tagName.toLowerCase() == 'img') {
                _data = $tom.getAttribute(_el.firstChild, "data") || "";
            } else {
                _data = _el.innerText;
            }
            this._command(_data);
            this.hide();
        }
        $tx.stop(ev);
    }
});

Trex.MarkupTemplate.add(
    'menu.matrix', [
        '<div class="tx-menu-inner">',
        '	<ul class="tx-menu-matrix-title">',
        '		#{for:matrices}<li class=""><a href="javascript:;" class="tx-menu-matrix-title-item">#{title}</a></li>#{/for:matrices}',
        '	</ul>',
        '	<div class="tx-menu-matrix-listset">',
        '   	#{for:matrices}<div class="tx-menu-matrix-list #{klass}">',
        '       	#{items}',
        '		</div>#{/for:matrices}',
        '    </div>',
        '</div>'
    ].join("")
);

/**
 * Trex.Menu.Matrix
 * as emoticon
 *
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.Matrix = Trex.Class.create( /** @lends Trex.Menu.Matrix.prototype */ {
    /** @ignore */
    $extend: Trex.Menu,
    /**
     * menu를 생성한다.
     * @function
     */
    generate: function() {
        var _config = this.config;
        /*
        	rows: number,
        	cols: number,
        	matrices: [{
        		title: "string",
        		options: ["string", ...]
        	}]

        */
        var _matrices = this.matrices = _config.matrices.findAll(function(matrix) {
            return !matrix.onlyIE || $tx.msie;
        });
        this.cols = _config.cols || 10;
        this.rows = _config.rows || 5;

        var _elList = this.generateMatrix(_matrices);
        $tom.insertFirst(this.elMenu, _elList);

        if (this.ongeneratedList) {
            this.generateList = this.ongeneratedList.bind(this);
        }
        if (this.ongeneratedListItem) {
            this.generateListItem = this.ongeneratedListItem.bind(this);
        }

        if (this.generateHandler) {
            this.generateHandler(_config);
        }

        this.showTab();
    },
    /**
     * menu를 재생성한다.
     * @function
     */
    regenerate: function() {
        this.showTab();
        if (this.regenerateHandler) {
            var _config = this.config;
            this.regenerateHandler(_config);
        }
    },
    /**
     * menu를 열 때 디폴트 Tab 혹은 최근에 열었던 Tab 을 보여준다.
     * @function
     */
    showTab: function() {
        var listItemToShow = this.lastElList;
        var titleItemToShow = this.lastElTitleItem;

        var isFirstTime = (!listItemToShow || !titleItemToShow);
        if (isFirstTime) {
            listItemToShow = this.defaultElListItem;
            titleItemToShow = this.defaultElTitleItem;
        }

        this.onTitleClick(_NULL, titleItemToShow, listItemToShow);
    },

    /**
     * 격자무늬 형태의 menu 항목을 생성하고 mouse event handler 를 연결한다.
     * @function
     */
    generateMatrix: function(matrices) {
        var _menu = this;

        var _cols = this.cols;
        var _rows = this.rows;
        matrices.each(function(matrix) {
            var _options = Trex.MarkupTemplate.splitList(_rows, _cols, matrix.options);
            matrix['items'] = Trex.MarkupTemplate.get('menu.items').evaluate(_options);
        });

        var _elInner = Trex.MarkupTemplate.get('menu.matrix').evaluateAsDom({
            'matrices': matrices
        });

        var _elLists = $tom.collectAll(_elInner, 'div.tx-menu-matrix-listset div.tx-menu-matrix-list');
        var _elTitles = $tom.collectAll(_elInner, 'ul.tx-menu-matrix-title li');

        var defaultIndex = function() {
            for (var i = 0, length = matrices.length; i < length; i++) {
                if (matrices[i].defaultshow) {
                    return i;
                }
            }
            return 0;
        }();
        this.defaultElListItem = _elLists[defaultIndex];
        this.defaultElTitleItem = _elTitles[defaultIndex];

        for (var i = 0; i < matrices.length; i++) {
            var _elList = _elLists[i];
            $tx.observe(_elList, "click", _menu.onSelect.bindAsEventListener(_menu));
            $tx.observe(_elList, 'mouseover', _menu.onItemMouseOver.bindAsEventListener(_menu));
            $tx.observe(_elList, 'mouseout', _menu.onItemMouseOut.bindAsEventListener(_menu));

            var _elTitle = _elTitles[i];
            $tx.observe(_elTitle, "click", _menu.onTitleClick.bindAsEventListener(_menu, _elTitle, _elList));
        }
        return _elInner;
    },
    /**
     * menu 의 group title tab 에 대한 event handler를 연결한다.
     * @function
     */
    onTitleClick: function(ev, elTitleItem, elList) {
        if (this.lastElList != elList) {
            $tx.show(elList);
            if (this.lastElList) {
                $tx.hide(this.lastElList);
            }
            this.lastElList = elList;

            if (this.lastElTitleItem) {
                $tx.removeClassName(this.lastElTitleItem, 'tx-selected');
            }
            $tx.addClassName(elTitleItem, 'tx-selected');
            this.lastElTitleItem = elTitleItem;
        }
        if (ev) {
            $tx.stop(ev);
        }
    },
    /**
     * menu 항목에 mouse over 하면 hovered state css class 를 적용한다.
     * @function
     */
    onItemMouseOver: function(ev) {
        var _el = $tx.findElement(ev, 'span');
        if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
            $tx.addClassName(_el, "tx-item-hovered");
        }
        $tx.stop(ev);
    },
    /**
     * menu 항목에 mouse out 하면 hovered state css class 를 해제한다.
     * @function
     */
    onItemMouseOut: function(ev) {
        var _el = $tx.findElement(ev, 'span');
        if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
            $tx.removeClassName(_el, "tx-item-hovered");
        }
        $tx.stop(ev);
    },
    /**
     * menu 의 list item 이 선택되었을 때 command 를 실행한다.
     * @function
     */
    onSelect: function(ev) {
        var _el = $tx.findElement(ev, 'span');
        if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
            this._command(_el.innerText);
            this.hide();
        }
        $tx.stop(ev);
    }
});

Trex.MarkupTemplate.add(
    'menu.colorPallete', [
        '<div class="tx-menu-inner">',
        '<ul class="tx-pallete-text-list"></ul>',
        '<ul class="tx-pallete-thumb-list"></ul>',
        '<p class="tx-pallete-input"><span style="background-color: rgb(7, 3, 3);"></span><input type="text" class="tx-color-value"/><a class="' + Trex._I18N.g('tx-enter', 'tx-enter') + '">@menu.pallete.enter</a></p>',
        '<div class="tx-pallete-buttons">',
        '	<p class="tx-pallete-more"><a class="tx-more-down" href="javascript:;">@menu.pallete.more</a></p>',
        '</div>',
        '<div class="tx-pallete-picker">',
        '	<div class="tx-pallete-pickerbox">',
        '		<div class="tx-chromabar" style="background-color: rgb(255, 0, 0);"></div><div class="tx-huebar"></div>',
        '	</div>',
        '</div>',
        '</div>'
    ].join("")
);

/**
 * Trex.Menu.ColorPallete
 *
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.ColorPallete = Trex.Class.create( /** @lends Trex.Menu.ColorPallete.prototype */ {
    /** @ignore */
    $extend: Trex.Menu,
    /** @ignore */
    $mixins: [
        Trex.I.ColorPallete
    ],
    /**
     * menu를 생성한다.
     * @function
     */
    generate: function() {
        var _config = this.config;

        var _elMenu = this.elMenu;
        Trex.MarkupTemplate.get("menu.colorPallete").evaluateToDom({}, _elMenu);

        if (_config.colorInputHidden) {
            $(_elMenu).find('.tx-pallete-input').hide();
        }

        var _transCfg = _config.thumbs.transparent;
        _config.thumbs.transparent = Object.extend(_config.thumbs.transparent, {
            image: TrexConfig.getIconPath(_transCfg.image),
            thumb: TrexConfig.getIconPath(_transCfg.thumb),
            thumbImage: TrexConfig.getIconPath(_transCfg.thumbImage)
        });

        if (!this.hookEvent) {
            throw new Error("[Exception]Trex.Menu.ColorPallete : not implement function(hookEvent)");
        }
        this.hookEvent(_config);

        if (this.generateHandler) {
            this.generateHandler(_config);
        }

        this.bindEvents();
    },
    /**
     * menu 의 list item(color) 이 선택되었을 때 command 를 실행한다.
     * @function
     */
    onSelect: function() {
        var _args = $A(arguments);
        var _ev = _args.shift();
        this._command.apply(this, _args);
        this.remainColor(_args);
        this.hide();
        if(_ev) $tx.stop(_ev);
    },
    /**
     * menu 의 list item(color) 이 선택되었을 때 선택 한 color value 를 input box에 남긴다.
     * this.onSelect function 에서 호출한다.
     * @function
     */
    remainColor: function(color) {
        if (color) {
            this.setColorValueAtInputbox(color);
        }
    },
    bindEvents: function() {
        var self = this;
        $tx.observe(this.elMore, 'click', function(ev) {
            self.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, {
                detail: {
                    menu: self
                }
            });
        });
    }
});

$tx.msie && Trex.module("add menu layer shield for IE flash object", function(editor, toolbar, sidebar, canvas /*, config*/ ) {

    /**
     * IE에서 object의 wmode=window에 대응하여 iframe을 메뉴 레이어 하단에 삽입한다.
     */
    Trex.MarkupTemplate.add(
        'menu.shield', [
            '<div class="tx-menu-back" style="overflow:hidden;position:absolute;border:0;">',
            '<iframe src="about:blank" width="100%" height="100%" frameborder="0"></iframe>',
            '</div>'
        ].join("")
    );

    /**
     * 각 메뉴 레이어에 추가되는 요소
     */
    var MenuShieldEntry = Trex.Class.create({
        initialize: function(id, menuEl) {
            this.id = id;
            this.menuEl = menuEl;
            this.shieldEl = Trex.MarkupTemplate.get('menu.shield').evaluateAsDom({});
        },
        show: function() {
            this.update();
            $tom.insertAt(this.shieldEl, this.menuEl);
            $tx.show(this.shieldEl);
        },
        hide: function() {
            $tx.hide(this.shieldEl);
            $tom.remove(this.shieldEl);
        },
        update: function() {
            var style = {
                "width": this.menuEl.offsetWidth.toPx(),
                "height": this.menuEl.offsetHeight.toPx(),
                "left": $tx.getStyle(this.menuEl, 'left'),
                "top": $tx.getStyle(this.menuEl, 'top')
            };
            $tx.setStyle(this.shieldEl, style);
        },
        destroy: function() {
            this.id = _NULL;
            this.menuEl = _NULL;
            this.shieldEl = _NULL;
        }
    });

    /**
     * 레이어 추가/삭제/갱신을 위한 컨트롤러
     */
    var MenuShield = Trex.Class.create({
        initialize: function() {
            this.entry = {};
        },
        show: function(id, menu) {
            var trg = this.entry[id];
            if (!trg) {
                // console.log('show', id, this.entry);
                var entry = new MenuShieldEntry(id, menu);
                this.entry[id] = trg = entry;
            }
            trg.show();
        },
        hide: function(id) {
            var trg = this.entry[id];
            if (trg) {
                // console.log('hide', id, this.entry);
                trg.hide();
                trg.destroy();
                delete this.entry[id];
            }
        },
        updateAll: function() {
            var cache = this.entry;
            setTimeout(function() {
                for (var p in cache) {
                    if (cache.hasOwnProperty(p)) {
                        cache[p].update();
                    }
                }
            }, 1);
        }
    });

    var shield = new MenuShield();

    function getMenuId(menu) {
        var id;
        try {
            if (menu.config.id) {
                id = menu.config.id + menu.config.initializedId;
            } else {
                id = menu.config.el.className;
            }
        } catch (e) {
            id = 'unknown';
        }
        return id;
    }

    toolbar.observeJob(Trex.Ev.__MENU_LAYER_SHOW, function(ev) {
        var menu = ev.detail.menu;
        shield.show(getMenuId(menu), menu.elMenu);
    });

    toolbar.observeJob(Trex.Ev.__MENU_LAYER_HIDE, function(ev) {
        var menu = ev.detail.menu;
        shield.hide(getMenuId(menu));
    });

    toolbar.observeJob(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, function(ev) {
        shield.updateAll();
    });
});

/**
 * @fileoverview
 * DaumEitor의 Entrypoint역할을 하는 source로 Trex.Editor, Editor 를 포함
 */

/**
 * 실제 Editor Implementation, 하지만 Editor 생성 시에는 Class Editor를 사용한다
 *
 * {@link Editor}
 * @class
 * @param {Object} config
 */
Trex.Editor = Trex.Class.create( /** @lends Trex.Editor.prototype */ {
    /** @ignore */
    $mixins: [Trex.I.JobObservable, Trex.I.KeyObservable],
    toolbar: _NULL,
    sidebar: _NULL,
    canvas: _NULL,
    config: _NULL,
    initialConfig: _NULL,
    initialize: function(config) {
        this.initialConfig = config;
        var _editor = this,
            _config = this.config = TrexConfig.setup(config);
        var _canvas = this.canvas = new Trex.Canvas(_editor, _config);
        var _toolbar = this.toolbar = new Trex.Toolbar(_editor, _config);
        var _sidebar = this.sidebar = new Trex.Sidebar(_editor, _config);
        Trex.invokeInstallation(_editor, _toolbar, _sidebar, _canvas, _config);

        /* common key event */
        var _evConfig = _config.events;
        var _keyDownHandler = function(ev) {
            if (_evConfig.useHotKey) {
                _editor.fireKeys(ev);
            }
        };
        $tx.observe(_DOC, "keydown", _keyDownHandler.bindAsEventListener(this), _FALSE);
        _editor.observeJob(Trex.Ev.__IFRAME_LOADING_TIME, function(sec) {
            //try{console.log('에디터 로딩시간 :'  + sec + 's');}catch(e){}
        });
        _canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
            //for hanmail iframe load log.
            var iframeLoadCompleteTime = new Date().getTime();
            var secTime = Math.round((iframeLoadCompleteTime - Editor.initStartTime) / 100) / 10;
            _editor.fireJobs(Trex.Ev.__IFRAME_LOADING_TIME, secTime); //TODO unresolved

            var _initializedId = _editor.getInitializedId();
            var _elLoading = $tx("tx_loading" + _initializedId);
            if (!_elLoading) {
                return;
            }
            if (_canvas.mode != Trex.Canvas.__WYSIWYG_MODE) {
                _canvas.fireJobs(Trex.Ev.__CANVAS_MODE_INITIALIZE, Trex.Canvas.__WYSIWYG_MODE, _canvas.mode);
            }

            /**
             * Chrome , IE 11 이미지 선택
             */
            if ($tx.chrome || ($tx.msie && $tx.msie_ver == 11)) {
                _editor._imageResizeCtrl = new Trex.KEditor.ImageResizeCtrl(_editor, _canvas);
            }

            $tx.hide(_elLoading);
            if (config.deferred) config.deferred.resolve(_editor);
        });
        /**
         * 붙여넣기 event observe
         */
        _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_PASTE_CUSTOM_KEY, function(e) {
            if (_editor.kEditor) Trex.KEditor.eventPaste(_editor.kEditor, e, false);
        });
        _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_PASTE_CUSTOM, function(e) {
            if (_editor.kEditor) Trex.KEditor.eventPaste(_editor.kEditor, e, true);
        });
        /**
         * Drop Event
         */
        _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DROP, function(e) {
            if (_editor.kEditor && _editor.kEditor._eventDrop) _editor.kEditor._eventDrop(e);
        });
        
        Trex.invokeRegisters(_editor, _toolbar, _sidebar, _canvas, _config);
        Trex.invokeModules(_editor, _toolbar, _sidebar, _canvas, _config);

        /**
         * JRE 체크
         */
        if(window.ImageUploader && window.ImageUploader.checkJRE){
            var _icon_jre = $('#tx_applet' + _config.initializedId||'');
            _icon_jre.on('click', function(){
                if(ImageUploader && ImageUploader.installJRE){
                    if(confirm(Trex._I18N.g('jre_win32_install', 'Plug-In을 설치하시면 MS Office(엑셀, 파워포인트, 워드)와의 호환성이 향상됩니다.'
                    + '\n\n- 엑셀 표 붙여넣기 향상(html, image, table 옵션)'
                    + '\n- Text+Image 붙여넣기'
                    + '\n\n설치하시겠습니까?'
                  ))){
                        ImageUploader.installJRE();
                    }
                }
            });
            ImageUploader.checkJRE($).then(function(flag){
                _icon_jre.parent()[flag?'hide':'show']();
            });
        }

        this.cleanupBtn = $('#tx_cleanup' + _config.initializedId||'').closest('li');

        /**
         * Canvas JPEG Qaulity 지원 체크
         */
        try{
            var _c = $('<canvas></canvas>').appendTo($(document.body));
            try{
                _c[0].toDataURL('image/jpeg', 0);
                Trex.Image._SUPPORT_JPEG_QUALITY = true;
            }catch(E){
                Trex.Image._SUPPORT_JPEG_QUALITY = false;
            }
            _c.remove();
        }catch(e){
            Trex.Image._SUPPORT_JPEG_QUALITY = false;
        }
        
        /**
         * 하단 Editor, HTML, Preview tab
         */
        var bottomTab = $('#tx_bottom_tab' + _config.initializedId||'');
        var _preview = $('#tx_preview_wrapper' + _config.initializedId||'');
        var _container = $('#tx_trex_container' + _config.initializedId||'');
        var _preview_iframe = $('#tx_preview' + _config.initializedId||'')[0];
        var _preview_doc = null;
        if(_preview_iframe){
            _preview_doc = _preview_iframe.contentWindow.document;
        }
        this.initPreviewIframe = function(){
            if(_preview_doc){
                _preview_doc.open();
                _preview_doc.write(_config.previewInitHTML?_config.previewInitHTML():'<html><head></head><body></body></html>');
                _preview_doc.close();
            }
        }
        function clearPreviewIframe(){
            if(_preview.is(':visible')) {
                try{
                    _preview_doc.body.innerHTML = '';
                }catch(e){}
                _preview.hide();
            }
        }
        if(bottomTab.length > 0 && bottomTab[0].style.display != 'none'){
            $('.tx-bottom-tab-bar .editor', bottomTab).on('click', function(){
                clearPreviewIframe();
                if(!_container.is(':visible')) _container.show();
                $('.tx-bottom-tab-bar .tx-bottom-tab', bottomTab).removeClass('selected');
                $(this).addClass('selected');
                if(_canvas.mode != 'html') _canvas.changeMode('html');
            });
            $('.tx-bottom-tab-bar .html', bottomTab).on('click', function(){
                clearPreviewIframe();
                if(!_container.is(':visible')) _container.show();
                $('.tx-bottom-tab-bar .tx-bottom-tab', bottomTab).removeClass('selected');
                $(this).addClass('selected');
                if(_canvas.mode != 'source') _canvas.changeMode('source');                
            });
            $('.tx-bottom-tab-bar .preview', bottomTab).on('click', function(){
                $('.tx-bottom-tab-bar .tx-bottom-tab', bottomTab).removeClass('selected');
                $(this).addClass('selected');
                if(_canvas.mode != 'html') _canvas.changeMode('html');
                if(_container.is(':visible')) _container.hide();
                if(!_preview.is(':visible')) {                    
                    _preview.show();
                    _preview_doc.body.innerHTML = _config.previewBodyHTML();
                }
            });
        }
    },
    showCleanupBtn:function(flag){
        this.cleanupBtn[flag===false?'hide':'show']();
    },
    setTranslate:function(translateFn){
        this.canvas.translateFn = translateFn;
        if(this.canvas.translateFn) $('.tx-toolbar-boundary ul.tx-group-translate', this.toolbar.el).show();
        else $('.tx-toolbar-boundary ul.tx-group-translate', this.toolbar.el).hide();
    },
    /**
     * Get toolbar instance
     * @see Trex.Toolbar
     */
    getToolbar: function() {
        return this.toolbar;
    },
    /**
     * Get sidebar instance
     * @see Trex.Sidebar
     */
    getSidebar: function() {
        return this.sidebar;
    },
    /**
     * Get canvas instance
     * @see Trex.Canvas
     */
    getCanvas: function() {
        return this.canvas;
    },
    getUsedWebfont: function() {
        return this.canvas.getUsedWebfont();
    },
    /**
     * Get config instance
     */
    getConfig: function() {
        return this.config;
    },
    getInitialConfig: function() {
        return this.initialConfig;
    },
    getParam: function(name) {
        var _params = {},
            _config = this.config;
        _config.params.each(function(name) {
            if (_config[name]) {
                _params[name] = _config[name];
            }
        });
        return _params[name];
    },
    getWrapper: function() {
        if (!this.initialConfig.wrapper) {
            throw new Error('`wrapper` config variable should be provided');
        }
        return $must(this.initialConfig.wrapper);
    },
    getInitializedId: function() {
        return this.initialConfig.initializedId || "";
    },
    saveEditor: function() {
        this.setDisableUnloadHandler();
        this.getSaver().submit();
    },
    loadEditor: function(data) {
        this.getSaver().load(data);
    },
    /**
     * Editor에서 작성된 저장하기 위해 parsing된 글의 내용을  가져온다.
     * @see Trex.Canvas#getContent
     */
    getContent: function() {
        return this.getSaver().getContent();
    },
    /**
     * Editor에 첨부된 첨부데이터 리스트를 가져온다.
     * * @see Trex.Sidebar#getAttachments
     */
    getAttachments: function(type, all) {
        return this.getSaver().getAttachments(type, all);
    },
    /**
     * Editor에 삽입된 Embed데이터 리스트를 가져온다.
     * * @see Trex.Sidebar#getEmbeddedData
     */
    getEmbeddedData: function(type) {
        return this.getSaver().getEmbeddedData(type);
    },
    /**
     * Editor에 첨부된 정보첨부 리스트를 가져온다.
     * * @see Trex.Sidebar#getResults
     */
    getResults: function(type) {
        return this.getSaver().getResults(type);
    },
    /**
     * autosaver의 현재 사용중인 key를 가져온다.
     * * @see Trex.Autosaver#getCurSeq
     */
    getAutosaveSeq: function() {
        return (this.getAutoSaver && this.getAutoSaver()) ? this.getAutoSaver().getCurSeq() : "0";
    },
    getImagePasteLayer:function(){
        if(!this.imagePasteLayer){
            this.imagePasteLayer = new Trex.Image.ImageInfo(this, this.toolbar, this.canvas, this.config, "paste");
        }
        return this.imagePasteLayer;
    }
});
// Binds helper functions for Editor
(function() {
    /**
     * Editor
     *
     * @example
     *  new Editor({
     *  	txService: 'sampleService',
     *  	txHost: 'sample.daum.net',
     *  	txPath: 'sampleService',
     *  	initializedId: 'stringValue',
     *  	form: 'tx_editor_form'+"$!initializedId"
     *  });
     *
     * @extends Trex.Editor
     * @class
     * @param {Object} config
     */
    _WIN.Editor = Trex.Class.create({
        /** @ignore */
        $const: {
            __ACTIVE: _FALSE,
            __PANEL_LOADED: _FALSE,
            __EDITOR_LOADED: _FALSE,
            __MULTI_LIST: [],
            __SELECTED_INDEX: 0
        },
        _initEditor: function(_editor, config) {
            Editor.__EDITOR_LOADED = _FALSE;
            Editor.__PANEL_LOADED = _FALSE;
            _editor = new Trex.Editor(config);
            var _initializedId = _editor.getInitializedId();
            if (_initializedId != _NULL) {
                var idx = _initializedId == "" ? 0 : _initializedId;
                Editor.__MULTI_LIST[idx] = _editor;
                Editor.__SELECTED_INDEX = idx;
            }
            Object.extend(Editor, _editor);
            Editor.__EDITOR_LOADED = _TRUE;
            Editor.__ACTIVE = _TRUE;
        },
        initialize: function(config) {
            //for hanmail iframe load log.
            if (Trex.hmailLogging) {
                Trex.hmailLogging(config);
            }
            Editor.initStartTime = new Date().getTime();

            var _editor = null;

            if (_WIN['DEBUG']) {
                this._initEditor(_editor, config);
            } else {
                try {
                    this._initEditor(_editor, config);
                } catch (e) {
                    if (_editor) {
                        _editor.fireJobs(Trex.Ev.__RUNTIME_EXCEPTION, e);
                    } else {
                        throw 'failed to initialize editor. caused by ' + e;
                    }
                    throw e;
                }
            }
        }
    });
    /**
     * 글을 수정할 때 저장된 글을 불러온다.
     * @param {Object} data - 에디트에 로드할 내용/첨부파일 값
     * @example
     *  Editor.modify({
     *  	content:'&lt;p&gt;content example&lt;/p&gt;' or $tx('tx_content')
     *  	attachments: [
     *  		{attacher: 'image',
     *				data: {
     *					thumburl: "http://cfile163.uf.daum.net/P150x100/0126A20248BFAFF72D2229",
     *					imageurl: "http://cfile163.uf.daum.net/image/0126A20248BFAFF72D2229",
     *					originalurl: "http://cfile163.uf.daum.net/original/0126A20248BFAFF72D2229",
     *					exifurl: "http://cfile163.uf.daum.net/info/0126A20248BFAFF72D2229",
     *					attachurl: "http://cfile163.uf.daum.net/attach/0126A20248BFAFF72D2229",
     *					filename: "Tree.jpg",
     *					filesize: "155833"
     *				}
     *			}]
     *  });
     */
    Editor.modify = function(data) {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            if (this.loadEditor) {
                this.loadEditor(data);
            }
        } else {
            setTimeout(this.modify.bind(this, data), 10);
        }
    };
    /**
     * Editor 생성 후 자동저장된 Content를 불러올 경우 사용한다.
     * @param {Object} data
     * @example
     *  Editor.restore(
     *  	{content: 'string',
     *  	attachments: [{Object}]});
     */
    Editor.restore = function(data) {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            if (this.getAutoSaver && this.getAutoSaver()) {
                this.getAutoSaver().load(data);
            }
        } else {
            setTimeout(this.restore.bind(this, data), 10);
        }
    };
    /**
     * 글 저장시 사용한다.
     * @example
     *  &lt;a onclick="Editor.save();return _FALSE;" href="#"&gt;save&lt;/a&gt;
     */
    Editor.save = function() {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            if (this.saveEditor) {
                this.saveEditor();
            }
        } else {
            setTimeout(this.saveEditor.bind(this), 10);
        }
        return _FALSE;
    };
    /**
     * Canvas의 최근 focus가 있던 영역에  focus를 준다.
     * 예를들어, 이미지를 첨부하는 팝업창에서 작업을 완료 후 팝업창을 닫고 에디터에 최근의 focus를 준다.
     */
    Editor.focus = function() {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            var _canvas = this.getCanvas();
            if (_canvas) {
                _canvas.focus();
            }
        } else {
            setTimeout(this.focus.bind(this), 10);
        }
        return _FALSE;
    };
    /**
     * Canvas의 맨 위에 focus를 준다.
     * @see Canvas#focusOnTop
     */
    Editor.focusOnTop = function() {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            var _canvas = this.getCanvas();
            if (_canvas) {
                _canvas.focusOnTop();
            }
        } else {
            setTimeout(this.focusOnTop.bind(this), 10);
        }
        return _FALSE;
    };

    /**
     * Canvas의 맨 아래에 focus를 준다.
     * @see Canvas#focusOnBottom
     */
    Editor.focusOnBottom = function() {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            var _canvas = this.getCanvas();
            if (_canvas) {
                _canvas.focusOnBottom();
            }
        } else {
            setTimeout(this.focusOnBottom.bind(this), 10);
        }
        return _FALSE;
    };
    /**
     * Editor가 있는 page를 나갈 경우 beforeunload eventlistener를 실행 시키지 도록 설정한다.
     * 예를들면, Editor에서 글을 작성 중에 새로고침했을 경우 경고창을 안뜨게 한다.
     */
    Editor.permitUnload = function() {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            this.setDisableUnloadHandler();
        } else {
            setTimeout(this.permitUnload.bind(this), 500);
        }
    };
    /**
     * Editor와 Iframe이 정상적으로 생성 된후 argument로 지정된 function을 실행 시킨다.
     * @param {Function} fn
     * @example
     * 	Editor.onPanelLoadComplete(function(){
     * 		Editor.focus();
     * 	});
     */
    Editor.onPanelLoadComplete = function(fn) {
        if (Editor.__PANEL_LOADED == _TRUE && Editor.__EDITOR_LOADED == _TRUE) {
            if (fn) {
                fn();
            }
        } else {
            setTimeout(Editor.onPanelLoadComplete.bind(Editor, fn), 500);
        }
    };
    /**
     * 동일한 Page에 Editor가 여러개 생성됬을 경우, 다른 Editor를 지정한다.
     * @param {Object} toIndex
     */
    Editor.switchEditor = function(toIndex) {
        Editor.__SELECTED_INDEX = toIndex;
        Object.extend(Editor, Editor.__MULTI_LIST[toIndex]);
    };
    /* 에디터가 여러개 있을 때 async로 불러오는 모듈에서 호출하는 에디터를 찾기 위함. */
    Editor.editorForAsyncLoad = Editor;
    /* 에디터가 여러개 있을 때 모든 에디터에 적용하기 위함 */
    Editor.forEachEditor = function(fn) {
        var indexName, list = Editor.__MULTI_LIST;
        var removeItem = [];
        for (indexName in list) {
            if (list.hasOwnProperty(indexName)) {
                /* Editor 가 없는 경우 체크 */
                try {
                    if ($('#tx_trex_container' + list[indexName].kEditor.eInstanceId).length == 0) {
                        removeItem.push(indexName);
                        continue;
                    }
                } catch (e) {
                    continue;
                }
                fn(list[indexName]);
            }
        }
        for (var i = 0; i < removeItem.length; i++) {
            delete list[removeItem[i]];
        }
    };
    Editor.isValidEditor = function(instanceid) {
        try {
            var list = Editor.__MULTI_LIST;
            var ed = list[instanceid];
            if (!ed) return false;
            if ($('#tx_trex_container' + ed.kEditor.eInstanceId).length == 0) {
                delete list[instanceid];
                return false;
            }
        } catch (e) {
            return false;
        }
        return true;
    };
    /**
     * focus on form
     * @param {String} name - focus를 줄 form의 name 속성 값
     * @example
     * 	Editor.focusOnForm("tx_article_title");
     */
    Editor.focusOnForm = function(name) {
        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            _WIN.focus();
            var _form = Editor.getForm();
            if (_form.getElementByName(name)) {
                _form.getElementByName(name).focus();
            }
        } else {
            setTimeout(Editor.focusOnForm.bind(Editor, name), 500);
        }
        return _FALSE;
    };
    /**
     * 파일함에서 export된 데이터를 에디터에 삽입한다. attachment만 삽입된다.
     * @param {Object} data - 에디트에 로드할 내용/첨부파일 값
     * @example
     *  Editor.fromHdrive(
    				[{attacher: 'image',
    	 *				data: {
    	 *					thumburl: "http://cfile163.uf.daum.net/P150x100/0126A20248BFAFF72D2229",
    	 *					imageurl: "http://cfile163.uf.daum.net/image/0126A20248BFAFF72D2229",
    	 *					originalurl: "http://cfile163.uf.daum.net/original/0126A20248BFAFF72D2229",
    	 *					exifurl: "http://cfile163.uf.daum.net/info/0126A20248BFAFF72D2229",
    	 *					attachurl: "http://cfile163.uf.daum.net/attach/0126A20248BFAFF72D2229",
    	 *					filename: "Tree.jpg",
    	 *					filesize: "155833"
    	 *				}
    	 *			}]
     */
    Editor.fromHdrive = function(data) {
        var attachments = [];
        for (var i = 0; i < data.length; i++) {
            attachments.push(data[i]);
        }
        var modifyData = {
            content: "",
            attachments: attachments
        };

        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            if (this.loadEditor) {
                this.loadEditor(modifyData);
                var _entries = Editor.getAttachBox().datalist;
                for (var j = 0; j < _entries.length; j++) {
                    _entries[j].execAppend();
                }
            }
        } else {
            setTimeout(this.fromHdrive.bind(this, data), 10);
        }
    };
    Editor.refreshSize = function() {
        this.canvas.fireJobs(Trex.Ev.__CANVAS_WRAP_WIDTH_CHANGE);
        //TODO.azki height..???
    };
    /**
     * <b>deprecated</b> - use Editor.switchEditor, 동일한 Page에 Editor가 여러개 생성됬을 경우, 다른 Editor를 지정한다.
     * @function
     * @deprecated since ver 1.2, use Editor.switchEditor
     */
    Editor.prototype.switchEditor = Editor.switchEditor;
    /**
     * <b>deprecated</b> - use Editor.focusOnForm, focus on form
     * @function
     * @deprecated since ver 1.2, Use Editor.focusOnForm
     */
    Editor.prototype.focusOnForm = Editor.focusOnForm;
})();


/**
 * @fileoverview
 * - Trex.Toolbar
 */

/**
 * Trex.Toolbar Class
 * @class
 * @param {Object} editor
 * @param {Object} config
 */
Trex.Toolbar = Trex.Class.create( /** @lends Trex.Toolbar.prototype */ {
    /** @ignore */
    $mixins: [
        Trex.I.JobObservable
    ],
    /**
     * Toolbar Dom Element
     */
    el: _NULL,
    /**
     * Tools List
     */
    tools: _NULL,
    initialize: function(editor, rootConfig) {
        this.canvas = editor.getCanvas();

        var _initializedId = rootConfig.initializedId || "";
        this.el = $must("tx_toolbar_basic" + _initializedId, "Trex.Toolbar");
    },
    /**
     * Toolbar의 tool을 비활성화 시킨다.
     * @function
     * @example
     * 	Editor.getToolbar().disableToolbar();
     */
    disableToolbar: function() {
        var _tools = this.tools;
        for (var _name in _tools) {
            if (_tools[_name].button) {
                _tools[_name].button.disable();
            }
        }
    },
    /**
     * 현재 toolbar의 상태를 serializing한다.
     * @function
     * @returns {object}
     */
    serializeToolValues: function() {
        var _tools = this.tools;
        var result = {};
        for (var name in _tools) {
            var _tool = _tools[name];
            result[name] = _tool.button.lastValue;
        }
        return result;
    },
    widgetSeq: 0,
    makeWidget: function(button, menu, handler) {
        var _toolbar = this;
        var _canvas = this.canvas;
        var _dummyToolClass = new(function() {
            this.identity = 'widget' + (++_toolbar.widgetSeq);
            this.wysiwygonly = _TRUE;
            this.menuFoldAuto = _TRUE;
            this.canvas = _canvas;
            this.toolbar = _toolbar;
        })();

        Trex.Tool.prototype.weave.bind(_dummyToolClass)(
            button,
            menu,
            handler
        );

        this.tools[_dummyToolClass.identity] = _dummyToolClass;
        return _dummyToolClass;
    }
});

Trex.install("editor.getTool",
    function(editor, toolbar) {
        var _tools = toolbar.tools = {};

        /**
         * memberOf Editor.prototype
         * @param {Object} name
         */
        editor.getTool = function(name) {
            if (_tools[name] != _NULL) {
                return _tools[name];
            } else if (arguments.length == 0) {
                return _tools;
            } else {
                return _NULL;
            }
        };
    }
);

Trex.register("new tools",
    function(editor, toolbar, sidebar, canvas, config) {
        var _tools = toolbar.tools;

        var _initializedId = config.initializedId || "";
        for (var item in Trex.Tool) {
            var _name = Trex.Tool[item]['__Identity'];
            if (_name) {
                var cfg = TrexConfig.getTool(_name, config);
                cfg.initializedId = _initializedId;
                if (Trex.available(cfg, _name + _initializedId)) {
                    _tools[_name] = new Trex.Tool[item](editor, toolbar, cfg);
                }
            }
        }
        if (!!canvas.config.readonly) {
            toolbar.disableToolbar();
        }
    }
);

Trex.module("bind events with tools",
    function(editor, toolbar, sidebar, canvas) {
        var _tools = toolbar.tools;

        var disableToolOnMobile = function() {
            var isMobile, name, tool, btn;
            isMobile = $tx.ios || $tx.android;
            if (!isMobile) {
                return;
            }
            for (name in _tools) {
                tool = _tools[name];
                if (tool.disabledonmobile) {
                    btn = tool.button;
                    btn.disable();
                }
            }
        };
        disableToolOnMobile();

        var _changeMode = function(from, to) {
            if (from == to) {
                return;
            }
            for (var _name in _tools) {
                var _tool = _tools[_name];
                var _btn = _tool.button;
                if (Trex.Canvas.__WYSIWYG_MODE == to) {
                    _btn.enable();
                } else if (Trex.Canvas.__WYSIWYG_MODE == from) {
                    if (_tool.wysiwygonly) {
                        _btn.disable();
                    } else {
                        _btn.enable();
                    }
                }
            }
            disableToolOnMobile();
        };
        canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, _changeMode);
        canvas.observeJob(Trex.Ev.__CANVAS_MODE_INITIALIZE, _changeMode);

        var _releaseTools = function(identity) {
            for (var _name in _tools) {
                var _tool = _tools[_name];
                if (identity != _tool.identity) {
                    if (_tool.button) {
                        _tool.button.release();
                        _tool.button.decreaseZindex();
                    }
                    if (_tool.menu && _tool.menuFoldAuto) {
                        _tool.menu.release();
                    }
                }
            }
        };
        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, _releaseTools);
        canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, _releaseTools);
        canvas.observeJob(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, _releaseTools);

        toolbar.observeJob(Trex.Ev.__TOOL_CLICK, _releaseTools);

        canvas.observeKey({ // Esc
            ctrlKey: _FALSE,
            altKey: _FALSE,
            shiftKey: _FALSE,
            keyCode: 27
        }, _releaseTools);

        editor.observeKey({ // Esc
            ctrlKey: _FALSE,
            altKey: _FALSE,
            shiftKey: _FALSE,
            keyCode: 27
        }, _releaseTools);

        $tx.observe(_DOC, 'click',
            function(e) {
                var _el = $tx.element(e);
                var _class = ['tx-sidebar', 'tx-toolbar-basic', 'tx-toolbar-advanced',
                    'tx-sidebar-boundary', 'tx-toolbar-boundary', 'tx-toolbar-boundary'
                ];
                if (Trex.Util.getMatchedClassName(_el, _class)) {
                    _releaseTools("-");
                }
            }, _FALSE);

        var _shouldCloseMenus = function() {
            editor.fireJobs(Trex.Ev.__SHOULD_CLOSE_MENUS);
        };
        toolbar.observeJob(Trex.Ev.__TOOL_CLICK, _shouldCloseMenus);
    }
);

/**
 * Tool 클래스의 추상 부모클래스로 각각의 tool들은 이 클래스를 상속받아야 하고,
 * 'oninitialized' 함수를 구현해야한다.
 *
 * @abstract
 * @class
 * @param {Object} editor
 * @param {Object} toolbar
 * @param {Object} config
 *
 * @example
 *	Trex.Tool.Example = Trex.Class.create({
 *		$const: {
 *			__Identity: 'example'
 *		},
 *		$extend: Trex.Tool,
 *		oninitialized: function(config) {
 *			var _tool = this;
 *
 *			this.weave.bind(this)(
 *				new Trex.Button(this.buttonCfg),
 *				new Trex.Menu(this.menuCfg),
 *				function(data) {
 *					//TODO
 *				}
 *			);
 *		}
 *	});
 */
Trex.Tool = Trex.Class.draft( /** @lends Trex.Tool.prototype */ {
    /**
     * tool identifier. 유일해야한다.
     * @private
     */
    identity: _NULL,
    /**
     * button 객체
     */
    button: _NULL,
    /**
     * menu 객체
     */
    menu: _NULL,
    initialize: function(editor, toolbar, config) {
        if (!this.constructor.__Identity) {
            throw new Error("[Exception]Trex.Tool : not implement const(__Identity)");
        }
        this.identity = this.constructor.__Identity;

        if (!editor) {
            throw new Error("[Exception]Trex.Tool : not exist argument(editor)");
        }
        /**
         * editor 객체
         * @private
         */
        this.editor = editor;
        /**
         * toolbar 객체
         * @private
         */
        this.toolbar = toolbar;
        /**
         * canvas 객체
         * @private
         */
        this.canvas = editor.getCanvas();
        /**
         * 해당 tool 설정값
         * @private
         */
        this.config = config;
        this.wysiwygonly = ((config.wysiwygonly != _NULL) ? config.wysiwygonly : _TRUE);
        this.menuFoldAuto = ((config.menuFoldAuto != _NULL) ? config.menuFoldAuto : _TRUE);
        if (config.disabledonmobile != _NULL) {
            this.disabledonmobile = config.disabledonmobile;
        }

        /**
         * 버튼을 생성할 때 필요한 설정값
         * @private
         */
        this.buttonCfg = TrexConfig.merge({
            id: "tx_" + this.identity
        }, config);

        /**
         * 메뉴를 생성할 때 필요한 설정값
         * @private
         */
        this.menuCfg = TrexConfig.merge({
            id: "tx_" + this.identity + "_menu"
        }, config);

        this.oninitialized.bind(this)(config);
    },
    /**
     * tool 객체를 초기화하는 마지막 단계에서 호출되는 함수로,
     * tool 클래스를 상속받는 tool에서 반드시 구현해야 한다.
     *
     * @abstract
     * @private
     * @function
     */
    oninitialized: function() {
        throw new Error("[Exception]Trex.Tool : not implements function(oninitialized)");
    },
    /**
     * 보통 tool은 버튼과 메뉴로 구성되는데, 이 함수에서 그 둘 사이의 연결을 해준다.<br/>
     * menu가 없으면 버튼을 클릭할 때 execHandler가 실행되고,
     * menu가 있으면 버튼을 클릭할 때 menu가 보이며,
     * menu에서 특정 값을 선택하면 그 값을 가지고 execHandler가 실행된다.
     *
     * @function
     * @private
     * @param {Object} button - 버튼 객체
     * @param {Object} menu - 메뉴 객체 optional
     * @param {Function} execHandler
     * @param {Function} initHandler - optional
     *
     * @example
     *	this.weave.bind(this)(
     *		new Trex.Button(this.buttonCfg),
     *		new Trex.Menu(this.menuCfg),
     *		function(data) {
     *			//TODO
     *		});
     *	}
     */
    weave: function(button, menu, execHandler, initHandler) {
        var _tool = this;
        var _identity = this.identity;
        var _toolbar = this.toolbar;
        var _canvas = this.canvas;

        this.button = button;
        button.tool = this;
        var cmd = _NULL;
        if (!menu) {
            button.setCommand(
                cmd = function() {
                    _toolbar.fireJobs(Trex.Ev.__TOOL_CLICK, _identity);
                    return execHandler.apply(_tool, arguments);
                }
            );
        } else {
            this.menu = menu;
            menu.tool = this;

            menu.initHandler = initHandler || function() {};
            menu.cancelHandler = function() { button.setState(_FALSE); };

            menu.setCommand(
                cmd = function() {
                    var args = arguments;
                    var success = execHandler.apply(_tool, args);
                    //handler에서 $stop 을 반환하면 버튼 값을 메뉴에서 선택한 값으로 안바꿈..
                    if (success === $stop) {
                        button.normalState.apply(button, args);
                    } else {
                        button.updateAfterCommand.apply(button, args);
                    }
                    return success;
                }
            );
            button.setCommand(
                function(ev) {
                    _toolbar.fireJobs(Trex.Ev.__TOOL_CLICK, _identity, ev);
                    if (!button.isPushed()) {
                        var _lastvalue = button.getValue();
                        button.increaseZindex();
                        menu.show(_lastvalue);
                    } else {
                        menu.hide();
                        if ($tx.msie) {
                            var _processor = _canvas.getProcessor();
                            if (_processor.restoreRange) {
                                setTimeout(function() {
                                    _processor.restoreRange();
                                }, 0);
                            }
                        }
                    }
                    return _TRUE;
                }
            );

            menu.observeJob(Trex.Ev.__MENU_LAYER_SHOW, function(ev) {
                _toolbar.fireJobs(Trex.Ev.__MENU_LAYER_SHOW, ev);
            });
            menu.observeJob(Trex.Ev.__MENU_LAYER_HIDE, function(ev) {
                _toolbar.fireJobs(Trex.Ev.__MENU_LAYER_HIDE, ev);
            });
            menu.observeJob(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, function(ev) {
                _toolbar.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, ev);
            });
        }
        this.execute = cmd;
    },
    /**
     * 연결된 버튼과 메뉴 레이어와의 관계를 모두 해제한다.
     * 일반적은 경우에는 필요하지 않고 async를 위한 tool에만 weave 구문 상위에 추가한다.
     * @function
     */
    resetWeave: function() {
        if (this.button == null) return;
        this.button.removeHandler();
        this.button.normalState();
        this.button = _NULL;
        this.menu = _NULL;
        this.execute = _NULL;
    },
    /**
     * 활성화 상태를 강제한다.
     * async tool 에서 클릭후 자동 활성화를 위함.
     * @function
     */
    forceActivate: function() {
        if (this.button && this.menu) {
            this.button.pushedState();
            this.button.increaseZindex();
            this.menu.show();
        }
    },
    bindKeyboard: function(keys, execHandler) {
        var toolbar = this.toolbar;
        var identity = this.identity;
        this.canvas.observeKey(keys, function(ev) {
            execHandler(ev);
            toolbar.fireJobs(Trex.Ev.__TOOL_SHORTCUT_KEY, identity);
        });
    }
});

Trex.AsyncTool = Trex.Class.draft( /** @lends Trex.Tool.prototype */ {
    $extend: Trex.Tool,
    oninitialized: function() {
        this.loaded = false;
        throw new Error("[Exception]Trex.AsyncTool : not implements function(oninitialized)");
    },
    onLoadModule: function() {
        var self = this;
        var url = this.config.asyncUrl;
        if (/^(?:\/\/)|(?:\w+:\/\/)/.test(url) === false) {
            url = this.getJSBasePath() + url;
        }
        if (EditorJSLoader.getOption('environment') == 'development') {
            var d = (new Date()).getTime();
            if (url.indexOf('?') === -1) {
                url += '?open&dummy=' + d;
            } else {
                url += '&dummy=' + d;
            }
        } else if (EditorJSLoader._VER) {
            url += (url.indexOf('?') === -1 ? "?open&" : "&") + '_ver=' + EditorJSLoader._VER;
        }
        Editor.editorForAsyncLoad = this.editor;
        EditorJSLoader.asyncLoadModule({
            url: TrexConfig.getUrl(url),
            callback: function() {
                self.loaded = true;
            }
        });
    },
    getJSBasePath: function() {
        var basePath;
        try {
            basePath = EditorJSLoader.getJSBasePath("editor.js");
        } catch (e) {
            basePath = EditorJSLoader.getJSBasePath();
        }
        return basePath;
    }
});

Trex.I.Tool = {};
Trex.I.Tool.QueryStyle = {};
Trex.I.Tool.QueryStyle.Standard = Trex.Mixin.create({
    queryNodeStyle: function(currentNode, cssPropertyName, queryCommandName, matchTagName) {
        return $tx.getStyle(currentNode, cssPropertyName).include(queryCommandName);
    }
});

Trex.I.Tool.QueryStyle.Gecko = Trex.Mixin.create({
    queryNodeStyle: function(currentNode, cssPropertyName, queryCommandName, matchTagName) {
        var tempNode = currentNode;
        var isInclude = _FALSE;
        while (tempNode && !$tom.isBody(tempNode) && !isInclude) {
            if ($tom.isTagName(tempNode, matchTagName)) {
                isInclude = _TRUE;
            } else {
                isInclude = $tx.getStyle(currentNode, cssPropertyName).include(queryCommandName);
            }

            // move to parent
            tempNode = tempNode.parentNode;
        }
        return isInclude;
    }
});


/**
 * @fileoverview
 * Trex.Sidebar, Trex.EntryBox, Trex.Entry, Trex.Actor를 포함하고 있다.
 */

/**
 * 에디터와 외부 component사이의 연동을 하는 class
 *
 * @class
 * @param {object} editor
 * @param {object} config
 */
Trex.Sidebar = Trex.Class.create({
    /** @ignore */
    $const: {
        __REG_ENTRY_ATTR_PAIR_Q: new RegExp("([\\w]+)=\"([^\"]+)\"", "g"),
        __REG_ENTRY_ATTR_PAIR_NQ: new RegExp("([\\w]+)=([\\w]+)", "g")
    },
    /** @ignore */
    $mixins: [
        Trex.I.JobObservable
    ],
    entryboxRegistry: _NULL,
    initialize: function(editor) {
        var _canvas = editor.getCanvas();

        this.entryboxRegistry = {};
        this.getFields = function() {
            var fields = [];
            for (var i in this.entryboxRegistry) {
                var entrybox = this.entryboxRegistry[i];
                fields = fields.concat(entrybox.getFields());
            }
            return fields;
        };

        this.syncSidebar = function() {
            var _content = _canvas.getContent();
            for (var i in this.entryboxRegistry) {
                this.entryboxRegistry[i].syncBox(_content);
            }
        };
        this.emptyEntries = function() {
            for (var i in this.entryboxRegistry) {
                this.entryboxRegistry[i].empty();
            }
        };

        // _canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING, function() {
        // 	try{this.syncSidebar();}catch(e){}
        // }.bind(this));
    }
});


/**
 * Trex.entryBox
 * @class
 */
Trex.EntryBox = Trex.Class.draft({
    /** @ignore */
    $mixins: [
        Trex.I.JobObservable
    ],
    autoSeq: 0,
    datalist: [],
    initialize: function() {
        throw new Error("[Exception]Trex.EntryBox : not implements function(initialize)");
    },
    newSeq: function() {
        return (++this.autoSeq);
    },
    syncSeq: function(existedSeq) {
        this.autoSeq = (existedSeq > this.autoSeq) ? existedSeq : this.autoSeq;
        return existedSeq;
    },
    empty: function() {
        this.fireJobs(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED);
        this.datalist = [];
    },
    append: function(entry) {
        this.datalist.push(entry);
        this.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, entry);
    },
    modify: function(entry) {
        this.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_MODIFIED, entry);
    },
    remove: function(entry) {
        entry.deletedMark = _TRUE;
        this.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, entry);
    },
    syncBox: function(content) {
        this.datalist.each(function(entry) {
            entry.execSync(content);
        });
    },
    getFields: function() {
        var _fields = [];
        this.datalist.each(function(entry) {
            _fields.push(entry.getField());
        });
        return _fields.findAll(function(field) {
            return (field != _NULL);
        });
    },
    getEntries: function(name) {
        if (!name) { //all file
            return this.datalist;
        }
        var _entries = [];
        this.datalist.each(
            function(entry) {
                if (entry.type == name) {
                    _entries.push(entry);
                }
            }
        );
        return _entries;
    }
});

/**
 * Trex.Entry
 * @class
 */
Trex.Entry = Trex.Class.draft({
    /** @ignore */
    $mixins: [
        Trex.I.JobObservable
    ],
    existStage: _FALSE,
    deletedMark: _FALSE,
    initialize: function( /*actor, canvas, entryBox, config*/ ) {
        throw new Error("[Exception]Trex.Entry : not implements function(initialize)");
    },
    setExistStage: function(existStage) {
        this.existStage = existStage;
    },
    execRegister: function() {
        this.register();
        this.entryBox.append(this);
        this.setExistStage(_TRUE);
    },
    execReload: function() {
        if (this.reload) {
            this.reload();
        }
        this.entryBox.append(this);
        this.exchangeHandlerAtReload();
    },
    execRemove: function() {
        this.remove();
        this.entryBox.remove(this);
    },
    execReplace: function(oldReg) {
        this.replace(oldReg);
        this.entryBox.modify(this);
        this.setExistStage(_TRUE);
    },
    execAppend: function() {
        this.register();
        this.setExistStage(_TRUE);
    },
    execSync: function(content) {
        this.setExistStage(this.checkExisted(content));
    },
    checkExisted: function(content) {
        if (this.canvas.isWYSIWYG()) {
            return (content.search(this.regHtml) > -1);
        } else {
            return (content.search(this.regText) > -1);
        }
    },
    getChangedContent: function(content, rex, str, param) {
        var _existStage = _FALSE;
        if (content.search(rex) > -1) {
            _existStage = _TRUE;
            if (this.actor.canResized) {
                content = this.getChangedContentWithAttr(content, rex, str, param);
            } else {
                content = content.replace(rex, str);
            }
        }
        this.setExistStage(_existStage);
        return content;
    },
    getChangedContentFromHtml: function(content) {
        return this.getChangedContent(content, this.regHtml, this.dispText, ["id", "class"]);
    },
    getChangedContentToHtml: function(content) {
        return this.getChangedContent(content, this.regText, this.dispHtml);
    },
    getChangedContentAtSave: function(content) { //Only HTML
        return this.getChangedContent(content, this.regHtml, this.saveHtml, ["id", "class"]);
    },
    getChangedContentAtLoad: function(content) { //Only HTML
        return this.getChangedContent(content, this.regLoad, this.dispHtml);
    },
    getChangedContentWithAttr: function(content, reg, disp, excepts) {
        excepts = excepts || [];
        var _attrMap = Trex.Util.getAllAttributes(disp);

        var _getChangedTag = function(source) {
            var _tag = Trex.Util.getMatchValue(/<([a-z]*)/i, disp, 1);
            var _attr = ["<" + _tag.toLowerCase()];
            var _overMap = Trex.Util.getAllAttributes(source);

            for (var _name in _attrMap) {
                if (["width", "height"].contains(_name)) {
                    if (!_overMap[_name]) {
                        _attr.push(_name + "=\"" + _attrMap[_name] + "\"");
                    }
                } else {
                    _attr.push(_name + "=\"" + _attrMap[_name] + "\"");
                }
            }

            for (var _name in _overMap) {
                if (!excepts.contains(_name)) {
                    if (["width", "height"].contains(_name)) {
                        _attr.push(_name + "=\"" + _overMap[_name] + "\"");
                    } else if (!_attrMap[_name]) {
                        _attr.push(_name + "=\"" + _overMap[_name] + "\"");
                    }
                }
            }
            _attr.push("/>");
            return _attr.join(" ");
        };

        var _orgContent = content;
        var _matchs;
        reg.lastIndex = 0;
        while ((_matchs = reg.exec(_orgContent)) != _NULL) {
            var _textOrg = _matchs[0];
            var _dispTrans = _getChangedTag(_textOrg);
            var _regOrg = _textOrg.getRegExp();
            content = content.replace(new RegExp(_regOrg, "gmi"), _dispTrans);
        }
        return content;
    },
    getField: function() {
        if (!this.field) {
            return _NULL;
        }
        return {
            name: this.field.name,
            value: [this.field.value, this.existStage].join('|')
        };
    },
    exchangeHandlerAtReload: function() {}
});

/**
 * Trex.Actor
 * @class
 */
Trex.Actor = Trex.Class.draft({
    /** @ignore */
    $mixins: [
        Trex.I.JobObservable
    ],
    isDisabled: _FALSE,
    initialize: function( /*config, canvas*/ ) {
        throw new Error("[Exception]Trex.Actor : not implements function(initialize)");
    },
    execAttach: function(data, type) {
        var _entry = this.createEntry(this.getDataForEntry(data), type);
        _entry.execRegister();
        this.canvas.fireJobs('canvas.' + (type || this.constructor.__Identity) + '.added', _entry);
    },
    getDatalist: function() {
        return this.entryBox.getEntries(this.name);
    },
    execReattach: function(data, type) {
        var datalist = this.getDatalist();
        var parsedData = this.getDataForEntry(data);
        if (datalist.length < 1) {
            var _entry = this.createEntry(parsedData, type);
            _entry.execRegister();
        } else {
            var _entry = datalist[0];
            var _oldReg = {
                regHtml: _entry.regHtml,
                regText: _entry.regText
            };
            _entry.setProperties(parsedData);
            _entry.execReplace(_oldReg);
        }
    },
    execReload: function(data, content, type) {
        var _dataForEntry = this.getDataForEntry(data, content);
        if (_dataForEntry) { // FTDUEDTR-1361
            var _entry = this.createEntry(_dataForEntry, type);
            _entry.execReload();
        }
    },
    existEntry: function() {
        var list = this.getDatalist().findAll(function(entry) {
            return entry.deletedMark != _TRUE;
        });
        return list.length !== 0;
    },
    getFirstEntryData: function() {
        var list = this.getDatalist().findAll(function(entry) {
            return entry.deletedMark != _TRUE;
        });
        return ((list.length == 0) ? _NULL : list[0].data);
    }
});


Trex.install("editor.getDocParser",
    function(editor, toolbar, sidebar, canvas, config) {
        var _docparser = new Trex.Docparser(editor, sidebar, config);
        editor.getDocParser = function() {
            return _docparser;
        };
    }
);

Trex.Docparser = Trex.Class.create({
    initialize: function(editor, sidebar, config) {
        this.editor = editor;
        this.sidebar = sidebar;
        this.config = config;
    },
    filters: {},
    /**
     * register contents converting filter
     *
     * 	original = DB에 저장되는 컨텐츠
     * 	html = wysiwyg 모드에서 보이는 컨텐츠
     * 	source = source 모드에서 보이는 컨텐츠
     * 	text = text 모드에서 보이는 컨텐츠
     *
     * @example
     * editor.getDocParser().registerFilter(
    		'filter/converting', {
    			'text@load': function(contents){ // orginal -> text
    				return contents;
    			},
    			'source@load': function(contents){ // orginal -> source
    				return contents;
    			},
    			'html@load': function(contents){ // orginal -> html
    				return contents;
    			},
    			'text4save': function(contents){ // text -> orginal
    				return contents;
    			},
    			'source4save': function(contents){ // source -> orginal
    				return contents;
    			},
    			'html4save': function(contents){ // html -> orginal
    				return contents;
    			},
    			'text2source': function(contents){ // text -> source
    				return contents;
    			},
    			'text2html': function(contents){ // text -> html
    				return contents;
    			},
    			'source2text': function(contents){ // source -> text
    				return contents;
    			},
    			'source2html': function(contents){ // source -> html
    				return contents;
    			},
    			'html2text': function(contents){ // html -> text
    				return contents;
    			},
    			'html2source': function(contents){ // html -> source
    				return contents;
    			}
    		}
    	);
     */
    registerFilter: function(name, filter) {
        this.filters[name] = filter;
    },
    getFilter: function(name) {
        return this.filters[name];
    },
    executeFilters: function(cmd, contents) {
        var filters = this.filters;
        ["before " + cmd, cmd, "after " + cmd].each(function(cmd) {
            var name, filter;
            for (name in filters) {
                if (filters.hasOwnProperty(name)) {
                    filter = filters[name];
                    if (filter[cmd]) {
                        contents = filter[cmd](contents);
                    }
                }
            }
        });
        return contents;
    },
    getContentsAtChangingMode: function(contents, oldMode, newMode) {
        if (oldMode == newMode) {
            return contents;
        }
        contents = contents.trim() || "";
        return this.executeFilters(oldMode.concat("2").concat(newMode), contents);
    },
    convertAtLoad: function(contents, editorMode, inputMode) { // For Display
        /*
         * DB에 저장된 컨텐츠
         *  > original, text
         */
        if (inputMode == 'original') { //original 컨텐츠 변환
            contents = this.executeFilters(editorMode.concat('@load'), contents);
        } else { //그외 모드, 자동저장은 변환없이 저장됨.
            if (editorMode != inputMode) {
                contents = this.executeFilters(inputMode.concat("2").concat(editorMode), contents);
            }
        }
        return contents;
    },
    convertAtSave: function(contents, editorMode, outputMode) { // For Save
        if (outputMode == 'original') { //original 컨텐츠 변환
            contents = this.executeFilters(editorMode.concat('4save'), contents);
        } else { //그외 모드, 자동저장은 변환없이 저장됨.
            if (editorMode != outputMode) {
                contents = this.executeFilters(editorMode.concat("2").concat(outputMode), contents);
            }
        }
        return contents;
    },
    /* 외부에서 참조할 컨텐츠 변환 필터명 시작 */
    text2source: function(contents) {
        return this.executeFilters("text2source", contents);
    },
    text2html: function(contents) {
        if (contents === "") {
            return $tom.EMPTY_PARAGRAPH_HTML;
        }
        return this.executeFilters("text2html", contents);
    },
    source2text: function(contents) {
        return this.executeFilters("source2text", contents);
    },
    source2html: function(contents) {
        if (contents === "") {
            return $tom.EMPTY_PARAGRAPH_HTML;
        }
        return this.executeFilters("source2html", contents);
    },
    html2text: function(contents) {
        return this.executeFilters("html2text", contents);
    },
    html2source: function(contents) {
            return this.executeFilters("html2source", contents);
        }
        /* 외부에서 참조할 컨텐츠 변환 필터명 끝 */
});


Trex.install("editor.getEntryProxy",
    function(editor, toolbar, sidebar, canvas, config) {
        var _entryproxy = new Trex.EntryProxy(editor, sidebar, config);
        editor.getEntryProxy = function() {
            return _entryproxy;
        };
    }
);

Trex.EntryProxy = Trex.Class.create({
    initialize: function(editor, sidebar, config) {
        this.editor = editor;
        this.sidebar = sidebar;
        this.config = config;
    },
    /**
     * For loadEntriesAtRestore, loadEntriesAtModify
     */
    commands: {},
    registerCommand: function(name, command) {
        this.commands[name] = command;
    },
    getcommand: function(name) {
        return this.commands[name];
    },
    executeCommand: function(cmd, data) {
        for (var i in this.commands) {
            var command = this.commands[i];
            if (command[cmd]) {
                command[cmd](data);
            }
        }
    },
    setAttachments: function(attachments, contents) { //NOTE: data format = JSON
        attachments = attachments || [];
        contents = contents || "";

        var _entrybox = this.editor.getAttachBox();
        _entrybox.empty();

        var _actors = this.sidebar.getAttacher();
        attachments.each(function(attachment) {
            try {
                var _actor = _actors[attachment.attacher];
                if (_actor) {
                    _actor.execReload(attachment.data, contents, attachment.type);
                }
            } catch (ignore) {
                // 첨부데이터 일부를 정상적으로 불러오지 못했습니다.
                // try{console.error("첨부데이터 일부를 정상적으로 불러오지 못했습니다:", ignore);}catch(e){}
            }
        });
    },
    getAttachments: function(attachments, all) {
        all = !!all;
        var _attachments = [];
        attachments.each(function(attachment) {
            if (attachment.deletedMark) {
                return;
            }
            if (all || attachment.existStage) {
                _attachments.push({
                    type: attachment.type,
                    attacher: attachment.actor.name,
                    existStage: attachment.existStage,
                    data: Object.extend(attachment.data, {
                            tmpSeq: attachment.dataSeq
                        }) //html mode
                });
            }
        });
        return _attachments;
    }
});


Trex.install("editor.getForm",
    function(editor, toolbar, sidebar, canvas, config) {
        var _formproxy = new Trex.FormProxy(editor, sidebar, config);
        editor.getForm = function() {
            return _formproxy;
        };
    }
);

Trex.FormProxy = Trex.Class.create({
    initialize: function(editor, sidebar, config) {
        this.editor = editor;
        this.sidebar = sidebar;
        this.config = config;

        var _elForm = this.elForm = _DOC.forms[config.form] || _DOC.getElementById(config.form);
        if (!_elForm) {
            throw new Error("[Exception]Trex.Form : not exist element - " + config.form);
        }

        _elForm.onsubmit = function() {
            return _FALSE;
        };
    },
    submit: function() {
        this.elForm.submit();
    },
    createField: function(elField) {
        this.elForm.appendChild(elField);
    },
    getElements: function() {
        return this.elForm.elements;
    },
    getElementByName: function(name) {
        return this.elForm[name];
    },
    getFormField: function() {
        var _formfield = {};

        var _fields = this.getElements();
        var _field;
        for (var i = 0; i < _fields.length; i++) {
            _field = _fields[i];
            if (!["select", "input", "textarea"].contains(_field.tagName.toLowerCase())) {
                continue;
            }
            if (!_field.name && !_field.id) {
                continue;
            }
            if (_field.tagName.toLowerCase() == "select") {
                if (_field.selectedIndex > 0) {
                    _formfield[_field.name] = _field.options[_field.selectedIndex].value;
                }
            } else {
                if (_field.type == "radio" && !_field.checked) {} else if (_field.type == "checkbox" && !_field.checked) {} else {
                    _formfield[_field.name || _field.id] = _field.value;
                }
            }
        }
        return _formfield;
    },
    setFormField: function(formfield) {
        if (!formfield) {
            return;
        }
        var _fields = this.getElements();
        var _field;
        var _value;
        for (var i = 0; i < _fields.length; i++) {
            _field = _fields[i];
            if (!["select", "input", "textarea"].contains(_field.tagName.toLowerCase())) {
                continue;
            }
            if (_field.name === _NULL || _field.name.length === 0) {
                continue;
            }
            if (!formfield[_field.name]) {
                continue;
            }
            _value = formfield[_field.name];
            if (_field.tagName.toLowerCase() == "select") {
                for (var j = 0; j < _field.options.length; j++) {
                    if (_field.options[j].value == _value) {
                        _field.options[j].selected = _TRUE;
                        break;
                    }
                }
            } else {
                if (_field.type == "radio" || _field.type == "checkbox") {
                    if (_field.value == _value) {
                        _field.checked = _TRUE;
                    }
                } else {
                    _field.value = _value;
                }
            }
        }
    }
});

Trex.install("editor.getSaver & editor.getDataAsJSON & editor.setDataByJSON",
    function(editor, toolbar, sidebar, canvas, config) {
        var _saver = new Trex.Save(editor, toolbar, sidebar, canvas, config);
        editor.getSaver = function() {
            return _saver;
        };

        editor.getDataAsJSON = function() {
            var _content = canvas.getContent(); // getContent() of current mode
            var _validator = new Trex.Validator();
            if (!_validator.exists(_content)) {
                return _NULL;
            }
            return {
                'inputmode': canvas.getCurrentPanel().getName(),
                'content': _content,
                'attachments': function() {
                    var _attachments = sidebar.getAttachments(); // all getAttachments()
                    return editor.getEntryProxy().getAttachments(_attachments, _TRUE);
                }(),
                'resultBox': function() {
                    var _resultBox = editor.getResultBox();
                    var datas = [];
                    _resultBox.datalist.each(function(entry) {
                        datas.push(entry.data);
                    });
                    return datas;
                }(),
                'formfield': editor.getForm().getFormField()
            };
        };

        editor.setDataByJSON = function(jsonData) {
            if (!jsonData) {
                return;
            }
            var _editorMode = canvas.mode;
            var _inputMode = jsonData.inputmode || _editorMode;
            if (_inputMode == 'original') { //save
            } else if (_inputMode != _editorMode) {
                canvas.fireJobs(Trex.Ev.__CANVAS_MODE_INITIALIZE, _editorMode, _inputMode);
                canvas.changeMode(_inputMode);
            }

            var _content = jsonData.content;

            if (jsonData.attachments) {
                editor.getEntryProxy().setAttachments(jsonData.attachments, _content);
            }

            if (_content) {
                _content = editor.getDocParser().convertAtLoad(_content, _editorMode, _inputMode); //onlyHTML
                canvas.initContent(_content);
            }

            if (jsonData.resultBox) {
                jsonData.resultBox.each(function(data) {
                    var _actor;
                    _actor = sidebar.searchers[data._meta.type];
                    if (_actor) {
                        _actor.execReload(data, _content);
                    }
                });
            }

            sidebar.syncSidebar(); //sync

            if (jsonData.formfield) {
                editor.getForm().setFormField(jsonData.formfield);
            }
        };
    }
);

Trex.Save = Trex.Class.create({
    editor: _NULL,
    toolbar: _NULL,
    sidebar: _NULL,
    canvas: _NULL,
    config: _NULL,
    form: _NULL,
    initialize: function(editor, toolbar, sidebar, canvas, config) {
        this.editor = editor;
        this.toolbar = toolbar;
        this.sidebar = sidebar;
        this.canvas = canvas;
        this.config = config;
        this.form = editor.getForm();
        this.docparser = editor.getDocParser();
        this.entryproxy = editor.getEntryProxy();
    },
    save: function() {
        try {
            if (typeof validForm == "function") {
                if (!validForm(this.editor)) {
                    return _FALSE;
                }
            }
            if (typeof setForm == "function") {
                if (!setForm(this.editor)) {
                    return _FALSE;
                }
            }
            return _TRUE;
        } catch (e) {
            this.editor.fireJobs(Trex.Ev.__RUNTIME_EXCEPTION, e);
            return _FALSE;
        }
    },
    submit: function() {
        if (this.save()) {
            this.editor.fireJobs(Trex.Ev.__ON_SUBMIT, this.editor);
            if (this.config.save && typeof this.config.save.onSave == "function") {
                var externalSaveHandler = this.config.save.onSave;
                externalSaveHandler();
            } else {
                this.form.submit();
            }
        }
    },
    getContent: function(outputMode) {
        var _canvas = this.canvas;

        //에디터모드, 출력모드
        var _editorMode = _canvas.mode;
        var _outputMode = outputMode || "original";

        var _content = _canvas.getContent(); // getContent() of current mode
        _content = this.docparser.convertAtSave(_content, _editorMode, _outputMode);

        return _content;
    },
    getAttachments: function(type, all) {
        all = all || _FALSE;
        var _attachments = this.sidebar.getAttachments(type); // all getAttachments()
        return this.entryproxy.getAttachments(_attachments, all);
    },
    getEmbeddedData: function(type) {
        return this.sidebar.getEmbeddedData(type);
    },
    getResults: function(type) {
        return this.sidebar.getResults(type);
    },
    /*
    	data = {
    		content: "string",
    		inputmode: "string",
    		attachments: [{
    			attacher: "string",
    			data: {object}
    		}]
    	}
    */
    load: function(jsonData) { //NOTE: data format = JSON
        jsonData = {
            'inputmode': (!jsonData.inputmode || jsonData.inputmode == 'html') ? 'original' : jsonData.inputmode,
            'content': function() {
                var _contentObj = jsonData.content;
                if (typeof _contentObj == "string") {
                    return jsonData.content;
                } else if (_contentObj && _contentObj.nodeType && (_contentObj.nodeType == 1)) {
                    return jsonData.content.value;
                } else {
                    return '';
                }
            }(),
            'attachments': jsonData.attachments
        };
        this.editor.fireJobs(Trex.Ev.__EDITOR_LOAD_DATA_BEGIN, jsonData);
        if (!jsonData) {
            throw new Error("[Exception]Trex.Save : not exist argument(data)");
        }
        if (typeof loadForm == "function") {
            loadForm(this.editor, jsonData);
        }

        try { //#FTDUEDTR-1111
            this.setDataByJSONToEditor(jsonData);
        } catch (error) {
            alert(' - Error: ' + error.message + Trex._I18N.g('setDataByJSONToEditor_error', '\n소스보기 모드로 전환합니다.\n잘못된 HTML이 있는지 확인해주세요.'));
            jsonData.inputmode = Trex.Canvas.__HTML_MODE;
            try {
                this.setDataByJSONToEditor(jsonData);
            } catch (ignore) {}
        }

        if (typeof postLoad == "function") {
            postLoad(this.editor, jsonData);
        }
        this.editor.fireJobs(Trex.Ev.__EDITOR_LOAD_DATA_END);
    },
    setDataByJSONToEditor: function(jsonData) {
        this.editor.setDataByJSON(jsonData);
    },
    makeField: function() {
        var _sidebar = this.sidebar;
        var _form = this.form;

        //NOTE: create field content
        var _content = this.getContent();
        _form.createField(tx.textarea({ name: "tx_content", style: { display: "none" } }, _content));

        //NOTE: create field attach
        var _fields = _sidebar.getFields();
        _fields.each(function(field) {
            _form.createField(tx.input({ type: "hidden", name: field.name, value: field.value }));
        });
    }

});

Trex.module("new Trex.Resizer",
    function(editor, toolbar, sidebar, canvas, config) {
        var _initializedId = config.initializedId || "";
        var cfg = TrexConfig.get("resizer", config);
        var _resizer = _NULL;

        editor.setMinHeight = function(h) {
            return _resizer.setMinHeight(h);
        };
        editor.restoreMinHeight = function() {
            return _resizer.restoreMinHeight();
        };
        if (Trex.available(cfg, "resizer" + _initializedId)) {
            _resizer = new Trex.Resizer(editor, cfg);
        }
    }
);
TrexConfig.add({
    'resizer': {
        minHeight: 200
    }
});
Trex.Resizer = Trex.Class.create({
    $const: {
        __Identity: 'resizer'
    },
    $mixins: [
        Trex.I.JobObservable
    ],
    initialize: function(editor, config) {
        var _presentHeight = 0;
        if (!editor) {
            return;
        }
        this.config = config;

        var _initializedId = editor.getInitializedId();
        var _elBar = this.elBar = $tx("tx_resizer" + _initializedId);
        if (!_elBar) {
            return;
        }
        if ($tx.msie_ver == '5.5') {
            _elBar.setAttribute('align', 'center');
        }

        this.resizeHeightAtService = function(height) { //NOTE: 에디터를 리사이즈하고 나서 실행할 서비스 콜백
            if (typeof resizeHeight == "function") {
                resizeHeight(height);
            }
        };
        this.resizingHeightAtService = function(height) { //NOTE: 에디터를 리사이즈하는 중에 실행할 서비스 콜백 ex) iframe 길이 늘리기
            if (typeof resizingEditorHeight == "function") {
                resizingEditorHeight(height);
            }
        };
        this.minDragHeight = config.minHeight;
        var _wysiwygDoc;
        this.startDrag = function(ev) {
            var _canvas = editor.getCanvas();
            var _panel = _canvas.getCurrentPanel();
            if (_panel == _NULL) {
                return;
            }

            var _position = _panel.getPosition();
            this.panelHeight = _position.height;
            this.dragStartPosY = ev.clientY;
            this.isDragging = _TRUE;
            $tx.observe(_DOC, 'mousemove', this.documentDraggingHandler);
            $tx.observe(_DOC, 'mouseup', this.stopDragHandler);
            if (_panel.getName() == Trex.Canvas.__WYSIWYG_MODE) {
                this.panelTop = _position.y;
                _wysiwygDoc = _panel.getDocument();
                if (_wysiwygDoc == _NULL) {
                    return;
                }
                _canvas.fireJobs('canvas.height.beforechange');
                $tx.observe(_wysiwygDoc, 'mousemove', this.wysiwygDraggingHandler);
                $tx.observe(_wysiwygDoc, 'mouseup', this.stopDragHandler);
            }
            $tx.stop(ev);
        };

        this.stopDrag = function(ev) {
            var _canvas = editor.getCanvas();
            var _panel = _canvas.getCurrentPanel();
            if (_panel == _NULL) {
                return;
            }
            this.isDragging = _FALSE;

            $tx.stopObserving(_DOC, 'mousemove', this.documentDraggingHandler);
            $tx.stopObserving(_DOC, 'mouseup', this.stopDragHandler);
            if (_wysiwygDoc == _NULL) {
                return;
            }
            $tx.stopObserving(_wysiwygDoc, 'mousemove', this.wysiwygDraggingHandler);
            $tx.stopObserving(_wysiwygDoc, 'mouseup', this.stopDragHandler);
            _wysiwygDoc = _NULL;
            this.resizeHeightAtService(_presentHeight);
            _canvas.fireJobs('canvas.height.afterchange');
            $tx.stop(ev);
        };

        this.dragingAtDocument = function(ev) {
            var _canvas = editor.getCanvas();
            if (this.isDragging) {
                var _panel = _canvas.getCurrentPanel();
                if (_panel == _NULL) {
                    return;
                }
                try {
                    var _height = Math.max((this.panelHeight + ev.clientY - this.dragStartPosY), this.minDragHeight.parsePx()).toPx();
                    _panel.setPanelHeight(_height);
                    _presentHeight = _height;
                    _canvas.fireJobs('canvas.height.change', _height);
                    this.resizingHeightAtService(_height);
                } catch (e) {
                    // console.log(e);
                }
            }
            $tx.stop(ev);
        };

        this.dragingAtWysiwyg = function(ev) {
            var _canvas = editor.getCanvas();
            if (this.isDragging) {
                var _panel = _canvas.getCurrentPanel();
                if (_panel == _NULL) {
                    return;
                }
                try {
                    var _scrollTop = _DOC.body.scrollTop || _DOC_EL.scrollTop || _WIN.pageYOffset;
                    var canvasPos = _canvas.getCanvasPos(); // canvas 위치를 조정하지 않아서 높이 잘못 계산한 부분 수정 #FTDUEDTR-1317
                    var _height = Math.max((this.panelHeight + ev.clientY + canvasPos.y - this.dragStartPosY + this.panelTop - _scrollTop), this.minDragHeight.parsePx()).toPx();
                    _panel.setPanelHeight(_height);
                    _canvas.fireJobs('canvas.height.change', _height);
                } catch (e) {
                    // console.log(e);
                }
            }
            $tx.stop(ev);
        };

        this.startDragHandler = this.startDrag.bindAsEventListener(this);
        this.stopDragHandler = this.stopDrag.bindAsEventListener(this);
        this.documentDraggingHandler = this.dragingAtDocument.bindAsEventListener(this);
        this.wysiwygDraggingHandler = this.dragingAtWysiwyg.bindAsEventListener(this);
        this.isDragging = _FALSE;

        $tx.observe(_elBar, 'mousedown', this.startDragHandler);

        var _canvas = editor.getCanvas();
        _canvas.observeJob(Trex.Ev.__CANVAS_FULL_SCREEN_CHANGE, function() {
            $tx.hide(_elBar);
        });

        _canvas.observeJob(Trex.Ev.__CANVAS_NORMAL_SCREEN_CHANGE, function() {
            $tx.show(_elBar);
        });

    },
    setMinHeight: function(height) {
        return this.minDragHeight = height.toPx();
    },
    restoreMinHeight: function() {
        return this.minDragHeight = this.config.minHeight || 200;
    }
});

/*
 알려진 문제들
 -
 덜 중요한 문제들
 - layout에 여러 개의 이미지를 한꺼번에 올린 경우에,  saveHistory 하지 않음
 - table resize 를 한 후에 saveHistory 하지 않음 / modified+마우스클릭 조합일 때, saveHistory를 하는 로직으로 인해 saveHistory가 될 수 있는 경우가 있음, but 완벽하지 않음
 - backspace / delete 든 여러 번 눌렀을 때에 한 번만 saveHistory하고 싶다.
 */

Trex.I.History = {};
Trex.I.History.Standard = {
    getRangeData: function() {
        throw Error("Unimplemented abstract method");
    },
    restoreRange: function(rangeData) {
        throw Error("Unimplemented abstract method");
    }
};

Trex.I.History.Webkit = {
    getRangeData: function() {
        var p = this.canvas.getProcessor(),
            txSel = p.getTxSel(),
            rangeCount = txSel.getSel().rangeCount;
        var start, end;

        if (rangeCount) {
            var range = txSel.getSel().getRangeAt(0);
            var preSelectionRange = range.cloneRange();
            preSelectionRange.selectNodeContents(this.canvas.getCurrentPanel().getDocument().body);
            preSelectionRange.setEnd(range.startContainer, range.startOffset);
            start = preSelectionRange.toString().length;
            end = start + range.toString().length;
        } else {
            start = 0;
            end = 0;
        }

        return {
            start: start,
            end: end
        };
    },
    restoreRange: function(savedSel) {
        var win = this.canvas.getCurrentPanel().getWindow();
        var doc = win.document;
        var containerEl = doc.body;
        var charIndex = 0,
            range = doc.createRange();
        range.setStart(containerEl, 0);
        range.collapse(true);
        var nodeStack = [containerEl],
            node, foundStart = false,
            stop = false;

        while (!stop && (node = nodeStack.pop())) {
            if (node.nodeType == 3) {
                var nextCharIndex = charIndex + node.length;
                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {
                    range.setStart(node, savedSel.start - charIndex);
                    foundStart = true;
                }
                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {
                    range.setEnd(node, savedSel.end - charIndex);
                    stop = true;
                }
                charIndex = nextCharIndex;
            } else {
                var i = node.childNodes.length;
                while (i--) {
                    nodeStack.push(node.childNodes[i]);
                }
            }
        }

        var sel = win.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
};

Trex.I.History.Trident = {
    getRangeData: function() {
        var doc = this.canvas.getCurrentPanel().getDocument();
        var containerEl = doc.body;
        //refactory 필요.
        /*
        try{
            var selectedTextRange = doc.selection.createRange();
        }catch(e){
            return {
                start:0,
                end:0
            }
        }*/
        /**
         * redo시 cursor가 맨처음으로 이동되는 문제가 있어서 변경함.
         * (입력 후 undo를 클릭할때 이미 cursor가 맨처음으로 이동되어있어서 문제가 됨.)
         * 확인 필요.
         */
        var selectedTextRange = null;
        var _last_range = this.canvas._SELECTION_RANGE;
        if (_last_range) selectedTextRange = _last_range;
        else {
            try {
                selectedTextRange = doc.selection.createRange();
            } catch (e) {
                return {
                    start: 0,
                    end: 0
                }
            }
        }
        var preSelectionTextRange = doc.body.createTextRange();
        preSelectionTextRange.moveToElementText(containerEl);
        try {
            preSelectionTextRange.setEndPoint("EndToStart", selectedTextRange);
            var start = preSelectionTextRange.text.length;
            return {
                start: start,
                end: start + selectedTextRange.text.length
            }
        } catch (e) {

        }

        var onepoint = preSelectionTextRange.text.length;
        return {
            start: onepoint,
            end: onepoint
        }
    },
    restoreRange: function(savedSel) {
        var doc = this.canvas.getCurrentPanel().getDocument();
        var containerEl = doc.body;
        var textRange = doc.body.createTextRange();
        textRange.moveToElementText(containerEl);
        textRange.collapse(true);
        textRange.moveEnd("character", savedSel.end);
        textRange.moveStart("character", savedSel.start);
        textRange.select();
    }
};

/**
 * @fileoverview default history class for redo/undo
 *
 * @author iamdanielkim
 */

/**
 * @namespace
 */
(function() {
    function keepMaxLength(list, maxLength) {
        while (list.length >= maxLength) {
            list.shift();
        }
    }

    var MAX_UNDO_COUNT = 10;

    /**
     * @class
     */
    Trex.History = Trex.Class.create({
        $mixins: [
            Trex.I.History.Standard,
            (($tx.msie_nonstd) ? Trex.I.History.Trident : Trex.I.History.Webkit)
        ],
        maxUndoCount: MAX_UNDO_COUNT,
        canvas: _NULL,
        undoMementoList: _NULL,
        redoMementoList: _NULL,
        currentMemento: _NULL,
        contentModified: _FALSE,
        initialize: function(canvas) {
            this.canvas = canvas;
            this.setupHistory();
            this.bindKeyEvent(canvas);
        },
        bindKeyEvent: function(canvas) {
            var self = this;
            canvas.observeJob('canvas.panel.undo', function() {
                self.undoHandler();
            });
            canvas.observeJob('canvas.panel.redo', function() {
                self.redoHandler();
            });
        },
        setupHistory: function() {
            this.initHistory({ content: $tom.EMPTY_PARAGRAPH_HTML, scrollTop: 0 });
        },
        canUndo: function() {
            return this.undoMementoList.length > 0;
        },
        canRedo: function() {
            return this.redoMementoList.length > 0;
        },
        setCurrentMemento: function(memento) {
            this.currentMemento = memento;
        },
        undoHandler: function() {
            var self = this;
            self.saveHistoryIfEdited();
            if (!self.canUndo()) {
                return;
            }

            var undoMemento = self.undoMementoList.pop();
            undoMemento.undo();
            self.redoMementoList.push(undoMemento);

            self.setCurrentMemento(undoMemento);
        },
        redoHandler: function() {
            var self = this;
            self.saveHistoryIfEdited();
            if (!self.canRedo()) {
                return;
            }

            var redoMemento = self.redoMementoList.pop();
            redoMemento.redo();
            self.undoMementoList.push(redoMemento);

            self.setCurrentMemento(redoMemento);
        },
        initHistory: function(data) {
            var self = this;
            self.undoMementoList = [];
            self.redoMementoList = [];

            var newMemento = new Memento();
            var initialData = Object.extend({ content: $tom.EMPTY_PARAGRAPH_HTML, scrollTop: 0 }, data);
            newMemento.addUndoData(initialData);
            newMemento.addHandler(self.getTextHandler());
            self.setCurrentMemento(newMemento);
        },
        saveHistory: function(before, after, handler) {
            var self = this;
            if (self._historyDisabled) return;
            var undoMementoList = self.undoMementoList;
            var currentMemento = self.currentMemento;

            self.redoMementoList = [];
            if (arguments.length == 3) {
                currentMemento.addUndoRedData(before, after, handler);
            }
            var textData = self.getTextData();
            /** 이미지 편집기의 반환값이  이미지 Data URL 이므로 본문이 커진다.
             * 기능 비활성화 후 확인
            if (textData.content.length > 300000) {
                self.undoMementoList = [];
                self.redoMementoList = [];
                self.currentMemento.before.content = null;
                self._historyDisabled = true;
                textData.content = '';
                try {
                    var undo = self.canvas.editor.toolbar.tools['undo'].button;
                    var redo = self.canvas.editor.toolbar.tools['redo'].button;
                    undo.disable();
                    redo.disable();
                    undo._btnAlwaysDisabled = true;
                    redo._btnAlwaysDisabled = true;
                } catch (e) {}
                return;
            }
            */
            currentMemento.addRedoData(textData);
            keepMaxLength(undoMementoList, self.maxUndoCount);
            undoMementoList.push(currentMemento);

            var newMemento = new Memento();
            newMemento.addHandler(self.getTextHandler());
            newMemento.addUndoData(textData);
            self.setCurrentMemento(newMemento);

            self.contentModified = _FALSE;
        },
        injectHistory: function(before, after, handler) {
            if (!this.canUndo()) {
                return;
            }
            var undoMementoList = this.undoMementoList;
            var lastMemento = undoMementoList[undoMementoList.length - 1];
            lastMemento.addUndoRedData(before, after, handler);
        },
        saveHistoryIfEdited: function() {
            if (this.contentModified) {
                this.saveHistory();
            }
        },
        saveHistoryByKeyEvent: function(event) {
            var key = {
                code: event.keyCode,
                ctrl: event.ctrlKey || (event.keyCode === 17),
                alt: event.altKey || (event.keyCode === 18),
                shift: event.shiftKey || (event.keyCode === 16)
            };

            if (key.code == 229) { // ignore mouse click in ff.
                return;
            }

            var self = this;
            if (key.code == Trex.__KEY.ENTER || key.code == Trex.__KEY.SPACE || key.code == Trex.__KEY.TAB) {
                self.saveHistoryIfEdited();
            } else if (key.code == Trex.__KEY.DELETE || key.code == Trex.__KEY.BACKSPACE) {
                self.saveHistory();
            } else if ((key.code == Trex.__KEY.PASTE || key.code == Trex.__KEY.CUT) && key.ctrl) {
                self.saveHistory();
            } else if (((key.code > 32 && key.code < 41) && key.shift) || (key.code == 65 && key.ctrl)) { // shift + arrow,  home, end,  etc..  / select all
                self.saveHistoryIfEdited();
            } else if (key.ctrl || key.alt || (key.shift && key.code == 16)) {
                // content isn't modified
            } else {
                self.contentModified = _TRUE;
            }
        },
        getTextHandler: function() {
            var canvas = this.canvas;
            var self = this;
            return function(data) {
                canvas.setContent(data.content);

                var DEFAULT_RESRORE_RANGE = { start: 0, end: 0 };
                var range = data.range || DEFAULT_RESRORE_RANGE;
                self.restoreRange(range);

                if ($tx.msie_nonstd) {
                    // #FTDUEDTR-1122
                    setTimeout(function() {
                        canvas.setScrollTop(data.scrollTop);
                    }, 0);
                }
            }
        },
        getTextData: function() {
            return {
                content: this.canvas.getContent(),
                scrollTop: this.canvas.getScrollTop(),
                range: this.getRangeData()
            };
        }
    });

    var Memento = Trex.Class.create({
        initialize: function() {
            this.before = {};
            this.after = {};
            this.handlers = [];
        },
        addUndoRedData: function(before, after, handler) {
            Object.extend(this.before, before);
            Object.extend(this.after, after);
            this.handlers.push(handler);
        },
        addHandler: function(handler) {
            this.handlers.push(handler);
        },
        addUndoData: function(data) {
            Object.extend(this.before, data);
        },
        addRedoData: function(data) {
            Object.extend(this.after, data);
        },
        undo: function() {
            var self = this;
            self.handlers.each(function(handler) {
                handler(self.before);
            });
        },
        redo: function() {
            var self = this;
            self.handlers.each(function(handler) {
                handler(self.after);
            });
        }
    });
})();

/**
 * @fileOverview
 * 컨텐츠를 가지고 있는 편집 영역을 수정, 관리하는 Trex.Canvas 관련 Source로
 * 대부분 각 panel들에게 행동들을 위임한다.
 * 편집 영역 = panel = TextPanel, HtmlPanel, WysiwygPanel
 */
(function(Trex) {
    var QUERY_TRIGGER_KEYCODES = new $tx.Set(13, 8, 32, 33, 34, 37, 38, 39, 40, 46);
    var shouldTriggerQuery = function(keyCode) {
        return QUERY_TRIGGER_KEYCODES.contains(keyCode);
    };

    TrexConfig.add({
        "canvas": {
            doctype: "auto", // edge
            mode: ["text", "html", "source"],
            styles: {
                color: "#333333",
                fontFamily: "돋움",
                fontSize: "9pt",
                backgroundColor: "#ffffff",
                lineHeight: "1.5",
                padding: "8px",
                margin: "0px" /* setPanelHeight 계산 오류처리 */
            },
            pMarginZero: true,
            selectedMode: "html",
            readonly: _FALSE,
            initHeight: 400,
            minHeight: 200,
            ext: 'html',
            param: "",
            newlinepolicy: "p",
            showGuideArea: _TRUE,
            convertingText: _TRUE,
            escapeTextModeContents: _TRUE,
            removeTextModeBr: _FALSE,
            respectVisibilityInDesign: _TRUE
        }
    }, function(root) {
        var _config = TrexConfig.get('canvas', root);
        var _evConfig = root.events;
        _config.initializedId = root.initializedId || '';
        _config.useHotKey = _evConfig.useHotKey;
        var _switcher = TrexConfig.getTool('switcher', root);
        if (Trex.available(_switcher, "switcher" + _config.initializedId)) {
            _config.mode = _switcher.options.pluck("data");
        }
        var _fontfamily = TrexConfig.getTool('fontfamily', root);
        if (Trex.available(_fontfamily, "fontfamily" + _config.initializedId)) {
            if (_fontfamily.webfont && _fontfamily.webfont.use) {
                _config.webfont = _fontfamily.webfont;
                _config.webfont.options.each(function(element) {
                    element.url = TrexConfig.getUrl(element.url);
                });
            }
        }
        var _resizer = TrexConfig.get('resizer', root);
        if (_resizer) {
            _config.minHeight = _resizer.minHeight;
        }
        /**
         * 에디터통합 버전으로 한메일 배포시에는
         * 윗줄 주석해제, 아랫줄 삭제
         */
        //_config.wysiwygUrl = TrexConfig.getUrl(["#host#path/pages/daumx/", "wysiwyg_", (_config.serviceWysiwyg || "" ), ((_config.doctype == "html") ? "html" : "xhtml"), ".", (_config.ext ? _config.ext : "html"), "?prefix=" + root.initializedId, "&", _config.param].join(""));
        _config.wysiwygUrl = TrexConfig.getUrl([(_config.wysiwygPath || "#host#path/pages/daumx/"), "wysiwyg_", (_config.serviceWysiwyg || ""), ((_config.doctype == "html") ? "html" : "xhtml"), ".", (_config.ext ? _config.ext : "html"), "?prefix=" + root.initializedId, "&", _config.param].join(""));

        /**
         * doctype 결정기준
         */
        if (_config.doctype == 'auto') {
            if ($tx.msie && $tx.msie_quirks) {
                _config.doctype = 'quirks';
            } else {
                _config.doctype = 'edge';
            }
        }

    });

    TrexConfig.add({
        "size": {

        }
    });
    /**
     * 컨텐츠를 가지고 있는 편집 영역을 수정, 관리하는 Trex.Canvas 객체로 <br/>
     * 대부분 각 panel들에게 행동들을 위임한다. <br/>
     * 각각의 panel들은 해당 Processor들을 포함한다. <br/>
     * 편집 영역 = panel = TextPanel, HtmlPanel, WysiwygPanel
     *
     * @class
     * @extends Trex.I.JobObservable Trex.I.KeyObservable
     * @param {Object} editor
     * @param {Object} config
     */
    Trex.Canvas = Trex.Class.create( /** @lends Trex.Canvas.prototype */ {
        /** @ignore */
        $const: {
            /** @name Trex.Canvas.__TEXT_MODE */
            __TEXT_MODE: "text",
            /** @name Trex.Canvas.__HTML_MODE */
            __HTML_MODE: "source",
            /** @name Trex.Canvas.__WYSIWYG_MODE */
            __WYSIWYG_MODE: "html",
            __WYSIWYG_PADDING: 8,
            __IMAGE_PADDING: 5
        },
        /** @ignore */
        $mixins: [Trex.I.JobObservable, Trex.I.KeyObservable, Trex.I.ElementObservable, Trex.I.MouseoverObservable],
        /** Editor instance */
        editor: _NULL,
        /** Canvas Dom element, Generally $tx('tx_canvas') */
        elContainer: _NULL,
        /** Block UI **/
        elEditorBlockUI: _NULL,
        /** Canvas Config */
        config: _NULL,
        /** History Instance for redo/undo */
        history: _NULL,
        /**
         * Panels 객체
         * @private
         * @example
         * 	canvas.panels['html']
         * 	canvas.panels['source']
         * 	canvas.panels['text']
         */
        panels: _NULL,
        initialize: function(editor, rootConfig) {

            this.editor = editor;
            var _config = this.config = TrexConfig.get('canvas', rootConfig);
            var _initializedId = ((rootConfig.initializedId) ? rootConfig.initializedId : "");

            this.elContainer = $tx("tx_canvas" + _initializedId);
            this.wysiwygEl = $tx("tx_canvas_wysiwyg_holder" + _initializedId);
            this.sourceEl = $tx("tx_canvas_source_holder" + _initializedId);
            this.textEl = $tx("tx_canvas_text_holder" + _initializedId);
            this.elEditorBlockUI = $tx("tx_editor_blockui" + _initializedId);

            this.initConfig(rootConfig);
            this.createPanel();
            this.history = new Trex.History(this, _config);
            this.setCanvasSize({
                height: _config.initHeight
            });
        },
        initConfig: function(rootConfig) {
            var _config = this.config;
            /**
             * root config를 얻어온다.
             * @private
             * @returns {Object} root config
             */
            this.getRootConfig = function() {
                return rootConfig;
            };

            /**
             * Canvas의 config를 가져온다.
             * @returns {Object} config
             */
            this.getConfig = function() {
                return _config;
            };

            /**
             * wysiwyg panel의 스타일 config를 가져온다.
             * @param {String} name - 스타일명 optional
             * @returns {Object} 스타일 config
             * @example
             *  canvas.getStyleConfig();
             */
            this.getStyleConfig = function(name) {
                if (name) {
                    return _config.styles[name];
                } else {
                    return _config.styles;
                }
            };

            var _sizeConfig = TrexConfig.get('size', rootConfig);
            this.measureWrapWidth = function() {
                _sizeConfig.wrapWidth = this.getContainerWidth(); // TODO FTDUEDTR-1214
            };
            this.measureWrapWidth();
            if (!_sizeConfig.contentWidth) {
                _sizeConfig.contentWidth = _sizeConfig.wrapWidth;
            }
            _sizeConfig.contentPadding = _config.styles.padding.parsePx(); //15

            /**
             * canvas size 관련 config를 얻어온다.
             * @returns {Object} size config
             */
            this.getSizeConfig = function() {
                return _sizeConfig;
            };
        },
        getContainerWidth: function() {
            return $tx.getDimensions(this.elContainer).width;
        },
        /**
         * Panels 객체들을 초기화한다.
         * @private
         */
        createPanel: function() {
            var _canvas = this;
            var _config = this.config;
            this.panels = {};
            this.mode = _config.selectedMode || Trex.Canvas.__WYSIWYG_MODE;
            if (this._isForceTextMode()) {
                this.mode = Trex.Canvas.__TEXT_MODE;
            }
            var _panelCreater = {
                "text": function(_config) {
                    return new Trex.Canvas.TextPanel(_canvas, _config);
                },
                "source": function(_config) {
                    return new Trex.Canvas.HtmlPanel(_canvas, _config);
                },
                "html": function(_config) {
                    return new Trex.Canvas.WysiwygPanel(_canvas, _config);
                }
            };
            _config.mode.each(function(name) {
                if (_panelCreater[name]) {
                    _canvas.panels[name] = _panelCreater[name](_config);
                }
            });
            for (var _p in _canvas.panels) {
                if (this.mode == _p) {
                    _canvas.panels[_p].show();
                } else {
                    _canvas.panels[_p].hide();
                }
            }
            _canvas.observeJob('canvas.panel.iframe.load', function(panelDoc) {
                _canvas.fireJobs(Trex.Ev.__IFRAME_LOAD_COMPLETE, panelDoc);
            });
        },
        _isForceTextMode: function() {
            // 기존에는 아래의 조건이었으나 모바일에서의 호환은 아직 문제가 많아 제한함. 20140430
            // ($tx.ios && $tx.ios_ver < 5) || ($tx.android && $tx.android_ver < 3)
            return $tx.ios || $tx.android;
        },
        /**
         * Canvas의 mode를 바꾸는것으로, 현재 활성화되어있는 panel을 변경한다.
         * @param {String} newMode - 변경 할 mode에 해당하는 문자열
         * @example
         *  editor.getCanvas().changeMode('html');
         *  editor.getCanvas().changeMode('source');
         *  editor.getCanvas().changeMode('text');
         */
        changeMode: function(newMode) {
            var _editor = this.editor;
            var oldMode = this.mode;
            if (oldMode == newMode) {
                return;
            }
            if (oldMode == Trex.Canvas.__WYSIWYG_MODE && _editor._imageResizeCtrl) {
                _editor._imageResizeCtrl.changeMode();
            }
            if (this._isForceTextMode() && oldMode == Trex.Canvas.__TEXT_MODE) {
                return;
            }
            var _oldPanel = this.panels[oldMode];
            var _newPanel = this.panels[newMode];
            if (!_oldPanel || !_newPanel) {
                throw new Error("[Exception]Trex.Canvas : not suppored mode");
            }
            var _oldContent = _oldPanel.getContent();
            var _content = _editor.getDocParser().getContentsAtChangingMode(_oldContent, oldMode, newMode);
            if (oldMode == Trex.Canvas.__WYSIWYG_MODE) { //NOTE: #FTDUEDTR-366
                if ($tx.msie_ver === 8) {
                    _oldPanel.hide();
                } //prevent black screen from youtube iframe. #FTDUEDTR-1272
                _oldPanel.setContent("");
                try {
                    this.focusOnTop();
                } catch (e) {}
            }
            try { //#FTDUEDTR-1111
                _newPanel.setContent(_content);
            } catch (error) {
                alert(' - Error: ' + error.message + Trex._I18N.g('changeMode_error', '\n에디터 타입 변경에 실패하였습니다.\n잘못된 HTML이 있는지 확인해주세요.'));
                _oldPanel.setContent(_oldContent);
                _oldPanel.show();
                return;
            }
            this.mode = newMode;
            this.fireJobs(Trex.Ev.__CANVAS_MODE_CHANGE, oldMode, newMode);
            _newPanel.setPanelHeight(_oldPanel.getPanelHeight());
            _newPanel.show();
            _oldPanel.hide();
            // FF2 bug:: When display is none,  designMode can't be set to on
            try {
                if (newMode == "html" && !this.getPanel("html").designModeActivated && $tx.gecko) {
                    this.getPanel("html").el.contentDocument.designMode = "on";
                    this.getPanel("html").designModeActivated = _TRUE;
                }
            } catch (e) {
                throw e;
            }
        },
        /**
         * 현재 panel에 포커스를 준다.
         */
        focus: function() {
            this.panels[this.mode].focus();
        },
        /**
         * 본문의 처음으로 캐럿을 옮긴다. - Only Wysiwyg
         */
        focusOnTop: function() {
            this.getProcessor().focusOnTop();
        },
        /**
         * 본문의 마지막으로 캐럿을 옮긴다. - Only Wysiwyg
         */
        focusOnBottom: function() {
            this.getProcessor().focusOnBottom();
        },
        /**
         * canvas의 position을 가져온다.
         * @returns {Object} position = { x: number, y:number }
         */
        getCanvasPos: function() {
            var _position = $tx.cumulativeOffset(this.elContainer);
            return {
                'x': _position[0],
                'y': _position[1]
            };
        },
        /**
         * canvas의 height를 변경한다.
         * @param {String} size (px)
         * @example
         *  canvas.setCanvasSize({
         *  	height: "500px"
         *  });
         */
        setCanvasSize: function(size) {
            if (this.panels[this.mode] && size.height) {
                this.panels[this.mode].setPanelHeight(size.height);
            } else {
                throw new Error("[Exception]Trex.Canvas : argument has no property - size.height ");
            }
        },
        /**
         * @Deprecated use isWYSIWYG()
         */
        canHTML: function() {
            return this.isWYSIWYG();
        },
        isWYSIWYG: function() {
            return this.mode === Trex.Canvas.__WYSIWYG_MODE;
        },
        /**
         * panel 객체를 가져온다.
         * @param {String} mode - 가져올 panel 모드명
         * @returns {Object} - parameter에 해당하는 Panel
         * @example
         * 	this.getPanel('html').designModeActivated = true;
         */
        getPanel: function(mode) {
            if (this.panels[mode]) {
                return this.panels[mode];
            } else {
                return _NULL;
            }
        },
        /**
         * 현재 활성화되어있는 panel 객체를 가져온다.
         * @returns {Object} - 활성화되어있는 panel 객체
         */
        getCurrentPanel: function() {
            if (this.panels[this.mode]) {
                return this.panels[this.mode];
            } else {
                return _NULL;
            }
        },
        /**
         * 현재 활성화되어있는 panel의 processor을 가져온다.
         * @returns {Object} - 활성화되어있는 panel의 processor 객체
         */
        getProcessor: function(mode) {
            if (!mode) {
                return this.panels[this.mode].getProcessor();
            } else {
                return this.panels[mode].getProcessor();
            }
        },
        /**
         * 본문의 내용을 가져온다
         * @returns {String}
         */
        getContent: function() {
            var _content = this.panels[this.mode].getContent();
            if (_content) {
                _content = _content.replace(Trex.__WORD_JOINER_REGEXP, ""); //NOTE: 서비스의 DB charset이 euc-kr 계열일 경우 문제가 있음.
            }
            return _content;
        },
        /**
         * 현재 Wysiwyg 영역의 수직 스크롤 값을 얻어온다. - Only Wysiwyg
         * @function
         * @returns {Number} 수직 스크롤 값
         * @see Trex.Canvas.WysiwygPanel#getScrollTop
         */
        getScrollTop: function() {
            if (!this.isWYSIWYG()) {
                return 0;
            }
            return this.panels[this.mode].getScrollTop();
        },
        /**
         * Wysiwyg 영역의 수직 스크롤 값을 셋팅한다. - Only Wysiwyg
         * @function
         * @param {Number} scrollTop - 수직 스크롤 값
         * @see Trex.Canvas.WysiwygPanel#setScrollTop
         */
        setScrollTop: function(scrollTop) {
            if (!this.isWYSIWYG()) {
                return;
            }
            this.panels[this.mode].setScrollTop(scrollTop);
        },
        /**
         * 현재 활성화된 panel에 컨텐츠를 주어진 문자열로 수정한다.
         * @param {String} content - 컨텐츠
         */
        setContent: function(content) {
            this.panels[this.mode].setContent(content);
            this.includeWebfontCss(content);
        },
        /**
         * panel에 컨텐츠를 주어진 문자열로 초기화한다.
         * @param {String} content - 컨텐츠
         */
        initContent: function(content) {
            this.history.initHistory({
                'content': content
            });
            this.panels[this.mode].setContent(content);
            this.includeWebfontCss(content);
            this.fireJobs(Trex.Ev.__CANVAS_DATA_INITIALIZE, Trex.Canvas.__WYSIWYG_MODE, _NULL);
            /* //NOTE: 메일은 수정이 없음. 답장 전달의 경우에는 본문 상단에 포커싱이 가도록.
            if ( $tx.gecko ){
                var me = this;
                setTimeout( function(){
                    me.focusOnBottom();
                },500)
            }else{
                this.focusOnBottom();
            }
			*/
        },
        /**
         * 컨텐츠를 파싱하여 사용되고 있는 웹폰트가 있으면, 웹폰트 css를 로딩한다. - Only Wysiwyg
         * @param {string} content
         * @see Trex.Canvas.WysiwygPanel#includeWebfontCss
         */
        includeWebfontCss: function(content) {
            if (!this.isWYSIWYG()) {
                return;
            }
            return this.panels[this.mode].includeWebfontCss(content);
        },
        /**
         * 본문에 사용된 웹폰트명 목록을 리턴한다. - Only Wysiwyg
         * @function
         * @returns {Array} 사용하고 있는 웹폰트명 목록
         * @see Trex.Canvas.WysiwygPanel#getUsedWebfont
         */
        getUsedWebfont: function() {
            if (!this.isWYSIWYG()) {
                return [];
            }
            return this.panels[this.mode].getUsedWebfont();
        },
        /**
         * 자바스크립트를 동적으로 실행한다 - Only Wysiwyg
         * @param {String} scripts - 자바스크립트 문자열
         */
        runScript: function(scripts) {
            if (!this.isWYSIWYG()) {
                return [];
            }
            this.panels[this.mode].runScript(scripts);
        },
        /**
         * 자바스크립트 소스를 로딩하여 동적으로 실행한다 - Only Wysiwyg
         * @param {String} url - 자바스크립트 url
         */
        importScript: function(url, callback) {
            if (!this.isWYSIWYG()) {
                return [];
            }
            this.panels[this.mode].importScript(url, callback);
        },
        /**
         * 선택된 영역의 상태 값을 알기위해 주어진 함수를 실행시킨다. - Only Wysiwyg
         * @param {Function} handler - 주어진 함수
         * @example
         * 		var _data = canvas.query(function(processor) {
         *			return processor.queryCommandState('bold');
         *		});
         */
        query: function(handler) {
            if (!this.isWYSIWYG()) {
                return _NULL;
            }
            var _processor = this.getProcessor();
            /* Block Scrolling
             if($tx.msie) {
             _processor.focus();
             }
             */
            return handler(_processor);
        },
        /**
         * 선택된 영역에 주어진 handler를 실행시킨다.
         * @param {Function} handler - 주어진 함수
         * @example
         * 		canvas.execute(function(processor) {
         *			processor.execCommand('bold', _NULL);
         *		});
         */
        execute: function(handler) {
            var _history = this.history;
            var _processor = this.getProcessor();
            if (this.isWYSIWYG()) {
                this.getPanel('html').ensureFocused();
                if (_processor.restoreRange) {
                    setTimeout(function() { //NOTE: #FTDUEDTR-435
                        _processor.restoreRange();
                        handler(_processor);
                        _history.saveHistory();
                        _processor.restore();
                    }, 0);
                } else {
                    _processor.focus();
                    handler(_processor);
                    _history.saveHistory();
                    _processor.restore();
                }
            } else {
                handler(_processor);
            }
        },
        /**
         * caret을 주어진 위치로 이동한다. - Only Wysiwyg <br/>
         * aaa.bbb - bbb라는 클래스를 가진 aaa 노드의 다음에 커서를 이동한다.
         * @param {String} scope
         */
        moveCaret: function(scope) {
            if (!scope) {
                return;
            }
            if (!this.isWYSIWYG()) {
                return;
            }
            this.getProcessor().moveCaretWith(scope);
        },
        /**
         * 선택한 영역에 HTML 컨텐츠를 삽입한다.
         * @param {String} content - 삽입하고자 하는 HTML 컨텐츠
         * @param {Boolean} newline - 현재 영역에서 한줄을 띄운 후 삽입할지 여부 true/_FALSE
         * @param {Object} wrapStyle - wrapper 노드에 적용할 스타일, <br/>
         * 					newline이 true 일 경우에만 의미를 갖는다.
         */
        pasteContent: function(content, newline, wrapStyle) {
            newline = newline || _FALSE;
            this.execute(function(processor) {
                processor.pasteContent(content, newline, wrapStyle);
            });
        },
        /**
         * 선택한 영역에 노드를 삽입한다. - Only Wysiwyg
         * @param {Array|Element} node - 삽입하고자 하는 노드 배열 또는 노드
         * @param {Boolean} newline - 현재 영역에서 한줄을 띄운 후 삽입할지 여부 true/_FALSE
         * @param {Object} wrapStyle - wrapper 노드에 적용할 스타일, <br/>
         * 					newline이 true 일 경우에만 의미를 갖는다.
         */
        pasteNode: function(node, newline, wrapStyle) {
            if (!this.isWYSIWYG()) {
                return;
            }
            newline = newline || _FALSE;
            this.execute(function(processor) {
                processor.pasteNode(node, newline, wrapStyle);
            });
        },
        /**
         * 현재 활성화된 panel에 스타일을 적용한다.
         * @param {Object} styles - 적용할 스타일
         */
        addStyle: function(styles) {
            this.panels[this.mode].addStyle(styles);
        },
        /**
         * 스타일명으로 현재 활성화된 panel의 스타일 값을 얻어온다.
         * @param {String} name - 스타일명
         * @returns {String} 해당 스타일 값
         */
        getStyle: function(name) {
            return this.panels[this.mode].getStyle(name);
        },
        /**
         * 특정 노드의 Wysiwyg 영역에서의 상대 위치를 얻어온다. - Only Wysiwyg
         * @function
         * @param {Element} node - 특정 노드
         * @returns {Object} position 객체 = {
         *								x: number,
         *								y: number,
         *								width: number,
         *								height: number
         *						}
         */
        getPositionByNode: function(node) {
            if (!this.isWYSIWYG()) {
                return {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            }
            return this.panels[this.mode].getPositionByNode(node);
        },

        onKeyDown: function(event) {
            function getNodeAndOffsetAtSel(_doc, _p) {
                var rng = goog.dom.Range.createFromBrowserSelection(_doc.getSelection ? _doc.getSelection() : _p.getSel());
                var node = rng.getStartNode();
                var offset = rng.getStartOffset();
                return {
                    node: node,
                    offset: offset
                }
            }
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_KEYDOWN, event);
            var prev = null;
            if (event.keyCode == Trex.__KEY.BACKSPACE) {
                var p = this.getProcessor();
                if (p.isCollapsed()) {
                    var doc = this.getCurrentPanel().getDocument();
                    var where = getNodeAndOffsetAtSel(doc, p);
                    if ((prev = $tom.prevNodeUntilTagName(where.node, where.offset, 'table')) && $tom.isTagName(prev, 'table')) {
                        $tx.stop(event);
                        this.fireJobs(Trex.Ev.__CANVAS_PANEL_BACKSPACE_TABLE, prev);
                    }
                }
            }
            /**
             * DEL, BACKSPACE 입력시 합처지는 p의 원 스타일 유지
             */
            function setInlineCurrentStyle(node, style_node, p) {
                node.style.fontFamily = p.queryStyle(style_node, 'fontFamily');
                node.style.fontSize = p.queryStyle(style_node, 'fontSize');
                node.style.color = p.queryStyle(style_node, 'color');
            }
            /**
             * IE에서 DEL 키 누르는 위치 의 다음에 `<span><p></p></span>` 구조의 tag가 있는경우 
             * 삭제가 되지 않고 뒤 `<span>` 안쪽에 `<p></p>`가 새로 생기는 현상 처리
             * <span><p></p></span> 안쪽 맨 끝 에서 DEL 키 누를때 처리
             */
            if ($tx.msie && $tx.msie_ver == 11  && event.keyCode == Trex.__KEY.DELETE){                
                var p = this.getProcessor();
                if (p.isCollapsed()) {
                    var doc = this.getCurrentPanel().getDocument();
                    var where = getNodeAndOffsetAtSel(doc, p);
                    var _node = where.node;
                    var _offset = where.offset;
                    /*_node.nodeName != "P" &&*/
                    if(_node.childNodes && _node.childNodes.length == 1 && _node.childNodes[0].nodeName == "BR" ){
                        _node.childNodes[0].removeNode(true);
                    }
                    if(_node.nodeName == "#text" && _node.length == 1 && encodeURIComponent(_node.nodeValue) == "%EF%BB%BF") {
                         _node.nodeValue = '';
                    }
                    if((_node.nodeName == "#text" && _node.length <= _offset) || (_node.textContent == "")){ // Text Node 이면서 Node의 끝에 있는 경우
                        var _p = null;
                        if(_node.nodeName == "P") _p = _node;
                        else{
                            for(var __p = _node.parentNode; __p != null; __p = __p.parentNode){
                                _p = __p;
                                // if($tom.isParagraph(_p)) break;
                                if(_p.nodeName == "P") break;
                                if(_p.nextSibling != null){
                                    _p = null; 
                                    break;
                                }
                            }
                        }
                        // SPAN 또는 P로 싸여 있는 경우 SPAN 삭제
                        var _ps = _p&&_p.parentNode||null;
                        var limit_w = 10;
                        while(_ps){
                            limit_w--;
                            if(limit_w < 0) break;
                            if(_ps.nodeName == "SPAN" || _ps.nodeName == "FONT" || _ps.nodeName == "P"){
                                _ps.removeNode(false);
                                _ps = _p.parentNode;
                            }else{
                                _ps = null;
                                break;
                            }
                        }
                        if(_p && _p.nextSibling && (_p.nextSibling.nodeName == "SPAN" || _p.nextSibling.nodeName == "FONT")){ // 부모 P 뒤에 바로 SPAN이 나온 경우
                            _p.nextSibling.removeNode(false);
                        }
                        var limit_f = 10;
                        function _checkSpan(_nex){
                            limit_f--;
                            if(limit_f < 0) return;
                            if(!_nex) return;                            
                            if(_nex.nodeName == "SPAN" || _nex.nodeName == "FONT"){
                                _nex.removeNode(false);
                                _checkSpan(_p.nextSibling);
                                return;
                            }
                            if(_nex.nodeName == "P" && _nex.childNodes.length > 0){                                
                                if(_nex.childNodes[0].nodeName == "P"){
                                    // <p><p> 구조.
                                    _nex.removeNode(false);
                                    _checkSpan(_p.nextSibling);
                                    return;
                                }
                                if(_nex.childNodes[0].nodeName == "SPAN" || _nex.childNodes[0].nodeName == "FONT"){
                                    // <span><p>
                                    var ___p = $tom.descendant(_nex.childNodes[0], '%paragraph');
                                    if(___p){
                                        _nex.childNodes[0].removeNode(false);
                                        _checkSpan(_p.nextSibling);
                                        return;
                                    }
                                }
                            }
                        }
                        if(_p) _checkSpan(_p.nextSibling);
                        /**
                         * 다음 P tag 하위 Text Node Style 처리
                         */
                        if(_p && _p.nextSibling && _p.nextSibling.tagName == 'P') {
                            var childs = _p.nextSibling.childNodes;
                            if(childs.length == 1 && childs[0].childNodes && childs[0].childNodes.length == 1  && childs[0].childNodes[0].nodeName == "BR"){
                                childs[0].removeNode(true);
                            }// 다음 <p><strong><br><strong></p> 등 삭제 커서 위로 이동 방지
                            for(var i = 0; i < childs.length; i++){
                                var _c_node = childs[i];
                                if(_c_node.nodeType == 3 && _c_node.textContent.replace(/[ \f\n\r\t\v]/g, '') !== ''){
                                    var newSpan = p.create("span");
                                    $tom.wrap(newSpan, _c_node);
                                    setInlineCurrentStyle(newSpan, newSpan, p);
                                }else if(_c_node.nodeType == 1 && _c_node.nodeName == "SPAN"){
                                    setInlineCurrentStyle(_c_node, _c_node, p);
                                }
                            }
                        }
                    }
                }
            }
            /**
             * IE에서 `<span><p></p></span>` 구조 안쪽에서 BACKSPACE 키 누를 때
             * 뒤 쪽 내용이 따라 오지 않는 현상 처리
             * `<span><p></p></span>` 구조 뒤에서 BACKSPACE 키 누를때
             */
            if ($tx.msie && $tx.msie_ver == 11 && event.keyCode == Trex.__KEY.BACKSPACE){  
                var p = this.getProcessor();
                if (p.isCollapsed()) {
                    var doc = this.getCurrentPanel().getDocument();
                    var where = getNodeAndOffsetAtSel(doc, p);
                    var _node = where.node;
                    var _offset = where.offset;   
                    var _p = null;
                    if(_node.nodeType == 3 && _node.nodeValue == Trex.__WORD_JOINER && _offset == 1){
                        _offset = 0;
                        var tmp = _node
                        _node = _node.parentNode;
                        tmp.removeNode(true);
                    }
                    if(_node.nodeName == "P" && _offset == 0){
                        _p = _node;
                    }else if(_offset == 0 && (/*_node.nodeName == "#text" &&*/ _node.previousSibling == null)){ //Node의 맨 앞 에 있는 경우
                        /**
                         * 현 node가 paragraph 맨 앞인지 여부
                         */
                        for(var __p = _node.parentNode; __p != null; __p = __p.parentNode){
                            _p = __p;
                            // if($tom.isParagraph(_p)) break;
                            if(_p.nodeName == "P") break;
                            if(_p.previousSibling != null){
                                _p = null; 
                                break;
                            }
                        }
                    }
                    if(_p && _node.nodeName != "P" && _node.nodeType == 1 
                        && _node.childNodes && (_node.childNodes.length == 0 
                            || (_node.childNodes.length == 1 && _node.childNodes[0].nodeName == "BR")
                            || (_node.childNodes.length == 1 && _node.childNodes[0].nodeType == 3 && _node.childNodes[0].nodeValue == Trex.__WORD_JOINER)
                        )){
                        // _node.removeNode(true);
                        var _trg = _node;
                        var limit_l = 100;
                        while(_trg && _trg.parentNode && _trg.parentNode != _p && _trg.parentNode.childNodes.length == 1) {
                            limit_l--;
                            if(limit_l < 0) break;
                            _trg = _trg.parentNode;
                        }
                        if(_trg) _trg.removeNode(true);
                    }
                    // SPAN 또는 P로 싸여 있는 경우 SPAN 삭제
                    var _ps = _p&&_p.parentNode||null;
                    var limit_w = 10;
                    while(_ps){
                        limit_w--;
                        if(limit_w < 0) break;
                        if(_ps.nodeName == "SPAN" || _ps.nodeName == "FONT" || _ps.nodeName == "P"){
                            _ps.removeNode(false);
                            _ps = _p.parentNode;
                        }else{
                            _ps = null;
                            break;
                        }
                    }
                    /**
                     * 내 앞 Paragraph 맨 뒤 element 상태 처리
                     */
                    var limit_f = 10;
                    function _procPrevious(_prev){
                        limit_f--;
                        if(limit_f < 0) return;
                        if(!_prev) return;                 
                        if(_prev.nodeName == "SPAN" || _prev.nodeName == "FONT"){
                            _prev.removeNode(_prev.textContent.replace(/\s/g, '') == "");
                            _procPrevious(_p.previousSibling);
                            return;
                        }
                        if(_prev.nodeName == "P"){
                            if(_prev.childNodes.length == 0){
                                _prev.removeNode(true);
                                // _procPrevious(_p.previousSibling);
                                if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }
                                if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; }
                                return;
                            }
                            var _lc = _prev.childNodes && _prev.childNodes[_prev.childNodes.length - 1]||null;
                            if(_lc && _lc.nodeName == "P"){
                                // <p><p> 구조.
                                _lc.removeNode(false);
                                _procPrevious(_p.previousSibling);
                                return;
                            }
                            if(_lc && (_lc.nodeName == "SPAN" || _lc.nodeName == "FONT")){
                                // <span><p>
                                var ___p = $tom.descendant(_lc, '%paragraph');
                                if(___p){
                                    _lc.removeNode(false);
                                    _procPrevious(_p.previousSibling);
                                    return;
                                }
                            }
                            var limit_w = 10;
                            while(_lc){
                                limit_w--;
                                if(limit_w < 0) break;
                                if(_lc.nodeName == "BR"){
                                    _lc.removeNode(true);
                                    break;
                                }else if((_lc.nodeName == "SPAN" || _lc.nodeName == "FONT" || _lc.nodeName == "STRONG" || _lc.nodeName == "B") 
                                    && (
                                        (_lc.childNodes.length == 1 && _lc.childNodes[0].nodeName == "BR") 
                                        || _lc.childNodes.length == 0
                                    )
                                    ){
                                    if(_lc.childNodes.length != 0) _lc.childNodes[0].removeNode(true);
                                    var txtNode = p.doc.createTextNode(Trex.__WORD_JOINER);
                                    _lc.appendChild(txtNode);
                                    break;
                                }else if(
                                    ((_lc.nodeName == "SPAN" || _lc.nodeName == "FONT") && _lc.innerHTML == "")
                                    || (_lc.nodeName == "#text" && _lc.previousSibling == null && _lc.textContent.replace(/\s/g, '') == "")){
                                    var tmp = _lc;
                                    var _lcp = _lc.parentNode;
                                    _lc = _prev;
                                    tmp.removeNode(true);
                                    if(_lcp.nodeName == "P" && _lcp.innerHTML == ""){
                                        _lcp.removeNode(true);
                                        // _procPrevious(_p.previousSibling);
                                        break;
                                    }
                                }else{
                                    // console.log('else',_lc.nodeName);
                                }
                                _lc = _lc && _lc.childNodes && _lc.childNodes[_lc.childNodes.length - 1]||null;
                            }
                        }
                    }
                    if(_p) _procPrevious(_p.previousSibling);
                    /**
                     * P tag 하위 Text Node Style 처리
                     */
                    if(_p && _p.style && (_p.style.marginLeft)) {
                        var mt = parseInt(_p.style.marginLeft);
                        if(mt < 2) {
                            _p.style.margin = _p.style.marginLeft = '';
                        }
                    }
                    if(_p && _p.previousSibling && _p.previousSibling.nodeName == 'P') {
                        var prev = _p.previousSibling;
                        if(_p.children && _p.children.length == 1 
                                && _p.children[0].nodeName == "SPAN" 
                                && (_p.textContent.replace(/[ \f\n\r\t\v]/g, '') !== '')
                            ){
                            setInlineCurrentStyle(_p.children[0], _p.children[0], p);
                        }else{
                            if(_p.children && _p.children.length == 1 && _p.children[0].nodeName == "BR"){
                                _p.removeChild(_p.children[0]);
                            }
                            if(_p.textContent.replace(/[ \f\n\r\t\v]/g, '') !== '' && !(_p.childNodes.length == 1 && _p.childNodes[0].nodeType == 1)){
                                var newSpan = p.create("span");
                                prev.appendChild(newSpan);
                                var txtNode = p.doc.createTextNode(Trex.__WORD_JOINER);
                                newSpan.appendChild(txtNode);
                                setInlineCurrentStyle(newSpan, _p, p);
                             }
                        }
                    }
                }
            }else if (!$tx.msie && event.keyCode == Trex.__KEY.BACKSPACE){
                var p = this.getProcessor();
                if (p.isCollapsed()) {
                    var doc = this.getCurrentPanel().getDocument();
                    var where = getNodeAndOffsetAtSel(doc, p);
                    var _node = where.node;
                    var _offset = where.offset;   
                    var _p = null;
                    if(_node.nodeName == "P" && _offset == 0){
                        _p = _node;
                    }else if(_offset == 0 && (/*_node.nodeName == "#text" &&*/ _node.previousSibling == null)){ //Node의 맨 앞 에 있는 경우
                        /**
                         * 현 node가 paragraph 맨 앞인지 여부
                         */
                        for(var __p = _node.parentNode; __p != null; __p = __p.parentNode){
                            _p = __p;
                            // if($tom.isParagraph(_p)) break;
                            if(_p.nodeName == "P") break;
                            if(_p.previousSibling != null){
                                _p = null; 
                                break;
                            }
                        }
                    }
                    if(_p && _p.style && (_p.style.marginLeft)) {
                        var mt = parseInt(_p.style.marginLeft);
                        if(mt < 2) {
                            _p.style.margin = _p.style.marginLeft = '';
                        }
                    }
                }
            }
            /**
             * 위/아래 이동 키
             * IE에서 위/아래 이동시 공백 줄을 건너뛰는 현상 처리
             * <p></p> innerHTML이 <br> 이 아닌 "%EF%BB%BF"(UTF-8 BOM) 값인 경우 
             */
            if ($tx.msie && (event.keyCode == 40 || event.keyCode == 38)){
                var p = this.getProcessor();
                if (p.isCollapsed()) {
                    var doc = this.getCurrentPanel().getDocument();
                    var where = getNodeAndOffsetAtSel(doc, p);
                    var _node = where.node;                                   
                    var _p = null;
                    if(_node.nodeName == "P") _p = _node;
                    else if(_node.parentNode && _node.parentNode.nodeName == "P") _p = _node.parentNode;
                    else _p = $tom.find(_node, '%paragraph');
                    _p = !_p?_node.parentNode:_p;
                    var _np = _p?event.keyCode == 40?_p.nextSibling:_p.previousSibling:null;
                    if(_np && _np.nodeName == "P" 
                        && _np.childNodes.length == 1 
                        && _np.childNodes[0].length == 1
                        && encodeURIComponent(_np.childNodes[0].nodeValue) == "%EF%BB%BF") _np.innerHTML = "<br>";
                }
            }

            if (this.config.useHotKey) {
                this.fireKeys(event);
            }
            if ($tx.msie && $tx.msie_ver == 11 && event.keyCode == Trex.__KEY.ENTER && !event.shiftKey) {
                var __self = this;
                setTimeout(__self._ie11Enterbug.bind(__self), 25);
            }
            if (event.keyCode == 86 && event.ctrlKey) {
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_PASTE_CUSTOM_KEY, event);
            }
        },
        // _ie11Enterbug: function() {
        //     var p = this.getProcessor();
        //     if (p.isCollapsed()) {
        //         var doc = this.getCurrentPanel().getDocument();
        //         var rng = goog.dom.Range.createFromBrowserSelection(doc.getSelection ? doc.getSelection() : p.getSel());
        //         var node = rng.getStartNode();
        //         //node.textContents
        //         //ie9+
        //         if (node && node.nodeType === 1 && (node.textContent.replace(/[ \f\n\r\t\v]/g, '') === '')) {
        //             var dummy = p.newDummy(false);
        //             rng.insertNode(dummy, true);
        //             rng.select();
        //     }
        // },
        _ie11Enterbug: function() {
            var p = this.getProcessor();
            if (p.isCollapsed()) {
                var doc = this.getCurrentPanel().getDocument();
                var rng = goog.dom.Range.createFromBrowserSelection(doc.getSelection ? doc.getSelection() : p.getSel());
                var node = rng.getStartNode();
                //node.textContents
                //ie9+
                // 공백 줄에 br이 없으면 커서 이동이 안되는 문제처리 윗쪽에 BR을 넣어준다.
                if (node && node.nodeType === 1 
                    && node.children && node.children.length <= 1 
                    && !(node.childNodes.length == 1 && (node.childNodes[0].nodeName == "BR"||node.childNodes[0].nodeName == "IMG"))
                    && (node.textContent.replace(/[ \f\n\r\t\v]/g, '') === '')) {
                    // var dummy = p.newDummy(false);
                    // node.appendChild(dummy);
                    // rng.insertNode(dummy, true);
                    // node.innerHTML = "<br>";
                    var tp = node.nodeName == "P" ? node : node.parentNode;
                    if( tp && tp.nodeName == "P" && tp.previousSibling && tp.previousSibling.nodeName == "P"){
                        var _prev = tp.previousSibling;
                        if(_prev.childNodes.length == 0 && _prev.textContent.replace(/[ \f\n\r\t\v]/g, '') === '') {
                            _prev.innerHTML = "<BR>";
                            // _prev.appendChild(p.newDummy(false));
                        } else if(_prev.childNodes.length == 1 && _prev.childNodes[0].nodeName == "SPAN"){
                            _prev = _prev.childNodes[0];
                            if(_prev.childNodes.length == 0) {
                                _prev.innerHTML = "<BR>";
                                // _prev.appendChild(p.newDummy(false));
                            } else if(_prev.childNodes[0].nodeType == 3 && _prev.childNodes[0].nodeValue.replace(Trex.__WORD_JOINER_REGEXP, "") == ""){
                                _prev.innerHTML = "<BR>";
                                // _prev.appendChild(p.newDummy(false));
                            }
                        }
                    }
                    if( tp && tp.nodeName == "P" && tp.nextSibling && tp.nextSibling.nodeName == "P"){
                        var _prev = tp.nextSibling;
                        var _need_br = false;
                        
                        if(_prev.childNodes.length == 0 && _prev.textContent.replace(/[ \f\n\r\t\v]/g, '') === '') {
                            _need_br = true;
                        } else if(_prev.childNodes.length == 1 && _prev.childNodes[0].nodeName == "SPAN"){
                            _prev = _prev.childNodes[0];
                            if(_prev.childNodes.length == 0) {
                                _need_br = true;
                            } else if(_prev.childNodes.length == 1 && _prev.childNodes[0].nodeType == 3 && _prev.childNodes[0].nodeValue.replace(Trex.__WORD_JOINER_REGEXP, "") == ""){
                                _need_br = true;
                            }
                        }
                        if(_need_br){
                            // var _range = doc.createRange();
                            // var _sel = doc.getSelection();
                            // _sel.removeAllRanges();
                            _prev.innerHTML = "<BR>";  
                            // _range.selectNode(_prev);
                            // _range.collapse(true);
                            // _sel.addRange(_range);
                            // return; 
                        }
                    }
                    rng.select();
                } else if(node && node.nodeType === 1 && node.nodeName == "SPAN" && node.childNodes.length == 1) {
                    var _child = node.childNodes[0];
                    var _parent = node.parentNode;
                    /* span 중첩 문제 처리 */
                    if (_parent && _parent.childNodes.length == 1 && _child.nodeName == node.nodeName && _child.style.cssText == node.style.cssText){
                        var _parent = node.parentNode;
                        $tom.remove(node);
                        _parent.appendChild(_child);
                        rng.select();
                    }
                } else if (node && node.nodeType === 1 && (node.textContent.replace(/[ \f\n\r\t\v]/g, '') === '')) {
                    var dummy = p.newDummy(false);
                    rng.insertNode(dummy, true);
                    rng.select();
                }
            }
        },

        onKeyUp: function(event) {
            var keyCode = event.keyCode + '';

            var _tq = shouldTriggerQuery(keyCode);
            if (_tq) {
                this.getProcessor().clearDummy();
            }

            this.history.saveHistoryByKeyEvent(event);

            try {
                this.mayAttachmentChanged = _TRUE;
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_KEYUP, event);
                if (this.isWYSIWYG() && _tq) {
                    this.triggerQueryStatus();
                }
                // __CANVAS_PANEL_DELETE_SOMETHING event 사용안함. 사용처 다 disable
                // if (keyCode === Trex.__KEY.DELETE || keyCode === Trex.__KEY.BACKSPACE) { //NOTE: (Del/Backspace) keys를 눌러 본문에서 무엇인가가 삭제되었다고 생각될 경우 첨부들의 싱크를 확인한다.
                //     this.fireJobs(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING);
                // }
            } catch (ignore) {}

            try {
                if (this.isWYSIWYG()) {
                    var _self = this;
                    setTimeout(function() {
                        try {
                            var googRange = _self.getProcessor().createGoogRange();
                            _self._SELECTION_RANGE = (googRange && googRange.browserRangeWrapper_ ? googRange.browserRangeWrapper_.range_ : null);
                        } catch (e) {
                            _self._SELECTION_RANGE = null;
                        }
                    }, 0);
                }
            } catch (e) {}
        },

        onMouseOver: function(event) {
            try {
                this.fireMouseover($tx.element(event));
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEOVER, event);
            } catch (ignore) {}
        },

        onMouseMove: function(event) {
            try {
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, event);
            } catch (ignore) {}
        },

        onMouseOut: function(event) {
            try {
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEOUT, event);
            } catch (ignore) {}
        },

        onMouseDown: function(event) {
            this.getProcessor().clearDummy();
            try {
                this.fireElements($tx.element(event));
            } catch (ignore) {}
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, event);
            var history = this.history;
            history.saveHistoryIfEdited();
        },

        onMouseUp: function(event) {
            try {
                var self = this;
                self.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEUP, event);
                var _btn = event.button;
                setTimeout(function() {
                    var __btn = _btn;
                    var googRange = self.getProcessor().createGoogRange();
                    if (googRange) {
                        self.fireJobs(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, googRange);
                    }
                    if (self.isWYSIWYG() && __btn == 1) {
                        self._SELECTION_RANGE = (googRange && googRange.browserRangeWrapper_ ? googRange.browserRangeWrapper_.range_ : null);
                    }
                }, 20);
            } catch (ignore) {}
        },

        onBlur: function(event) {
            try {
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_BLUR, event);
            } catch (ignore) {}
        },

        mayAttachmentChanged: _FALSE,

        onClick: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_CLICK, event);
        },

        onDoubleClick: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DBLCLICK, event);
        },

        onScroll: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_SCROLLING, event);
        },

        onPaste: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_PASTE_CUSTOM, event);
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_PASTE, event);
        },

        onDrop: function(event){
            if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; }
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DROP, event);
        },

        onFocus: function(event){
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_FOCUS, event);
        },

        onDragEnter: function(event){
            this.focus();
            if($tx.msie){
                if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }
                if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; }
            }
        },
        onDragOver: function(event){
            if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }
            if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; }
        },
        onDragLeave: function(event){
            if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }
            if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; }
        },

        onContextMenu: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_CONTEXTMENU_SHOW, event);
        },

        // TODO rename query status 라는 말 말고 다른 말 없을까?
        triggerQueryStatus: function() {
            this.cancelReservedQueryStatusTrigger();
            this.reserveQueryStatusTrigger();
        },

        reserveQueryStatusTrigger: function() {
            var self = this;
            this.reservedQueryStatusTrigger = setTimeout(function() {
                var googRange = self.getProcessor().createGoogRange();
                if (googRange) {
                    self.fireJobs(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, googRange);
                    self.fireElements(self.getProcessor().getNode());
                }
            }, 20); // IE의 경우 canvas.execute 에서 setTimeout 처리 하기 때문에, execute 뒤에 부르는 syncProperty가 그 뒤에 실행되게 하려고 20ms 딜레이 준다....
        },

        cancelReservedQueryStatusTrigger: function() {
            if (this.reservedQueryStatusTrigger) {
                clearTimeout(this.reservedQueryStatusTrigger);
            }
        },

        /**
         * @depreacated use canvas.triggerQueryStatus();
         */
        syncProperty: function() {
            this.triggerQueryStatus();
        }
    });

})(Trex);

Trex.module("bind canvas events for close external menus",
    function(editor, toolbar, sidebar, canvas /*, config*/ ) {
        var _shouldCloseMenus = function() {
            editor.fireJobs(Trex.Ev.__SHOULD_CLOSE_MENUS);
        };
        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, _shouldCloseMenus);
        canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, _shouldCloseMenus);
        canvas.observeJob(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, _shouldCloseMenus);
    }
);

Trex.module("make getter for 'iframeheight' and 'iframetop' size",
    function(editor, toolbar, sidebar, canvas /*, config*/ ) {
        var _iframeHeight = 0;
        var _iframeTop = 0;

        function resetIframeAttributes() {
            try {
                var _wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
                if (!(_wysiwygPanel && _wysiwygPanel.el && $("#" + _wysiwygPanel.el.id.replace(/\$/g, "\\$")).length != 0)) return;
                _iframeHeight = _wysiwygPanel.getPanelHeight().parsePx();
                var _position = $tom.getPosition(_wysiwygPanel.el);
                _iframeTop = _position.y;
            } catch (e) {}
        }

        // canvas resize
        canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(height) {
            resetIframeAttributes();
        });
        canvas.observeJob(Trex.Ev.__CANVAS_FULL_SCREEN_CHANGE, function() {
            resetIframeAttributes();
        });
        canvas.observeJob(Trex.Ev.__CANVAS_NORMAL_SCREEN_CHANGE, function() {
            resetIframeAttributes();
        });
        canvas.observeJob('canvas.apply.background', function() {
            resetIframeAttributes();
        });
        canvas.observeJob('canvas.apply.letterpaper', function() {
            resetIframeAttributes();
        });
        canvas.reserveJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
            resetIframeAttributes();
        }, 300);

        // attachbox change ui
        var attachbox = editor.getAttachBox();
        attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_SHOW, function() {
            resetIframeAttributes();
        });
        attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_HIDE, function() {
            resetIframeAttributes();
        });

        // window resize
        $tx.observe(_WIN, 'resize', function() {
            resetIframeAttributes();
        });

        // create interface
        canvas.getIframeHeight = function() {
            return _iframeHeight;
        };
        canvas.getIframeTop = function() {
            return _iframeTop;
        };
    }
);

Trex.module("sync attachment data periodically", function(editor, toolbar, sidebar, canvas /*, config*/ ) {
    // 사용 안함.
    // setTimeout(function() {
    //     setInterval(function() {
    //         if (canvas.mayAttachmentChanged) {
    //             // TODO 굳이 event 를 이용할 필요없이 바로 호출해줘도 될 것 같다.
    //             canvas.fireJobs(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING);
    //             canvas.mayAttachmentChanged = _FALSE;
    //         }
    //     }, 3000);
    // }, 10000);
});

Trex.module("synchronize the font style when caret is in end of paragraph", function(editor, toolbar, sidebar, canvas /*, config*/ ) {
    // only gecko #FTDUEDTR-1415
    $tx.gecko && canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev) {
        if (canvas.isWYSIWYG()) {
            var clickEl = ev.target;
            var isParagraph = clickEl instanceof HTMLParagraphElement;
            var isHtml = clickEl instanceof HTMLHtmlElement;
            if (!isParagraph && !isHtml) {
                return;
            }

            var processor = canvas.getProcessor();
            var x = ev.pageX,
                y = ev.pageY;

            var caret = processor.doc.caretPositionFromPoint(x, y);
            var node = caret && caret.offsetNode;
            var des = node && $tom.descendants(node, '#text');
            if (!des || !des.length) {
                return;
            }

            var lastTextNode = des[des.length - 1];
            if (lastTextNode) {
                var newRange = processor.createGoogRangeFromNodes(lastTextNode, lastTextNode.length, lastTextNode, lastTextNode.length);
                newRange.select();
            }
        }
    });
});

// FTDUEDTR-1431
Trex.module("apply respectVisibilityInDesign for old IE", function(editor, toolbar, sidebar, canvas, config) {
    var isOldIE = ($tx.msie && ($tx.msie_docmode < 9));
    isOldIE && canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function(oldMode, newMode) {
        changeVisibilityValue();
    });
    isOldIE && canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(ev) {
        changeVisibilityValue();
    });

    var COMMAND_API = 'RespectVisibilityInDesign';

    function changeVisibilityValue() {
        if (canvas.isWYSIWYG()) {
            var processor = canvas.getProcessor();
            var state = processor.doc.queryCommandState(COMMAND_API);
            var configFlag = canvas.config.respectVisibilityInDesign;

            if (state != configFlag) {
                processor.doc.execCommand(COMMAND_API, false, configFlag);
                // console.log('RespectVisibilityInDesign ', configFlag);
            }
        }
    }
});

/**
 * @fileOverview
 * 각 panel의 컨텐츠를 수정, 관리하기 위한 추상 클래스 관련 Source
 */

/**
 * 각 panel의 컨텐츠를 수정, 관리하기 위한 클래스로 <br/>
 * WysiwygPanel, HtmlPanel, TextPanel에서 상속받아 사용한다. <br/>
 *
 * @abstract
 * @class
 * @param {Object} canvas
 * @param {Object} config - canvas의 config
 */
Trex.Canvas.BasedPanel = Trex.Class.draft( /** @lends Trex.Canvas.BasedPanel.prototype */ {
    initialize: function(canvas, config) {
        this.config = config;
        this.canvas = canvas;

        this.elHolder = this.getHolder(config);
        this.el = this.getPanel(config);
        if (!this.el) {
            throw new Error("[Exception]Trex.Canvas.Panel : panel element is not founded");
        }

        var _name = this.constructor.__MODE;
        /**
         * panel의 이름을 리턴한다.
         * @function
         * @returns {String} 'html'
         */
        this.getName = function() { return _name; };

        this.lastHeight = _NULL;
    },
    /**
     * 컨텐츠 영역에 포커스를 준다.
     * @function
     */
    focus: function() {
        this.el.focus();
    },
    /**
     * panel을 보이게한다.
     * @function
     */
    show: function() {
        try {
            $tx.show(this.elHolder);
        } catch (e) {}
    },
    /**
     * panel을 감춘다.
     * @function
     */
    hide: function() {
        try {
            $tx.hide(this.elHolder);
        } catch (e) {}
    },
    /**
     * 스타일명으로 컨텐츠 영역의 스타일 값을 얻어온다.
     * @function
     * @param {String} name - 스타일명
     * @returns {String} 해당 스타일 값
     */
    getStyle: function(name) {
        if (this.el.style[name]) {
            return this.el.style[name];
        } else {
            return _NULL;
        }
    },
    /**
     * 컨텐츠 영역에 스타일을 적용한다.
     * @function
     * @param {Object} styles - 적용할 스타일
     */
    addStyle: function(styles) {
        for (var name in styles) {
            if (this.el.style[name]) {
                this.el.style[name] = styles[name];
            }
        }
    },
    /**
     * panel 영역의 x,y 위치와 넓이, 높이 값을 얻어온다.
     * @function
     * @returns {Object} position 객체 = {
     *								x: number,
     *								y: number,
     *								width: number,
     *								height: number
     *						}
     */
    getPosition: function() {
        return $tom.getPosition(this.el);
    },
    /**
     * panel 영역의 높이를 얻어온다.
     * @function
     * @returns {String} textarea 영역의 높이 (px)
     */
    getPanelHeight: function() {
        return $tom.getHeight(this.el).toPx();
    },
    /**
     * panel 영역의 높이를 셋팅한다.
     * @function
     * @param {Number} height - textarea 영역의 넓이 (px)
     */
    setPanelHeight: function(height) {
        height = height.toPx();
        if (this.lastHeight == height) {
            return;
        }
        $tom.setHeight(this.el, height);
        this.lastHeight = height;
    }
});


(function() {
    /**
     * WYSIWYG 편집 영역에 해당하는 <iframe> 을 초기화한다.
     * document.write 방식을 이용하여 iframe을 초기화 하며, 용
     * IE + document.domain 이 지정된 경우 document.domain 이 지정된 iframe(catalyst)을 먼저 로딩하여
     * iframe 에 접근가능하도록 처리 한 후, document.write 를 실행한다.
     * @private
     * @class
     */
    Trex.WysiwygIframeLoader = Trex.Class.create({
        initialize: function(iframe, iframeUrl, doctype) {
            this.iframe = iframe;
            this.iframeUrl = iframeUrl;
            this.doctype = '';
            switch (doctype) {
                case "edge":
                case "loose":
                case "strict":
                    this.doctype = doctype;
                    //			case "quirks":
            }
        },

        load: function(callback) {
            try {
                this.loadLocalIframe(callback, this.doctype);
            } catch (e) {
                this.reloadUsingCatalyst(callback);
            }
        },

        loadLocalIframe: function(callback, doctype) {
            var doc = this.iframe.contentWindow.document;
            doc.open();
            switch (doctype) {
                case "edge":
                    doc.write(DOCTYPE_edge);
                    break;
                case "loose":
                    doc.write(DOCTYPE_loose);
                    break;
                case "strict":
                    doc.write(DOCTYPE_strict);
                    break;
            }
            doc.write(wysiwygHTML);
            doc.close();
            // 하위 호환을 위하여 delay 처리한다. 기존 iframe observer 들이 loading 이 비동기라 가정하고 작성되어있다.
            setTimeout(function() {
                callback(doc);
            }, 0);
        },

        reloadUsingCatalyst: function(callback) {
            //console.log("retry with xss iframe catalyst");
            var self = this;
            _WIN.__tx_wysiwyg_iframe_load_complete = function() {
                self.loadLocalIframe(callback, ''); //이 시점에선 어차피 doctype 을 설정할 수 없음.
            };
            if (!this.iframeUrl) {
                var basePath = this.getIframePagePath();
                var doctype = this.doctype;
                switch (doctype) {
                    case "edge":
                    case "loose":
                    case "strict":
                        this.iframeUrl = basePath + "trex/iframe_loader_catalyst_" + doctype + ".html?open";
                        break;
                    default:
                        this.iframeUrl = basePath + "trex/iframe_loader_catalyst.html?open";
                }
            }

            var explicitDocumentDomain = (document.location.hostname != document.domain);
            if (explicitDocumentDomain) {
                this.iframeUrl = this.iframeUrl + ((this.iframeUrl.indexOf("?") > -1) ? "&" : "?") + "xssDomain=" + document.domain;
            }
            this.iframe.src = this.iframeUrl;
        },

        getIframePagePath: function() {
            return EditorJSLoader.getPageBasePath('editor.js');
        },

        // 옛날 스타일
        loadRemoteIframe: function() {
            var iframe = this.el;
            iframe.setAttribute("src", this.canvasConfig.wysiwygUrl);
        }
    });


    function absolutizeURL(url) {
        var location = _DOC.location;
        if (/^(https?:|file:|)\/\//.test(url)) {} else if (url.indexOf("/") === 0) {
            url = "//" + location.host + ":" + (location.port || "80") + url;
        } else {
            var href = location.href;
            var cutPos = href.lastIndexOf("/");
            url = href.substring(0, cutPos + 1) + url;
        }
        return url;
    }

    var cssBasePath = absolutizeURL(EditorJSLoader.getCSSBasePath());

    var DOCTYPE_edge = '<!DOCTYPE html>';
    var DOCTYPE_loose = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">';
    var DOCTYPE_strict = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">';

    var wysiwygHTML =
        '<html lang="ko"><head>' +
        '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">' +
        '<title>K-Portal Web Editor</title>' +
        '<script id="txScriptForEval"></script>' +
        '<link rel="stylesheet" href="' + cssBasePath + 'content_view' + (Trex._JS_MIN ? '.min' : '') + '.css?open&_ver=' + (EditorJSLoader._VER || '') + '" type="text/css"></link>' +
        '<link rel="stylesheet" href="' + cssBasePath + 'content_wysiwyg' + (Trex._JS_MIN ? '.min' : '') + '.css?open&_ver=' + (EditorJSLoader._VER || '') + '" type="text/css"></link>' +
        '<style id="txStyleForSetRule"></style>' +
        '</head>' +
        '<body class="tx-content-container">' +
        $tom.EMPTY_PARAGRAPH_HTML +
        '</body></html>';

})();

(function() {
    /**
     * 웹폰트를 로딩하기 위한 클래스로 WysiwygPanel 내부에서만 사용된다.
     * @private
     * @class
     */
    Trex.WebfontLoader = Trex.Class.create({
        initialize: function(doc, config) {
            this.doc = doc;
            this.styleCnt = 0;
            this.defWebfont = config.styles.fontFamily;
            this.useWebfont = (config.webfont && config.webfont.use);
            this.webfontCfg = config.webfont || [];
            this.elStyleSheet = this.getStyleSheet();
        },

        load: function(content) {
            if (!$tx.msie) {
                return;
            }
            if (!content) {
                return;
            }
            if (!this.useWebfont) {
                return;
            }

            var _matchs = [];
            content += " // font-family:" + this.defWebfont;
            content.replace(/font-family\s*:\s*(\w*)/gi, function(full, name) {
                _matchs.push(name);
                return full;
            });
            if (_matchs.length == 0) {
                return;
            }

            var _loader = this;
            setTimeout(function() {
                var _matchedSource = _matchs.uniq().join("||");
                _loader.webfontCfg.options.each(function(item) {
                    if (item.url && _matchedSource.indexOf(item.data) > -1) {
                        _loader.imports(item);
                    }
                });
            }, 10);
        },

        getUsed: function() {
            if (!$tx.msie) {
                return [];
            }
            var _result = [];
            if (!this.useWebfont) {
                return _result;
            }
            this.webfontCfg.options.each(function(item) {
                if (!item.url) {
                    _result.push(item.data);
                }
            });
            return _result;
        },

        getStyleSheet: function() {
            return this.doc.styleSheets[this.styleCnt++];
        },

        imports: function(item) {
            try {
                this.elStyleSheet.addImport(item.url, 2);
            } catch (e) {
                this.elStyleSheet = this.getStyleSheet();
                this.elStyleSheet.addImport(item.url, 2);
            }
            item.url = _NULL;
        }
    });
})();

(function() {
    var __SCROLL_WIDTH = 16;
    /**
     * wysiwyg 영역에서의 특정 노드의 상대 위치를 계산하기 위한 클래스로 WysiwygPanel 내부에서만 사용된다.
     * @private
     * @class
     */
    Trex.WysiwygRelative = Trex.Class.create({
        initialize: function(iframe) {
            this.iframe = iframe;
        },
        getRelative: function(node) {
            var _relatives = { x: 0, y: 0, width: 0, height: 0 };
            var doc = this.iframe.contentWindow.document;
            if (node) {
                var _position = $tom.getPosition(node, _TRUE);
                var _frameHeight = $tom.getHeight(this.iframe);
                var _scrollTop = $tom.getScrollTop(doc);

                if (_position.y + _position.height < _scrollTop || _position.y > _scrollTop + _frameHeight) {
                    return _relatives;
                } else {
                    var _frameLeft = 0; //Holder 기준
                    var _frameTop = 0; //Holder 기준
                    var _frameWidth = $tom.getWidth(this.iframe);
                    var _scrollLeft = $tom.getScrollLeft(doc);

                    _relatives.x = _frameLeft + ((_scrollLeft > 0) ? 0 : _position.x);
                    _relatives.width = Math.min(_frameWidth - _position.x - __SCROLL_WIDTH, _position.width - ((_scrollLeft > 0) ? _scrollLeft - _position.x : 0));
                    _relatives.height = _position.height;
                    _relatives.y = _position.y - _scrollTop + _frameTop;
                }
            }
            return _relatives;
        }
    });
})();

(function() {
    Trex.WysiwygEventBinder = Trex.Class.create({
        initialize: function(win, doc, canvas) {
            this.win = win;
            this.doc = doc;
            this.canvas = canvas;
        },

        bindEvents: function() {
            this.translateDocumentEventToCanvas("keyup", 'onKeyUp');
            this.translateDocumentEventToCanvas('keydown', 'onKeyDown');
            this.translateDocumentEventToCanvas('mouseover', 'onMouseOver');
            this.translateDocumentEventToCanvas('mousemove', 'onMouseMove');
            this.translateDocumentEventToCanvas('mouseout', 'onMouseOut');
            this.translateDocumentEventToCanvas('click', 'onClick');
            this.translateDocumentEventToCanvas('dblclick', 'onDoubleClick');
            this.translateDocumentEventToCanvas('mousedown', 'onMouseDown');
            this.translateDocumentEventToCanvas('mouseup', 'onMouseUp');
            this.translateDocumentEventToCanvas('contextmenu', 'onContextMenu');
            this.translateWindowEventToCanvas('scroll', 'onScroll');
            this.translateBodyEventToCanvas('paste', 'onPaste');

            this.translateBodyEventToCanvas('blur', 'onBlur');

            this.translateDocumentEventToCanvas('drop', 'onDrop');
            this.translateDocumentEventToCanvas('dragenter', 'onDragEnter');
            this.translateDocumentEventToCanvas('dragover', 'onDragOver');
            this.translateDocumentEventToCanvas('dragleave', 'onDragLeave');

            this.translateWindowEventToCanvas('focus', 'onFocus');

            this.triggerQueryStatusWhenTenConsecutiveKeyPressesDetected();
        },

        translateDocumentEventToCanvas: function(eventName, canvasMethodName) {
            this.translateEventToCanvas(this.doc, eventName, canvasMethodName);
        },

        translateWindowEventToCanvas: function(eventName, canvasMethodName) {
            this.translateEventToCanvas(this.win, eventName, canvasMethodName);
        },

        translateBodyEventToCanvas: function(eventName, canvasMethodName) {
            this.translateEventToCanvas(this.doc.body, eventName, canvasMethodName);
        },

        translateEventToCanvas: function(element, eventName, canvasMethodName) {
            var canvas = this.canvas;
            $tx.observe(element, eventName, function(e) {
                canvas[canvasMethodName](e);
            }, _FALSE);
        },

        triggerQueryStatusWhenTenConsecutiveKeyPressesDetected: function() {
            var canvas = this.canvas;
            observeTenConsecutiveKeyPresses(this.doc, function() {
                canvas.triggerQueryStatus();
            });
        }
    });

    var observeTenConsecutiveKeyPresses = function(element, handler) {
        var count = 0,
            previousKeyCode = -1,
            keyPressEvent = 'keydown'; //($tx.msie || $tx.webkit) ? "keydown" : "keypress";

        $tx.observe(element, keyPressEvent, function(event) {
            var newKeyCode = event.keyCode;
            if (!shouldIgnore(newKeyCode) && previousKeyCode !== newKeyCode) {
                if (count >= 9) {
                    handler();
                    count = 0;
                } else {
                    count++;
                }
                previousKeyCode = newKeyCode;
            }
        }, _FALSE);
    };

    var shouldIgnore = function(keyCode) {
        return QUERY_TRIGGER_IGNORE_KEYCODES.contains(keyCode);
    };

    var QUERY_TRIGGER_IGNORE_KEYCODES = new $tx.Set(8, 16, 17, 18, 32, 33, 34, 37, 38, 39, 40, 46, 229 /* hangul */ );

})();


(function() {
    /**
     * wysiwyg 영역의 컨텐츠를 수정, 관리하기 위한 클래스로,
     * 편집 영역에 해당하는 iframe 객체에 접근하여 이벤트를 부여하거나 속성 값들을 읽거나 변경한다.
     *
     * @class
     * @extends Trex.Canvas.BasedPanel
     * @param {Object} canvas
     * @param {Object} config - canvas의 config
     */
    Trex.Canvas.WysiwygPanel = Trex.Class.create( /** @lends Trex.Canvas.WysiwygPanel.prototype */ {
        /** @ignore */
        $extend: Trex.Canvas.BasedPanel,


        /** @ignore */
        $const: {
            /** @name Trex.Canvas.WysiwygPanel.__MODE */
            __MODE: Trex.Canvas.__WYSIWYG_MODE,
            EVENT_BINDING_DELAY: 500
        },


        initialize: function(canvas, canvasConfig) {
            this.$super.initialize(canvas, canvasConfig);

            this.canvasConfig = canvasConfig;
            this.iframe = this.el;
            this.wysiwygWindow = this.iframe.contentWindow;
            this.onceWysiwygFocused = false;

            var self = this;
            var iframeLoader = new Trex.WysiwygIframeLoader(this.iframe, canvasConfig.wysiwygCatalystUrl, canvasConfig.doctype);
            iframeLoader.load(function(doc) {
                self.wysiwygDoc = doc;
                self.initializeSubModules(doc);
                installHyperscript(self.wysiwygWindow, self.wysiwygDoc);
                self.makeEditable();
                self.applyBodyStyles(self.canvasConfig.styles);
                self.applyCustomCssText(self.canvasConfig.customCssText);
                self.clearContent();
                self.bindEvents(canvas);
                Editor.__PANEL_LOADED = _TRUE;
                $tx.observe(self.wysiwygWindow, 'focus', function onWysiwygFocused() {
                    if (!self.onceWysiwygFocused) {
                        self.onceWysiwygFocused = true;
                    }
                });
                if ($tx.msie_nonstd) {
                    var htmlEl = self.wysiwygDoc.getElementsByTagName('html');
                    if (htmlEl && htmlEl[0]) {
                        $tx.observe(htmlEl[0], 'click', function(event) {
                            var target = $tx.element(event);
                            if (canvas.canHTML() && htmlEl[0] == target) {
                                self.focus();
                            }
                        });
                    }
                }
                canvas.fireJobs(Trex.Ev.__IFRAME_LOAD_COMPLETE, doc);

            });

        },
        _bodyHeight: 0,
        _bodyContentHeight: 0,

        initializeSubModules: function(doc) {
            var win = this.wysiwygWindow;
            this.processor = new Trex.Canvas.ProcessorP(win, doc);
            this.webfontLoader = new Trex.WebfontLoader(doc, this.canvasConfig);
        },


        /**
         * WYSIWYG 영역 iframe을 편집 가능한 상태로 변경한다.
         */
        makeEditable: function() {
            if (this.canvasConfig.readonly) {
                return;
            }

            if (this.wysiwygDoc.body.contentEditable) {
                this.wysiwygDoc.body.contentEditable = _TRUE;
            } else {
                var self = this;
                setTimeout(function() {
                    try {
                        self.wysiwygDoc.designMode = "On";
                        if ($tx.gecko) {
                            self.wysiwygDoc.execCommand("enableInlineTableEditing", _FALSE, _FALSE);
                        }
                    } catch (e) {
                        self.designModeActivated = _FALSE;
                    }
                }, 10);
            }
        },

        /**
         * panel의 이름을 리턴한다.
         * @function
         * @returns {String} 'html'
         */
        getName: function() {
            return this.constructor.__MODE;
        },


        /**
         * wysiwyg 영역의 window 객체를 넘겨준다.
         * @function
         * @returns {Element} wysiwyg 영역의 window 객체
         */
        getWindow: function() {
            return this.wysiwygWindow;
        },


        /**
         * wysiwyg 영역의 document 객체를 넘겨준다.
         * @function
         * @returns {Element} wysiwyg 영역의 document 객체
         */
        getDocument: function() {
            return this.wysiwygDoc;
        },


        /**
         * wysiwyg 영역에 쓰여진 컨텐츠를 얻어온다.
         * @function
         * @returns {String} 컨텐츠 문자열
         */
        getContent: function() {
            return this.wysiwygDoc.body.innerHTML;
        },


        /**
         * wysiwyg 영역의 컨텐츠를 주어진 문자열로 수정한다.
         * @function
         * @param {String} contentHTML - 컨텐츠
         */
        setContent: function(contentHTML) {
            contentHTML = this.doPreFilter(contentHTML);
            this.setBodyHTML(contentHTML);
            this.doPostFilter(this.wysiwygDoc.body);
        },

        doPreFilter: function(contentHTML) {
            if (contentHTML) {
                contentHTML = removeWordJoiner(contentHTML);
                contentHTML = preventRemovingNoScopeElementInIE(contentHTML);
            }
            return contentHTML;
        },

        setBodyHTML: function(content) {
            this.wysiwygDoc.body.innerHTML = content || $tom.EMPTY_PARAGRAPH_HTML;
        },

        doPostFilter: function(body) {
            makeEmptyParagraphVisibleInIE(body);
        },


        /**
         * 편집 문서 body의 HTML을 모두 지우고 기본 마크업을 세팅한다.
         */
        clearContent: function() {
            this.setContent("");
        },


        /**
         * 현재 wysiwyg 영역의 수직 스크롤 값을 얻어온다.
         * @function
         * @returns {Number} 수직 스크롤 값
         */
        getScrollTop: function() {
            return $tom.getScrollTop(this.wysiwygDoc);
        },


        /**
         * wysiwyg 영역의 수직 스크롤 값을 셋팅한다.
         * @function
         * @param {Number} scrollTop - 수직 스크롤 값
         */
        setScrollTop: function(scrollTop) {
            $tom.setScrollTop(this.wysiwygDoc, scrollTop);
        },


        /**
         * 현재 wysiwyg 영역의 수평 스크롤 값을 얻어온다.
         * @function
         * @returns {Number} 수평 스크롤 값
         */
        getScrollLeft: function() {
            return $tom.getScrollLeft(this.wysiwygDoc);
        },


        /**
         * 생성된 Processor 객체를 리턴한다.
         * @function
         * @returns {Object} Processor 객체
         */
        getProcessor: function() {
            return this.processor;
        },


        /**
         * 만약 processor 객체가 준비되었다면 processor 객체를 argument로 넘기며 주어진 함수를 수행한다.
         * @param fn {function} processor 객체를 argument로 받아 실행할 함수
         */
        ifProcessorReady: function(fn) {
            if (this.processor) {
                fn(this.processor);
            }
        },


        /**
         * 스타일명으로 wysiwyg 영역의 스타일 값을 얻어온다.
         * @function
         * @param {String} name - 스타일명
         * @returns {String} 해당 스타일 값
         */
        getStyle: function(name) {
            return $tx.getStyle(this.wysiwygDoc.body, name);
        },


        /**
         * wysiwyg 영역에 스타일을 적용한다.
         * @function
         * @param {Object} styles - 적용할 스타일
         */
        addStyle: function(styles) {
            $tx.setStyleProperty(this.wysiwygDoc.body, styles);
        },


        /**
         * 주어진 문서의 body element 에 CSS 속성을 지정한다. 단 폰트 관련 속성은 제외한다.
         * @param doc {HTMLDocument}
         * @param styles {Object} key: value 형태의 CSS property 모음
         */
        setBodyStyle: function(doc, styles) {
            var excluded = excludeNotAllowed(styles);
            $tx.setStyleProperty(doc.body, excluded);
        },


        /**
         * 주어진 문서에 폰트 관련 CSS 속성을 지정한다
         * @param doc {HTMLDocument}
         * @param styles {Object} key: value 형태의 CSS property 모음
         */
        setFontStyle: function(doc, styles) {
            var extendedStyles = Object.extend(styles, {
                'browser': $tx.browser,
                'pMarginZero': this.canvasConfig.pMarginZero ? "true" : "false"
            });
            var cssText = new Template([
                "#{if:pMarginZero=='true'}p { margin:0; padding:0; }#{/if:pMarginZero}",
                "body, td, button { color:#{color}; font-size:#{fontSize}; font-family:#{fontFamily}; line-height:#{lineHeight}; }",
                /*"a, a:hover, a:link, a:active, a:visited { color:#{color}; }",*/
                "div.txc-search-border { border-color:#{color}; }",
                "div.txc-search-opborder { border-color:#{color}; }",
                "img.tx-unresizable { width: auto !important; height: auto !important; }",
                "button a { text-decoration:none #{if:browser=='firefox'}!important#{/if:browser}; color:#{color} #{if:browser=='firefox'}!important#{/if:browser}; }"
            ].join("\n")).evaluate(extendedStyles);
            $tx.applyCSSText(doc, cssText);
        },


        applyBodyStyles: function(styles) {
            var doc = this.wysiwygDoc;
            try {
                this.setFontStyle(doc, styles);
                this.setBodyStyle(doc, styles);
            } catch (e) {}
        },

        applyCustomCssText: function(cssText) {
            if (!cssText) {
                return;
            }
            var doc = this.wysiwygDoc;
            try {
                $tx.applyCSSText(doc, cssText);
            } catch (ignore) {}
        },

        setRule: function(selector, value) {
            var styleElem, sheet, rules;
            try {
                styleElem = this.wysiwygDoc.getElementById("txStyleForSetRule");
                sheet = styleElem.sheet ? styleElem.sheet : styleElem.styleSheet;
                rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                if (sheet.insertRule) { // all browsers, except IE before version 9
                    if (0 < rules.length) {
                        sheet.deleteRule(0);
                    }
                    if (selector) {
                        sheet.insertRule(selector + "{" + value + "}", 0);
                    }
                } else { // Internet Explorer before version 9
                    if (sheet.addRule) {
                        if (0 < rules.length) {
                            sheet.removeRule(0);
                        }
                        if (selector) {
                            sheet.addRule(selector, value, 0);
                        }
                    }
                }
            } catch (ignore) {}
        },

        /**
         * iframe에서 발생하는 각종 event 들을 observing 하기 시작한다.
         */
        bindEvents: function(canvas) {
            var eventBinder = new Trex.WysiwygEventBinder(this.wysiwygWindow, this.wysiwygDoc, canvas, this.processor);
            setTimeout(function() {
                eventBinder.bindEvents();
            }, this.constructor.EVENT_BINDING_DELAY); // why delay 500ms?
        },

        /**
         * panel 엘리먼트를 가지고 온다.
         * @function
         */
        getPanel: function(config) {
            var id = config.initializedId || "";
            return $must("tx_canvas_wysiwyg" + id, "Trex.Canvas.WysiwygPanel");
        },
        //#1454
        setHeightBody: function(height) {
            var body = this.wysiwygWindow.document.body;
            var _config = this.config.styles;
            var margin_top = (_config.marginTop?parseInt(_config.marginTop):_config.margin?parseInt(_config.margin):parseInt($tx.getStyle(body, 'margin-top')));
            var padding_top = (_config.paddingTop?parseInt(_config.paddingTop):_config.padding?parseInt(_config.padding):parseInt($tx.getStyle(body, 'padding-top')));
            var marginPaddingTop =  margin_top + padding_top;
            var margin_bottom = (_config.marginBottom?parseInt(_config.marginBottom):_config.margin?parseInt(_config.margin):parseInt($tx.getStyle(body, 'margin-bottom')));
            var padding_bottom = (_config.paddingBottom?parseInt(_config.paddingBottom):_config.padding?parseInt(_config.padding):parseInt($tx.getStyle(body, 'padding-bottom')));
            var marginPaddingBottom = margin_bottom + padding_bottom;
            height = parseInt(height) - marginPaddingTop - marginPaddingBottom;
            body.style.height = height.toPx();
            this._bodyHeight = height;
        },

        setPanelHeight: function(height) {
            var self = this;
            function timesTry(n) {
                if (n === 0) return;
                try {
                    self.setHeightBody(height);
                } catch (e) {
                    setTimeout(timesTry.bind(this, n - 1), 30);
                }
            }
            //초기화 중에 body가 초기화 되지 않았기 때문에 body가 오류날 확률이 있음. 10번 시도 하는 로직 추가
            timesTry(10);
            self.$super.setPanelHeight(height);
        },


        /**
         * panel 엘리먼트를 감싸고 있는 wrapper 엘리먼트를 가지고 온다.
         * @function
         */
        getHolder: function(config) {
            var id = config.initializedId || "";
            return $must("tx_canvas_wysiwyg_holder" + id, "Trex.Canvas.WysiwygPanel");
        },


        /**
         * wysiwyg 영역에 포커스를 준다.
         * @function
         */
        focus: function() {
            this.ifProcessorReady(function(processor) {
                processor.focus();
            });
        },

        ensureFocused: function() {
            if (!this.onceWysiwygFocused) {
                this.onceWysiwygFocused = true;
                this.focus();
            }
        },

        /**
         * wysiwyg panel을 보이게한다.
         * @function
         */
        show: function() {
            this.$super.show();
            this.ifProcessorReady(function(processor) {
                setTimeout(function() {
                    try {
                        processor.focusOnTop(); //한메일에서 모드 변경시 focus 제일 위로 가게함.. (주의: 현재 다른 서비스는 Bottom 으로 되어있음)
                    } catch (e) {}
                }, 100);
            });
        },


        /**
         * wysiwyg panel을 감춘다.
         * @function
         */
        hide: function() {
            this.ifProcessorReady(function(processor) {
                processor.blur();
            });
            this.$super.hide();
        },


        /**
         * 컨텐츠를 파싱하여 사용되고 있는 웹폰트가 있으면, 웹폰트 css를 로딩한다.<br/>
         * 로딩속도를 향상시키기 위해 본문을 파싱하여 웹폰트를 사용할 경우에만 동적으로 웹폰트 CSS를 호출한다.
         * @function
         * @param {String} content - 컨텐츠
         */
        includeWebfontCss: function(content) {
            this.webfontLoader.load(content);
        },


        /**
         * 본문에 사용된 웹폰트명 목록을 리턴한다.
         * @function
         * @returns {Array} 사용하고 있는 웹폰트명 목록
         */
        getUsedWebfont: function() {
            return this.webfontLoader.getUsed();
        },


        /**
         * 특정 노드의 wysiwyg 영역에서의 상대 위치를 얻어온다.
         * @function
         * @param {Element} node - 특정 노드
         * @returns {Object} position 객체 { x: number, y: number, width: number, height: number }
         */
        getPositionByNode: function(node) {
            var wysiwygRelative = new Trex.WysiwygRelative(this.iframe);
            return wysiwygRelative.getRelative(node);
        }
    });

    function excludeNotAllowed(style) {
        var notAllowed = ["color", "fontSize", "fontFamily", "lineHeight", "pMarginZero", "browser"];
        var excluded = Object.clone(style);
        for (var i = 0; i < notAllowed.length; i++) {
            delete excluded[notAllowed[i]];
        }
        return excluded;
    }

    function removeWordJoiner(content) {
        return content.replace(Trex.__WORD_JOINER_REGEXP, "");
    }

    /*
     * NOTE: FTDUEDTR-900
     */
    function preventRemovingNoScopeElementInIE(markup) {
        if ($tx.msie) {
            markup = markup.replace(/(<script|<style)/i, Trex.__WORD_JOINER + "$1");
        }
        return markup;
    }

    /*
     * IE에서 빈 p 엘리먼트는 높이를 갖지 않고 화면에 표시되지 않는다. 따라 빈 문단 표시를 위하여 <P>&nbsp;</P> 를
     * 사용하는 데, 편집시에는 &nbsp;가 빈칸 한칸으로서 자리를 차지하여 걸리적 거리므로 이를 제거하여 준다.
     * 이와 같이 contentEditable 환경에서 &nbsp; 를 주었다가 빼면 빈 엘리먼트임에도 불구하고 문단으로서 높이를 유지한다.
     *
     * 의문 1.
     *  그런데 LI는 왜 하는 걸까 -_-^
     * 의문 2.
     *	<P></P> 를 하나의 문단으로 여기고 높이를 잡아주는 게 맞을까? 글 조회시에는 표시 되지 않을텐데...
     *	편집시와 조회시 불일치 발생한다.
     *	참고 이슈 #FTDUEDTR-1121
     * 의문 3.
     *	저장시 빈 문단에 &nbsp;를 다시 넣어주는 듯 한데, 어디서 해주는 걸까
     * @param body
     */
    function makeEmptyParagraphVisibleInIE(body) {
        if ($tx.msie_nonstd) {
            var pNodes = $tom.collectAll(body, 'p,li');
            for (var i = 0, len = pNodes.length; i < len; i++) {
                var node = pNodes[i];
                if ($tom.getLength(node) === 0 && node.tagName.toLowerCase() !== 'p') { //#FTDUEDTR-1121
                    try {
                        node.innerHTML = '&nbsp;';
                    } catch (ignore) {}
                }
                if ($tom.getLength(node) === 1 && node.innerHTML === '&nbsp;') {
                    node.innerHTML = '';
                }
            }
        }
    }
})();

Trex.module("canvas set focus on mousedown event. only IE.",
    function(editor, toolbar, sidebar, canvas, config) {
        if (!$tx.msie_std) {
            return;
        }

        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev) {
            if ($tx.isLeftClick(ev)) {
                var tagName = $tx.element(ev).tagName;
                if (tagName.toLocaleLowerCase() == 'html') {
                    canvas.focusOnBottom();
                }
            }
        });
    });

Trex.module("auto body resize",
    function(editor, toolbar, sidebar, canvas, config) {
        canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
            var beforeHTML = '';
            var bodyHeight = 0;
            var _panel = canvas.getPanel('html');
            bodyHeight = _panel._bodyHeight;
            var _intervalId = null;
            var _checkCount = 30; // 열고 30초 뒤부터 
            canvas.observeJob('canvas.height.change', function(h) {
                bodyHeight = parseInt(_panel._bodyHeight);
            });
            var paddingTB = 16;
            try{paddingTB = parseInt(this.config.styles.padding, 10) * 2;}catch(e){}
            function _clear() {
                try {
                    delete Editor.__MULTI_LIST[editor.kEditor.instanceId];
                } catch (e) {}
                if (canvas && canvas.history) {
                    canvas.history.undoMementoList = [];
                    canvas.history.redoMementoList = [];
                    canvas.history.undoMementoList = null;
                    canvas.history.redoMementoList = null;
                    try {
                        canvas.history.currentMemento.before.content = null;
                        canvas.history.currentMemento.before = null;
                    } catch (ei) {}
                    try {
                        canvas.history.currentMemento.after.content = null;
                        canvas.history.currentMemento.after = null;
                    } catch (ei) {}
                    canvas.history.currentMemento = null;
                    canvas.history = null;
                }
                try { delete canvas.jobObservers } catch (e) {}
                try { delete canvas.keyObservers } catch (e) {}
                _panel.el = _panel.elHolder = _panel.iframe = _panel.wysiwygWindow = _panel.wysiwygDoc = _panel.canvas = null;
                canvas.elContainer = canvas.wysiwygEl = canvas.sourceEl = canvas.textEl = canvas.elEditorBlockUI = null;
                beforeHTML = '';
            }

            function _resize() {
                try {
                    _checkCount--;
                    if (_checkCount == 0) {
                        if (editor && editor.kEditor && $('#tx_trex_container' + editor.kEditor.eInstanceId).length == 0) {
                            clearInterval(_intervalId);
                            _clear();
                            return;
                        }
                        _checkCount = 10; // 10초 간격으로
                    }
                    if (!canvas.isWYSIWYG()) return;
                    var _doc = _panel.getDocument();
                    var _body = _doc.body;
                    // var _html = _body.innerHTML;
                    // if(beforeHTML === _html) return;
                    // beforeHTML = _html;
                    // _body.style.height = '';
                    var _h = _body.scrollHeight; //$tx.getDimensions(_body).height;
                    _panel._bodyContentHeight = _h;
                    _h -= paddingTB; // 위 아래 padding
                    if (_h <= bodyHeight) {
                        _body.style.height = bodyHeight.toPx();
                    } else {
                        _body.style.height = '';
                    }
                } catch (e) {
                    clearInterval(_intervalId);
                }
            }
            _intervalId = setInterval(_resize, 1000);
        });
    }
);




/**
 * @fileOverview
 * 이 클래스는 BasedPanel 을 상속받는다.
 * 또한 TextPanel 과 HtmlPanel 가 이 클래스를 상속한다.
 */

/**
 * TextareaPanel
 *
 * @class
 * @extends Trex.Canvas.BasedPanel
 * @param {Object} canvas
 * @param {Object} config - canvas의 config
 */
Trex.Canvas.TextareaPanel = Trex.Class.create( /** @lends Trex.Canvas.TextareaPanel.prototype */ {
    /** @ignore */
    $extend: Trex.Canvas.BasedPanel,
    /** @ignore */
    initialize: function(canvas, config) {
        this.$super.initialize(canvas, config);

        var _processor = new Trex.Canvas.TextAreaProcessor(this.el);
        /**
         * 생성된 Processor 객체를 리턴한다.
         * @function
         * @returns {Object} Processor 객체
         */
        this.getProcessor = function() {
            return _processor;
        };

        this.lastHeight = (this.lastHeight - 9 * 2).toPx(); //"382px";
        if (!!config.readonly) {
            this.setReadOnly();
        }
    },
    /**
     * panel을 보이게한다.
     * @function
     */
    show: function() {
        this.$super.show();
        var _elHolder = this.elHolder;
        var _processor = this.getProcessor();
        setTimeout(function() {
            try {
                _processor.focusOnTop(); //모드 변경시 focus 제일 위로 가게함..
            } catch (ignore) {}
            if ($tx.msie6) { //NOTE: #FTDUEDTR-174
                _elHolder.style.padding = "1px";
                setTimeout(function() {
                    _elHolder.style.padding = "0px";
                }, 0);
            }
        }, 100);
    },
    /**
     * 컨텐츠 영역의 컨텐츠를 주어진 문자열로 수정한다.
     * @function
     * @param {String} content - 컨텐츠
     */
    setContent: function(content) {
        this.el.value = content;
    },
    /**
     * 컨텐츠 영역에 쓰여진 컨텐츠를 얻어온다.
     * @function
     * @returns {String} 컨텐츠 문자열
     */
    getContent: function() {
        return this.el.value;
    },
    /**
     * panel 영역의 높이를 얻어온다.
     * @function
     * @returns {String} textarea 영역의 높이 (px)
     */
    getPanelHeight: function() {
        return ($tom.getHeight(this.el).parsePx() + 2).toPx();
    },
    /**
     * panel 영역의 높이를 셋팅한다.
     * @function
     * @param {Number} width - textarea 영역의 넓이 (px)
     */
    setPanelHeight: function(height) {
        this.$super.setPanelHeight((height.parsePx() - 2).toPx());
    },
    /**
     * panel의 readonly를 속성을 setting함으로써 글쓰기를 제한한다.
     * @function
     */
    setReadOnly: function() {
        this.el.readOnly = _TRUE;
    }
});

/**
 * @fileOverview
 * Textarea (source, text) 영역의 컨텐츠를 수정, 관리하기 위한 HtmlPanel 관련 Source
 */

/**
 * HTML모드(소스모드)의 컨텐츠를 수정, 관리하기 위한 클래스
 *
 * @class
 * @extends Trex.Canvas.BasedPanel
 * @param {Object} canvas
 * @param {Object} config - canvas의 config
 */
Trex.Canvas.HtmlPanel = Trex.Class.create( /** @lends Trex.Canvas.HtmlPanel.prototype */ {
    /** @ignore */
    $extend: Trex.Canvas.TextareaPanel,
    /** @ignore */
    $const: {
        /** @name Trex.Canvas.HtmlPanel.__MODE */
        __MODE: Trex.Canvas.__HTML_MODE
    },
    initialize: function(canvas, config) {
        this.$super.initialize(canvas, config);
        this.bindEvents();

        if ($tx.msie_ver == '8') { //NOTE: #FTDUEDTR-963
            this.el.setAttribute('style', 'width: 500px; min-width: 100%; max-width: 100%;');
        }
        if (!config.styles.notApplyBgColorOnSourceMode) {
            if (config.styles.backgroundColor) {
                $tx.setStyle(this.el, {
                    backgroundColor: config.styles.backgroundColor
                });
            }
            if (config.styles.color) {
                $tx.setStyle(this.el, {
                    color: config.styles.color
                });
            }
        }
    },
    bindEvents: function() {
        var _handlers = {
            keydown: function(ev) {
                this.canvas.fireJobs(Trex.Ev.__CANVAS_SOURCE_PANEL_KEYDOWN, ev);
            },
            keyup: function() {
                var processor = this.canvas.getProcessor();
                if (processor && processor.savePosition) {
                    processor.savePosition();
                }
            },
            mousedown: function(ev) {
                this.canvas.fireJobs(Trex.Ev.__CANVAS_SOURCE_PANEL_MOUSEDOWN, ev);
            },
            mouseup: function() {
                var processor = this.canvas.getProcessor();
                if (processor && processor.savePosition) {
                    processor.savePosition();
                }
            },
            click: function(ev) {
                this.canvas.fireJobs(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, ev);
            }
        };
        for (var _eventType in _handlers) {
            $tx.observe(this.el, _eventType, _handlers[_eventType].bind(this), _TRUE);
        }
    },
    /**
     * panel 엘리먼트를 가지고 온다.
     * @function
     */
    getPanel: function(config) {
        var _initializedId = ((config.initializedId) ? config.initializedId : "");
        return $must("tx_canvas_source" + _initializedId, "Trex.Canvas.HtmlPanel");
    },
    /**
     * panel 엘리먼트를 감싸고 있는 wrapper 엘리먼트를 가지고 온다.
     * @function
     */
    getHolder: function(config) {
        var _initializedId = ((config.initializedId) ? config.initializedId : "");
        return $must("tx_canvas_source_holder" + _initializedId, "Trex.Canvas.HtmlPanel");
    },
    /**
     * 컨텐츠 영역의 컨텐츠를 주어진 문자열로 수정한다.
     * @function
     * @param {String} content - 컨텐츠
     */
    setContent: function(content) {
        var validator = new Trex.Validator();
        if (validator.exists(content)) {
            this.$super.setContent(content);
        } else {
            this.$super.setContent("");
        }
    }
});

/**
 * @fileOverview
 * Textarea (source, text) 영역의 컨텐츠를 수정, 관리하기 위한 TextPanel 관련 Source
 */

/**
 * 텍스트모드의 컨텐츠를 수정, 관리하기 위한 클래스
 *
 * @class
 * @extends Trex.Canvas.BasedPanel
 * @param {Object} canvas
 * @param {Object} config - canvas의 config
 */
Trex.Canvas.TextPanel = Trex.Class.create( /** @lends Trex.Canvas.TextPanel.prototype */ {
    /** @ignore */
    $extend: Trex.Canvas.TextareaPanel,
    /** @ignore */
    $const: {
        /** @name Trex.Canvas.TextPanel.__MODE */
        __MODE: Trex.Canvas.__TEXT_MODE
    },
    initialize: function(canvas, config) {
        this.$super.initialize(canvas, config);
        this.bindEvents();
    },
    bindEvents: function() {
        var _handlers = {
            keydown: function() {},
            keyup: function() {},
            mousedown: function() {},
            mouseup: function() {},
            click: function(ev) {
                this.canvas.fireJobs(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, ev);
            }
        };
        for (var _eventType in _handlers) {
            $tx.observe(this.el, _eventType, _handlers[_eventType].bind(this), _TRUE);
        }
    },
    /**
     * panel 엘리먼트를 가지고 온다.
     * @function
     */
    getPanel: function(config) {
        var _initializedId = ((config.initializedId) ? config.initializedId : "");
        return $must("tx_canvas_text" + _initializedId, "Trex.Canvas.TextPanel");
    },
    /**
     * panel 엘리먼트를 감싸고 있는 wrapper 엘리먼트를 가지고 온다.
     * @function
     */
    getHolder: function(config) {
        var _initializedId = ((config.initializedId) ? config.initializedId : "");
        return $must("tx_canvas_text_holder" + _initializedId, "Trex.Canvas.TextPanel");
    }
});

Trex.module("interrupt enter key action @ text panel",
    function(editor, toolbar, sidebar, canvas) {
        var _newlinepolicy = canvas.config.newlinepolicy;
        var _insertbr = canvas.config.insertbr;
        if (_newlinepolicy == "br" && _insertbr) {
            canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_KEYDOWN, function(ev) {
                if (canvas.isWYSIWYG()) {
                    return;
                }
                canvas.getProcessor().controlEnter(ev);
            });
        }
    }
);


/**
 * @fileOverview
 * Wysiwyg 영역의 DOM 조작을 하기전에 선택된 영역의 시작과 끝에 marker를 삽입하여
 * DOM 조작을 보다 용이하게 하는 객체로 Processor#execWithMarker 에서 사용된다.
 */
Trex.I.Marker = {};

Trex.I.Marker.Standard = /** @lends Trex.Canvas.Marker.prototype */ {
    /**
     * 선택된 영역의 시작과 끝에 marker를 삽입한다.
     * @example
     * 	marker.paste();
     */
    paste: function() {
        var _rng = this.processor.getRange();

        var _endContainer = _rng.endContainer;
        var _startContainer = _rng.startContainer;
        if (_endContainer.nodeType == 9) { //NOTE: #FTDUEDTR-919
            _endContainer = this.processor.doc.body;
            _startContainer = this.processor.doc.body;
        }

        var _endMarker = this.endMarker = this.processor.create('span', { id: "tx_end_marker" });
        var _endOffset = _rng.endOffset;

        if (_endContainer.nodeType == 3) {
            _endContainer.splitText(_endOffset);
            _endContainer.parentNode.insertBefore(_endMarker, _endContainer.nextSibling);
        } else {
            _endContainer.insertBefore(_endMarker, _endContainer.childNodes[_endOffset]);
        }

        var _startMarker = this.startMarker = this.processor.create('span', { id: "tx_start_marker" });
        var _startOffset = _rng.startOffset;

        if (_startContainer.nodeType == 3) {
            _startContainer.splitText(_startOffset);
            _startContainer.parentNode.insertBefore(_startMarker, _startContainer.nextSibling);
        } else {
            _startContainer.insertBefore(_startMarker, _startContainer.childNodes[_startOffset]);
        }
    },
    /**
     * 삽입된 마커를 제거한다.
     * @example
     * 	marker.remove();
     */
    remove: function() {
        $tom.remove(this.startMarker);
        $tom.remove(this.endMarker);
    }
};


Trex.I.Marker.Trident = /** @lends Trex.Canvas.Marker.prototype */ {
    /**
     * 선택된 영역의 시작과 끝에 marker를 삽입한다.
     * @example
     * 	marker.paste();
     */
    paste: function() {
        this.clear();

        var _rng = this.processor.getRange();
        var _cnxt = this.processor.doc.body;

        var _rng1 = _rng.duplicate();
        _rng1.collapse(_TRUE);
        _rng1.pasteHTML('<span id="tx_start_marker"></span>');
        this.startMarker = $tom.collect(_cnxt, '#tx_start_marker');

        var _rng2 = _rng.duplicate();
        _rng2.collapse(_FALSE);
        _rng2.pasteHTML('<span id="tx_end_marker"></span>');
        this.endMarker = $tom.collect(_cnxt, '#tx_end_marker');
    },
    /**
     * @private
     * 기존에 삽입된 마커를 모두 제거한다.
     * @example
     * 	marker.remove();
     */
    clear: function() {
        var _cnxt = this.processor.doc.body;
        $tom.remove($tom.collect(_cnxt, '#tx_start_marker'));
        $tom.remove($tom.collect(_cnxt, '#tx_end_marker'));
    },
    /**
     * 삽입된 마커를 제거한다.
     * @example
     * 	marker.remove();
     */
    remove: function() {
        $tom.remove(this.startMarker);
        $tom.remove(this.endMarker);
    }
};

/**
 * Wysiwyg 영역의 DOM 조작을 하기전에 선택된 영역의 시작과 끝에 marker를 삽입하여  <br/>
 * DOM 조작을 보다 용이하게 하는 객체로  <br/>
 * browser에 따라 필요한 함수들을 mixin한다. <br/>
 * Processor#execWithMarker 에서만 사용된다.<br/>
 *
 * @example
 * 		var _marker = new Trex.Canvas.Marker(processor);
 *		processor.bookmarkTo();
 *		try {
 *			_marker.paste();
 *			_marker.backup();
 *			handler(_marker);
 *		} catch(e) {
 *		} finally {
 *			_marker.remove();
 *		}
 * @class
 * @param {Object} processor - Processor 객체
 */
Trex.Canvas.Marker = Trex.Class.create( /** @lends Trex.Canvas.Marker.prototype */ {
    /** @ignore */
    $mixins: [
        (($tx.msie_nonstd) ? Trex.I.Marker.Trident : Trex.I.Marker.Standard)
    ],
    initialize: function(processor) {
        this.processor = processor;
    },
    /**
     * 마커를 삽입한 후 북마크를 수정한다.
     * @example
     * 	marker.backup();
     */
    backup: function() {
        this.processor.bookmarkWithMarker(this);
    },
    /**
     * @private
     * 선택된 영역이 collapse인지 여부를 리턴한다.
     * @returns {Boolean} - 선택된 영역이 collapse인지 여부
     * @example
     * 	marker.checkCollapsed();
     */
    checkCollapsed: function() {
        return ($tom.next(this.startMarker) == this.endMarker); //collapsed
    }
});



/**
 * @fileOverview
 * native selection, range 객체를 wrapping 한 객체로 Processor 에서 주로 사용된다.
 */
Trex.I.Selection = {};
Trex.I.Selection.Standard = /** @lends Trex.Canvas.Selection.prototype */ {
    /**
     * native selection object를 리턴한다.
     * @returns {Object} - native selection object
     * @example
     * 	txSelection.getSel();
     */
    getSel: function() {
        return this.win.getSelection();
    },
    /**
     * 선택된 영역의 텍스트 데이터를 리턴한다.
     * @returns {String} - 선택된 영역의 텍스트 데이터
     * @example
     * 	txSelection.getText();
     */
    getText: function() {
        return this.getSel().toString();
    },
    /**
     * 선택된 영역의 노드를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @example
     * 	txSelection.getNode();
     */
    getNode: function() {
        var _rng = this.getRange();
        if (_rng) {
            var _startContainer = _rng.startContainer;
            if (_startContainer.nodeType == 1) {
                if ($tom.isBody(_startContainer)) {
                    return (_startContainer);
                } else {
                    return (_startContainer.childNodes[_rng.startOffset]);
                }
            } else {
                return (_startContainer.parentNode);
            }
        } else {
            return _NULL;
        }
    },
    /**
     * native range 를 생성한다.
     * @returns {Object} - native range 객체
     * @example
     * 	txSelection.createRange();
     */
    createRange: function() {
        return this.doc.createRange();
    },
    /**
     * native text range 를 생성한다.
     * @returns {Object} - native text range 객체
     * @example
     * 	txSelection.createTextRange();
     */
    createTextRange: function() {
        return this.doc.createRange();
    },
    /**
     * native range object를 리턴한다.
     * @returns {Object} - native range 객체
     * @example
     * 	txSelection.getRange();
     */
    getRange: function(collapse) {
        var _sel = this.getSel();
        if (_sel && _sel.rangeCount > 0) {
            if (collapse == _NULL) {
                if (_sel.rangeCount == 1) { //단일 Range = 일반적인 경우
                    return _sel.getRangeAt(0);
                } else { //복수 Range -> 단일 Range로 변환
                    return this.mergeRange(_sel);
                }
            } else { //Range를 collapse할 경우
                var _rng = _sel.getRangeAt(0);
                _rng.collapse(collapse);
                return _rng;
            }
        } else { //Range가 없을 경우
            return this.doc.createRange();
        }
    },
    /**
     * 선택된 영역의 collapse 여부(선택된 영역이 있는지 여부)를 리턴한다.
     * @returns {Boolean} - collapse 여부
     * @example
     * 	txSelection.isCollapsed();
     */
    isCollapsed: function() {
        var _sel = this.getSel();
        return (_sel && _sel.isCollapsed);
    },
    /**
     * 선택된 영역을 collapse 시킨다.
     * @param {Boolean} toStart - 위치, 시작 = true
     * @example
     * 	txSelection.collapse(true);
     */
    collapse: function(toStart) {
        var _sel = this.getSel();
        if (_sel && _sel.rangeCount > 0) {
            var _rng = _sel.getRangeAt(0);
            _rng.collapse(toStart);
        }
    },
    /**
     * 선택된 영역의 컨트롤 노드(img,object,hr,table,button)를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @example
     * 	txSelection.getControl();
     */
    getControl: function() {
        var _sel = this.getSel();
        var _node;
        if ($tx.opera) {
            /* @opera IMG 선택시 isCollapsed 가 true 되는 문제가 있음. */
            _node = _sel.anchorNode.childNodes[_sel.anchorOffset];
            if (_node == _NULL) {
                return _NULL;
            }
            if (_sel.isCollapsed && _node.tagName != "IMG") {
                return _NULL;
            }
        } else {
            if (_sel.isCollapsed) {
                return _NULL;
            }
            _node = _sel.anchorNode.childNodes[_sel.anchorOffset];
        }
        if ($tom.kindOf(_node, '%control')) {
            return _node;
        } else {
            return _NULL;
        }
    },
    /**
     * 선택된 영역이 컨트롤 노드인지 여부를 리턴한다.
     * @returns {Boolean} - 컨트롤 노드인지 여부
     * @example
     * 	txSelection.hasControl();
     */
    hasControl: function() {
        return (this.getControl() != _NULL);
    },
    /**
     * 컨트롤 노드를 선택한다.
     * @param {Element} node - 컨트롤 노트
     * @example
     * 	txSelection.selectControl(node);
     */
    selectControl: function(node) {
        var _rng = this.createRange();
        _rng.selectNode(node);
        var _sel = this.getSel();
        _sel.removeAllRanges();
        _sel.addRange(_rng);
    },
    /**
     * 선택된 영역이 텍스트 데이터 영역의 어떤 위치인지를 리턴한다.
     * @returns {Number} - 텍스트 데이터 영역의 어떤 위치인지 <br/>
     * 					빈 텍스트일 경우 : $tom.__POSITION.__EMPTY_TEXT : -2<br/>
     * 					텍스트의 처음 : $tom.__POSITION.__START_OF_TEXT : -1<br/>
     * 					텍스트의 중간 : $tom.__POSITION.__MIDDLE_OF_TEXT : 0<br/>
     * 					텍스트의 마지막 : $tom.__POSITION.__END_OF_TEXT : 1
     * @example
     * 	txSelection.compareTextPos();
     */
    compareTextPos: function() {
        var _rng = this.getRange();
        if (_rng) {
            var _startContainer = _rng.startContainer;
            if (_startContainer.nodeType == 3) {
                if (_startContainer.textContent.trim().length == 0) {
                    return $tom.__POSITION.__EMPTY_TEXT;
                } else if (_rng.startOffset == 0) {
                    return $tom.__POSITION.__START_OF_TEXT;
                } else if (_rng.startOffset == _startContainer.textContent.length) {
                    return $tom.__POSITION.__END_OF_TEXT;
                } else {
                    return $tom.__POSITION.__MIDDLE_OF_TEXT;
                }
            }
        }
        return $tom.__POSITION.__END_OF_TEXT;
    },
    /**
     * @private
     * selection에 복수의 range가 있을 경우 range를 합친디ㅏ.
     * @returns {Object} - native range 객체
     * @example
     * 	txSelection.mergeRange(sel);
     */
    mergeRange: function(sel) {
        try {
            var _ranges = [];
            for (var i = 0, _length = sel.rangeCount; i < _length; i++) {
                _ranges.push(sel.getRangeAt(i));
            }
            sel.removeAllRanges();

            var _startNode = _ranges[0].startContainer.childNodes[_ranges[0].startOffset];
            var _endNode = _ranges[_length - 1].endContainer.childNodes[_ranges[_length - 1].endOffset - 1];

            var _rng = this.doc.createRange();
            try {
                _rng.setStart(_startNode, 0);
            } catch (e) {
                _rng.collapse(_TRUE);
            }
            try {
                _rng.setEnd(_endNode, _endNode.childNodes.length);
            } catch (e) {}

            sel.addRange(_rng);
            return sel.getRangeAt(0);
        } catch (e) {
            return sel.getRangeAt(0);
        }
    },
    /**
     * @private
     * 특정 위치로 range의 시작위치를 지정한다.
     * @param {Object} rng - native range 객체
     * @param {Element} node - 특정 부모 노드
     * @param {Number} offset - 노드의 옵셋
     * @example
     * 	txSelection.setStart(range, node, 1);
     */
    setStart: function(rng, node, offset) {
        try {
            rng.setStart(node, offset);
        } catch (e) {
            rng.collapse(_TRUE);
            rng.setStart(node, offset);
        }
    },
    /**
     * @private
     * 특정 위치로 range의 끝위치를 지정한다.
     * @param {Object} rng - native range 객체
     * @param {Element} node - 특정 부모 노드
     * @param {Number} offset - 노드의 옵셋
     * @example
     * 	txSelection.setEnd(range, node, 1);
     */
    setEnd: function(rng, node, offset) {
        try {
            rng.setEnd(node, offset);
        } catch (e) {
            rng.collapse(_FALSE);
            rng.setEnd(node, offset);
        }
    },
    /**
     * 주어진 range를 선택한다.
     * @returns {Object} - native selection 객체
     * @example
     * 	txSelection.selectRange(range);
     */
    selectRange: function(rng) {
        var _sel = this.getSel();
        _sel.removeAllRanges();
        _sel.addRange(rng);
    }
};


Trex.I.Selection.Trident = /** @lends Trex.Canvas.Selection.prototype */ {
    /**
     * native selection object를 리턴한다.
     * @returns {Object} - native selection object
     * @example
     * 	txSelection.getSel();
     */
    getSel: function() {
        return this.doc.selection;
    },
    /**
     * 선택된 영역의 텍스트 데이터를 리턴한다.
     * @returns {String} - 선택된 영역의 텍스트 데이터
     * @example
     * 	txSelection.getText();
     */
    getText: function() {
        return this.getSel().createRange().text;
    },
    /**
     * 선택된 영역의 노드를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @example
     * 	txSelection.getNode();
     */
    getNode: function() {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type === "control") {
            return (_sel.createRange().item(0));
        } else {
            return (_sel.createRange().parentElement());
        }
    },
    /**
     * native range 를 생성한다.
     * @returns {Object} - native range 객체
     * @example
     * 	txSelection.createRange();
     */
    createRange: function() {
        var _sel = this.getSel();
        return _sel.createRange();
    },
    /**
     * native text range 를 생성한다.
     * @returns {Object} - native text range 객체
     * @example
     * 	txSelection.createTextRange();
     */
    createTextRange: function() {
        return this.doc.body.createTextRange();
    },
    /**
     * native range object를 리턴한다.
     * @returns {Object} - native range 객체
     * @example
     * 	txSelection.getRange();
     */
    getRange: function(collapse) {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type == "none") {
            return _sel.createRange() ? _sel.createRange() : function() {
                var _rng = this.doc.body.createTextRange();
                _rng.collapse(_TRUE);
                _rng.select();
                return _rng;
            }();
        }
        if (collapse == _NULL) {
            return _sel.createRange();
        } else {
            if (_type === "text") {
                var _rng = _sel.createRange();
                _rng.collapse(collapse);
                _rng.select();
                return _sel.createRange();
            } else {
                if (_type === "control") {
                    _sel.empty();
                }
                return _sel.createRange();
            }
        }
    },
    /**
     * 선택된 영역의 collapse 여부(선택된 영역이 있는지 여부)를 리턴한다.
     * @returns {Boolean} - collapse 여부
     * @example
     * 	txSelection.isCollapsed();
     */
    isCollapsed: function() {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type === "none") {
            return _TRUE;
        } else if (_type === "control") {
            return _TRUE;
        } else if (_type === "text") {
            var _rng = _sel.createRange();
            return _rng.compareEndPoints('StartToEnd', _rng) == 0;
        } else {
            return _TRUE;
        }
    },
    /**
     * 선택된 영역을 collapse 시킨다.
     * @param {Boolean} toStart - 위치, 시작 = true
     * @example
     * 	txSelection.collapse(true);
     */
    collapse: function(toStart) {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type === "text") {
            var _rng = _sel.createRange();
            _rng.collapse(toStart);
            _rng.select();
            return _sel.createRange();
        } else {
            if (_type === "control") {
                _sel.empty();
            }
            return _sel.createRange();
        }
    },
    /**
     * 선택된 영역의 컨트롤 노드(img,object,hr,table,button)를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @example
     * 	txSelection.hasControl();
     */
    getControl: function() {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type === "control") {
            var _node = _sel.createRange().item(0);
            if ($tom.kindOf(_node, '%control')) {
                return _node;
            } else {
                return _NULL;
            }
        } else {
            return _NULL;
        }
    },
    /**
     * 선택된 영역이 컨트롤 노드인지 여부를 리턴한다.
     * @returns {Boolean} - 컨트롤 노드인지 여부
     * @example
     * 	txSelection.hasControl();
     */
    hasControl: function() {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type === "control") {
            return _TRUE;
        } else {
            return _FALSE;
        }
    },
    /**
     * 컨트롤 노드를 선택한다.
     * @param {Element} node - 컨트롤 노트
     * @example
     * 	txSelection.selectControl(node);
     */
    selectControl: function(node) {
        var _rng = this.doc.body.createControlRange();
        _rng.add(node);
        _rng.select();
    },
    /**
     * 선택된 영역이 텍스트 데이터 영역의 어떤 위치인지를 리턴한다.
     * @returns {Number} - 텍스트 데이터 영역의 어떤 위치인지 <br/>
     * 					텍스트의 처음 : $tom.__POSITION.__START_OF_TEXT : -1<br/>
     * 					텍스트의 중간 : $tom.__POSITION.__MIDDLE_OF_TEXT : 0<br/>
     * 					텍스트의 마지막 : $tom.__POSITION.__END_OF_TEXT : 1
     * @example
     * 	txSelection.compareTextPos();
     */
    compareTextPos: function() {
        var _sel = this.getSel();
        var _type = _sel.type.toLowerCase();
        if (_type === "none") {
            var _rng = _sel.createRange();
            var _rng2 = _rng.duplicate();
            _rng2.moveToElementText(_rng.parentElement());
            if (_rng2.text.trim().replace(Trex.__WORD_JOINER_REGEXP, "").length == 0) {
                return $tom.__POSITION.__EMPTY_TEXT;
            } else if (_rng.compareEndPoints('StartToStart', _rng2) == 0) {
                return $tom.__POSITION.__START_OF_TEXT;
            } else if (_rng.compareEndPoints('EndToEnd', _rng2) == 0) {
                return $tom.__POSITION.__END_OF_TEXT;
            } else {
                return $tom.__POSITION.__MIDDLE_OF_TEXT;
            }
        }
        return $tom.__POSITION.__END_OF_TEXT;
    },
    /**
     * @private
     * @reference http://msdn.microsoft.com/en-us/library/ms536745(VS.85).aspx
    	StartToEnd - Move the start of the TextRange object to the end of the specified oTextRange parameter.
    	StartToStart - Move the start of the TextRange object to the start of the specified oTextRange parameter.
    	EndToStart - Move the end of the TextRange object to the start of the specified oTextRange parameter.
    	EndToEnd - Move the end of the TextRange object to the end of the specified oTextRange parameter.
     */
    transTextRange: function(rng, node, offset, toStart) {
        var _pntRng = this.createTextRange();

        var _pntNode = this.win.span(Trex.__WORD_JOINER);
        $tom.insertAt(_pntNode, node);
        _pntRng.moveToElementText(_pntNode);
        $tom.remove(_pntNode);

        _pntRng.collapse(_TRUE);
        _pntRng.moveStart('character', offset);

        if (toStart) {
            rng.setEndPoint('StartToStart', _pntRng);
        } else {
            rng.setEndPoint('EndToEnd', _pntRng);
        }

        return rng;
    },
    /**
     * @private
     * 특정 위치로 range의 시작위치를 지정한다.
     * @param {Object} rng - native range 객체
     * @param {Element} node - 특정 부모 노드
     * @param {Number} offset - 노드의 옵셋
     * @example
     * 	txSelection.setStart(range, node, 1);
     */
    setStart: function(rng, node, offset) {
        try {
            this.transTextRange(rng, node, offset, _TRUE);
        } catch (e) {
            // console.log(e)
        }
        return rng;
    },
    /**
     * @private
     * 특정 위치로 range의 끝위치를 지정한다.
     * @param {Object} rng - native range 객체
     * @param {Element} node - 특정 부모 노드
     * @param {Number} offset - 노드의 옵셋
     * @example
     * 	txSelection.setEnd(range, node, 1);
     */
    setEnd: function(rng, node, offset) {
        try {
            this.transTextRange(rng, node, offset, _FALSE);
        } catch (e) {
            // console.log(e)
        }
        return rng;
    },
    /**
     * 주어진 range를 선택한다.
     * @returns {Object} - native selection 객체
     * @example
     * 	txSelection.selectRange(range);
     */
    selectRange: function(rng) {
        rng.select();
    }
};

Trex.I.Selection.TridentStandard = {
    /**
     * 선택된 영역의 컨트롤 노드(img,object,hr,table,button)를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @example
     * 	txSelection.getControl();
     */
    getControl: function() {
        var _sel = this.getSel();
        if (_sel.isCollapsed) {
            return null;
        }
        if ($tom.isElement(_sel.anchorNode)) {
            var _node = _sel.anchorNode.childNodes[_sel.anchorOffset];
            if ($tom.kindOf(_node, '%control')) {
                return _node;
            } else {
                return null;
            }
        }
        //button
        var _prevNode = $tom.previous(_sel.focusNode);
        var _nextNode = $tom.next(_sel.anchorNode);
        if (_prevNode == _nextNode) {
            return $tom.first(_prevNode, '%control');
        } else {
            return null;
        }
    },
    /**
     * 컨트롤 노드를 선택한다.
     * @param {Element} node - 컨트롤 노트
     * @example
     * 	txSelection.selectControl(node);
     */
    selectControl: function(node) {
        var _rng = this.createRange();
        _rng.selectNode(node);
        var _sel = this.getSel();
        _sel.removeAllRanges();
        _sel.addRange(_rng);
    }
};


Trex.I.Selection.Gecko = {

};

Trex.I.Selection.Webkit = {
    /**
     * 선택된 영역의 컨트롤 노드(img,object,hr,table,button)를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @example
     * 	txSelection.getControl();
     */
    getControl: function() {
        var _sel = this.getSel();
        if (_sel.isCollapsed) {
            return _NULL;
        }
        if ($tom.isElement(_sel.anchorNode)) {
            var _node = _sel.anchorNode.childNodes[_sel.anchorOffset];
            if ($tom.kindOf(_node, '%control')) {
                return _node;
            } else {
                return _NULL;
            }
        }
        //button
        var _prevNode = $tom.previous(_sel.focusNode);
        var _nextNode = $tom.next(_sel.anchorNode);
        if (_prevNode == _nextNode) {
            return $tom.first(_prevNode, '%control');
        } else {
            return _NULL;
        }
    },
    /**
     * 컨트롤 노드를 선택한다.
     * @param {Element} node - 컨트롤 노트
     * @example
     * 	txSelection.selectControl(node);
     */
    selectControl: function(node) {
        var _rng = this.createRange();
        _rng.selectNode(node);
        var _sel = this.getSel();
        _sel.removeAllRanges();
        _sel.addRange(_rng);
    }
};

Trex.I.Selection.Presto = {

};

/**
 * native selection, range 객체를 wrapping 한 객체로 <br/>
 * browser에 따라 필요한 함수들을 mixin한다. <br/>
 * 주로 Processor와 연관된 객체에서 호출하며, <br/>
 * processor.getTxSel()를 통해서 txSelection를 얻어서 사용한다. <br/>
 * native selection 과 구분짓기 위해서 txSelection로 명명한다.
 *
 * @class
 * @param {Object} processor - Processor 객체
 */
Trex.Canvas.Selection = Trex.Class.create( /** @lends Trex.Canvas.Selection.prototype */ {
    /** @ignore */
    $mixins: [
        Trex.I.Selection.Standard,
        (($tx.msie_nonstd) ? Trex.I.Selection.Trident : {}),
        (($tx.msie_std) ? Trex.I.Selection.TridentStandard : {}),
        (($tx.gecko) ? Trex.I.Selection.Gecko : {}),
        (($tx.webkit) ? Trex.I.Selection.Webkit : {}),
        (($tx.presto) ? Trex.I.Selection.Presto : {})
    ],
    initialize: function(processor) {
        this.processor = processor;
        this.win = processor.win;
        this.doc = processor.doc;
    }
});

/**
 * @fileOverview
 * 선택된 영역을 북마크하여
 * 포커스된 document가 변경되거나 DOM 조작을 하더라도 선택 영역이 유지되도록 한다.
 * Processor 에서 주로 사용된다.
 */

/**
 * 선택된 영역을 북마크하여 <br/>
 * 포커스된 document가 변경되거나 DOM 조작을 하더라도 선택 영역이 유지되도록 하는 객체로 <br/>
 * native range 객체에 있는 5가지 프로퍼티만 저장한다. <br/>
 * 주로 Processor와 연관된 객체에서 호출하며, <br/>
 * processor.getBookmark()를 통해서 bookmark를 얻어서 사용한다.<br/>
 *
 * @class
 */
Trex.Canvas.Bookmark = Trex.Class.create( /** @lends Trex.Canvas.Bookmark.prototype */ {
    startContainer: _NULL,
    startOffset: 0,
    endContainer: _NULL,
    endOffset: 0,
    initialize: function(processor) {
        this.processor = processor;
        this.win = processor.win;
        this.doc = processor.doc;
        this.dummy = function() {
            return processor.newDummy();
        };
    },
    /**
     * 시작위치와 끝위치를 동일하게 북마크를 수정한다.
     * @param {Boolean} toStart - 위치, 시작 = true
     * @example
     * 	bookmark.collapse(true);
     */
    collapse: function(toStart) {
        if (toStart) {
            this.updateEnd(this.startContainer, this.startOffset);
        } else {
            this.updateStart(this.endContainer, this.endOffset);
        }
    },
    /**
     * native range 객체로 북마크를 수정한다.
     * @param {Object} rng - native range 객체
     * @example
     * 	bookmark.save(range);
     */
    save: function(rng) {
        this.updateStart(rng.startContainer, rng.startOffset);
        this.updateEnd(rng.endContainer, rng.endOffset);
    },
    /**
     * 특정 노드의 앞과 뒤로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.saveAroundNode(node);
     */
    saveAroundNode: function(node) {
        this.updateStartBefore($tom.top(node));
        this.updateEndAfter($tom.bottom(node));
    },
    /**
     * 특정 노드의 처음으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.saveIntoFirst(node);
     */
    saveIntoFirst: function(node) {
        var _node = $tom.top(node);
        this.updateEndBefore(_node);
        this.collapse(_FALSE);
    },
    /**
     * 특정 노드의 마지막으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.saveIntoLast(node);
     */
    saveIntoLast: function(node) {
        var _node = $tom.bottom(node);
        this.updateEndBefore(_node);
        this.collapse(_FALSE);
    },
    /**
     * 특정 노드의 이전으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.saveNextTo(node);
     */
    savePreviousTo: function(node) {
        if ($tom.previous(node)) {
            var _node = $tom.top($tom.previous(node));
            this.updateEndAfter(_node);
        } else {
            this.updateEndBefore(node);
        }
        this.collapse(_FALSE);
    },
    /**
     * 특정 노드의 다음으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.saveNextTo(node);
     */
    saveNextTo: function(node) {
        if ($tom.next(node)) {
            var _node = $tom.top($tom.next(node));
            this.updateEndBefore(_node);
        } else {
            this.updateEndAfter(node);
        }
        this.collapse(_FALSE);
    },
    /**
     * marker node로 북마크를 수정한다.
     * @param {Object} marker - marker 객체
     * @example
     * 	bookmark.saveWithMarker(marker);
     */
    saveWithMarker: function(marker) {
        if (marker.checkCollapsed()) { //collapsed
            this.updateEndAfter(marker.endMarker);
            this.collapse(_FALSE);
        } else {
            this.updateStartBefore(marker.startMarker);
            this.updateEndAfter(marker.endMarker);
        }
    },
    /**
     * txSelection가지고 저장된 북마크를 선택한다.
     * @param {Object} txSelection - txSelection 객체
     * @example
     * 	bookmark.select(txSelection);
     */
    select: function(txSel) {
        if (this.isValid()) {
            var _rng = txSel.createTextRange();
            try {
                txSel.setStart(_rng, this.startContainer, this.startOffset);
                txSel.setEnd(_rng, this.endContainer, this.endOffset);
            } catch (e) {
                // console.log(e)
            }
            txSel.selectRange(_rng);
        }
        this.reset();
    },
    isValid: function() {
        return this.isValidStartContainer() && this.isValidEndContainer();
    },
    isValidStartContainer: function() {
        return this.doc.body === $tom.body(this.startContainer);
    },
    isValidEndContainer: function() {
        return this.doc.body === $tom.body(this.endContainer);
    },
    /**
     * @private
     * 시작 관련 프로퍼티를 특정 위치로 지정한다.
     * @param {Element} node - 특정 부모 노드
     * @param {Number} offset - 노드의 옵셋
     * @example
     * 	bookmark.updateStart(node, 1);
     */
    updateStart: function(node, offset) {
        this.startContainer = node;
        this.startOffset = offset;
    },
    /**
     * @private
     * 시작 관련 프로퍼티를 특정 위치로 이전으로 지정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.updateStartBefore(node);
     */
    updateStartBefore: function(node) {
        var _tNode = this.dummy();
        $tom.insertAt(_tNode, node);

        this.startContainer = _tNode;
        this.startOffset = 0;
    },
    /**
     * @private
     * 시작 관련 프로퍼티를 특정 위치로 다음으로 지정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.updateStartAfter(node);
     */
    updateStartAfter: function(node) {
        var _tNode = this.dummy();
        $tom.insertNext(_tNode, node);

        this.startContainer = _tNode;
        this.startOffset = 0;
    },
    /**
     * @private
     * 끝 관련 프로퍼티를 특정 위치로 지정한다.
     * @param {Element} node - 특정 부모 노드
     * @param {Number} offset - 노드의 옵셋
     * @example
     * 	bookmark.updateEnd(node, 1);
     */
    updateEnd: function(node, offset) {
        this.endContainer = node;
        this.endOffset = offset;
    },
    /**
     * @private
     * 끝 관련 프로퍼티를 특정 위치로 이전으로 지정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.updateEndBefore(node);
     */
    updateEndBefore: function(node) {
        var _tNode = this.dummy();
        if (node.nodeName && node.nodeName.toUpperCase() == "P" && !node.nodeValue) { // Note: 마지막 조건( !node.nodeValue)은 무의미한데..
            $tom.append(node, _tNode);
        } else {
            $tom.insertAt(_tNode, node);
        }

        this.endContainer = _tNode;
        this.endOffset = _tNode.length;
    },
    /**
     * @private
     * 끝 관련 프로퍼티를 특정 위치로 다음으로 지정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	bookmark.updateEndAfter(node);
     */
    updateEndAfter: function(node) {
        var _tNode = this.dummy();
        $tom.insertNext(_tNode, node);

        this.endContainer = _tNode;
        this.endOffset = _tNode.length;
    },
    /**
     * @private
     * 북마크를 초기화한다.
     * @returns {Boolean} - collapse 여부
     * @example
     * 	bookmark.reset();
     */
    reset: function() {
        this.startContainer = _NULL;
        this.startOffset = 0;
        this.endContainer = _NULL;
        this.endOffset = 0;
    }
});

Trex.Canvas.TextAreaProcessor = Trex.Class.create({
    $mixins: [],
    initialize: function(textarea) {
        this.el = textarea;
    },
    focus: function() {
        this.el.focus();
    },
    blur: function() {
        _WIN.focus();
    },
    /**
     * 본문의 처음으로 캐럿을 옮긴다.
     * @example
     * 	processor.focusOnTop();
     */
    focusOnTop: function() {
        var textarea = this.el;
        textarea.focus();
        this._selectCharacter(0, 0);
        textarea.scrollTop = 0;
    },
    focusOnBottom: function() {
        var textarea = this.el;
        textarea.focus();
        var len = textarea.value.length;
        this._selectCharacter(len, len);
        textarea.scrollTop = textarea.scrollHeight;
    },
    savePosition: function() {
        // 왜 사용되었는지 의문.. this.currentPos가 쓰이는 곳이 없음. #FTDUEDTR-1395
        //		if (this.el.createTextRange) {
        //			this.currentPos = _DOC.selection.createRange().duplicate();
        //		}
    },
    controlEnter: function() {
        var _processor = this;
        _processor.insertTag("<br/>", "");
    },
    insertTag: function(prefix, postfix) {
        this.pasteContent(prefix + postfix);
        return _TRUE;
    },
    pasteContent: function(content /*, newLine, wrapStyle*/ ) {
        this.el.value += content;
    },
    _selectCharacter: function(startChar, endChar) {
        var textarea = this.el;
        if (textarea.setSelectionRange) { // standard
            textarea.select();
            textarea.setSelectionRange(startChar, endChar);

        } else if (textarea.createTextRange) { // IE
            var range = textarea.createTextRange();
            range.collapse(_TRUE);
            range.moveStart("character", startChar);
            range.moveEnd("character", endChar);
            range.select();
        }
    }
});


/**
 * @fileOverview
 * Wysiwyg 영역의 컨텐츠를 조작하기 위해 사용되는 공통되는 Processor 정의
 */
Trex.I.Processor = {};
Trex.I.Processor.Standard = /** @lends Trex.Canvas.Processor.prototype */ {
    txSelection: _NULL,
    isRangeInsideWysiwyg: _FALSE,
    lastRange: _NULL,
    initialize: function(win, doc) {
        this.win = win;
        this.doc = doc;

        this.txSelection = new Trex.Canvas.Selection(this);
        this.bookmark = new Trex.Canvas.Bookmark(this);
    },
    /**
     * Trex.Canvas.Selection 객체를 리턴한다.
     * @returns {Object} - Trex.Canvas.Selection 객체
     * @example
     * 	processor.getTxSel();
     */
    getTxSel: function() {
        return this.txSelection;
    },
    /**
     * native selection object를 리턴한다.
     * @returns {Object} - native selection 객체
     * @example
     * 	processor.getSel();
     */
    getSel: function() {
        return this.txSelection.getSel();
    },
    /**
     * native range object를 리턴한다.
     * @returns {Object} - native range 객체
     * @example
     * 	processor.getRange();
     */
    getRange: function() {
        return this.txSelection.getRange();
    },
    /**
     * Trex.Canvas.Bookmark 객체를 리턴한다.
     * @returns {Object} - Trex.Canvas.Bookmark 객체
     * @example
     * 	processor.getBookmark();
     */
    getBookmark: function() {
        return this.bookmark;
    },
    /**
     * 선택된 영역의 collapse 여부(선택된 영역이 있는지 여부)를 리턴한다.
     * @returns {Boolean} - collapse 여부
     * @see Trex.Canvas.Selection#isCollapsed
     * @example
     * 	processor.isCollapsed();
     */
    isCollapsed: function() {
        return this.txSelection.isCollapsed();
    },
    /**
     * 선택된 영역의 노드를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @see Trex.Canvas.Selection#getNode
     * @example
     * 	processor.getNode();
     */
    getNode: function() {
        return this.txSelection.getNode();
    },
    /**
     * 선택된 영역의 컨트롤 노드(img,object,hr,table,button)를 리턴한다.
     * @returns {Element} - 선택된 영역의 노드
     * @see Trex.Canvas.Selection#getControl
     * @example
     * 	processor.getControl();
     */
    getControl: function() {
        return this.txSelection.getControl();
    },
    /**
     * 선택된 영역이 컨트롤 노드인지 여부를 리턴한다.
     * @returns {Boolean} - 컨트롤 노드인지 여부
     * @see Trex.Canvas.Selection#hasControl
     * @example
     * 	processor.hasControl();
     */
    hasControl: function() {
        return this.txSelection.hasControl();
    },
    /**
     * 컨트롤 노드를 선택한다.
     * @param {Element} node - 컨트롤 노트
     * @example
     * 	txSelection.selectControl(node);
     */
    selectControl: function(node) {
        return this.txSelection.selectControl(node);
    },
    /**
     * 선택된 영역의 텍스트 데이터를 리턴한다.
     * @returns {String} - 선택된 영역의 텍스트 데이터
     * @see Trex.Canvas.Selection#getText
     * @example
     * 	processor.getText();
     */
    getText: function() {
        return this.txSelection.getText();
    },
    /**
     * 선택된 영역이 텍스트 데이터 영역의 어떤 위치인지를 리턴한다.
     * @returns {Number} - 텍스트 데이터 영역의 어떤 위치인지 <br/>
     * 					텍스트의 처음 : $tom.__POSITION.__START_OF_TEXT : -1<br/>
     * 					텍스트의 중간 : $tom.__POSITION.__MIDDLE_OF_TEXT : 0<br/>
     * 					텍스트의 마지막 : $tom.__POSITION.__END_OF_TEXT : 1
     * @see Trex.Canvas.Selection#compareTextPos
     * @example
     * 	processor.compareTextPos();
     */
    compareTextPos: function() {
        return this.txSelection.compareTextPos();
    },
    /**
     * 현재 선택된 영역에서 조건에 맞는 노드를 리턴한다.
     * @param {Function, String} filter - 조건을 나타내는 함수 또는 문자열
     * @returns {Element} - 조건에 맞는 노드
     * @example
     * 	processor.findNode(function() { return 'p,div'; });
     * 	processor.findNode('%paragraph');
     */
    findNode: function(filter) {
        try {
            return $tom.find(this.getNode(), filter);
        } catch (e) {
            return _NULL;
        }
    },
    /*-------- processor - query style start --------*/
    /**
     * 특정한 노드의 특정한 스타일 값을 얻어온다.
     * @param {Element} node - 특정 노드
     * @param {String} styleName - 스타일 명
     * @returns {String} - 스타일 값
     * @example
     * 	processor.queryStyle(node, 'textAlign');
     */
    queryStyle: function(node, styleName) {
        if (!node) {
            return _NULL;
        }
        styleName = ((styleName == 'float') ? ((node.style.styleFloat === _UNDEFINED) ? 'cssFloat' : 'styleFloat') : styleName);
        if (node.style && node.style[styleName]) {
            return node.style[styleName];
        } else if (node.currentStyle && node.currentStyle[styleName]) {
            return node.currentStyle[styleName];
        } else if (_WIN.getComputedStyle) {
            var targetNode = node;
            while ($tom.isText(targetNode)) {
                targetNode = targetNode.parentNode;
            }
            var win = $tom.getWindow(this.doc);
            var _cssStyle = win.getComputedStyle(targetNode, _NULL);
            return ((_cssStyle) ? _cssStyle[styleName] : _NULL);
        }
        return _NULL;
    },
    /**
     * 특정한 노드의 특정한 속성 값을 얻어온다.
     * @param {Element} node - 특정 노드
     * @param {String} attrName - 속성 명
     * @returns {String} - 속성 값
     * @example
     * 	processor.queryAttr(node, 'align');
     */
    queryAttr: function(node, attrName) {
        if (!node) {
            return _NULL;
        }
        return $tom.getAttribute(node, attrName);
    },
    /**
     * 선택된 영역의 native queryCommandState 값을 얻어온다.
     * @param {String} command - 커맨드 명
     * @returns {Boolean} - 해당 영역이 커맨드 상태인지 여부
     * @example
     * 	processor.queryCommandState('bold');
     */
    queryCommandState: function(command) {
        try {
            return this.doc.queryCommandState(command);
        } catch (e) { return _FALSE; }
    },
    /**
     * 선택된 영역의 native queryCommandValue 값을 얻어온다.
     */
    queryCommandValue: function(command) {
        try {
            return this.doc.queryCommandValue(command);
        } catch (e) {
            return "";
        }
    },
    /*-------- processor - query style end --------*/
    /**
     * 선택된 영역에 native execCommand를 실행시킨다.
     * @param {String} command - 커맨드 명
     * @param {String} data - 데이터 값
     * @example
     * 	processor.execCommand('forecolor', '#333');
     */
    execCommand: function(command, data) {
        if ($tx.gecko) {
            // Firefox는 styleWithCSS 기본값이 true
            try {
                this.doc.execCommand('styleWithCSS', _FALSE, _FALSE);
            } catch (e) {}
        }
        try {
            this.doc.execCommand(command, _FALSE, data);
        } catch (e) {}
    },
    /*-------- processor - marker start --------*/
    /**
     * 선택된 영역에 주어진 handler를 실행시킨다.
     * 주로 외부에서 processor를 이용해 DOM조작을 할 경우에 사용된다.
     * @param {Funtion} handler - 해당 영역에 실행할 함수
     * @example
     * 	processor.execWithMarker(function(marker) {
     *		$tom.insertAt(node, marker.endMarker);
     *  });
     */
    execWithMarker: function(handler) {
        var _marker = new Trex.Canvas.Marker(this);
        this.bookmarkTo();
        try {
            _marker.paste();
            _marker.backup();
            handler(_marker);
        } catch (e) {
            // console.log(e, e.stack)
        } finally {
            _marker.remove();
        }
    },
    /*-------- processor - marker end --------*/
    /*--------------------- focus, movecaret ----------------------*/
    /**
     * wysiwyg 영역에 포커스를 준다.
     * @example
     * 	processor.focus();
     */
    focus: function() {
        this.doc.body.focus();
    },
    /**
     * wysiwyg 영역에 포커스를 뺀다.
     * @example
     * 	processor.blur();
     */
    blur: function() {
        _WIN.focus(); //NOTE: by focused on parent window, editor will be blured
    },
    /**
     * 본문의 처음으로 캐럿을 옮긴다.
     * @example
     * 	processor.focusOnTop();
     */
    focusOnTop: function() {
        this.focus();
        this.selectFirstText(this.doc.body);
        this.doc.body.scrollTop = 0; //NOTE: only html, not xhtml
    },
    selectFirstText: function(node) {
        var firstNode = $tom.top(node);
        var range = this.createGoogRangeFromNodes(firstNode, 0, firstNode, 0);
        range.select();
    },
    selectLastText: function(node) {
        var lastNode = $tom.bottom(node);
        var offset = 0;
        if(lastNode && lastNode.nodeType == 3 && lastNode.length) offset = lastNode.length;
        var range = this.createGoogRangeFromNodes(lastNode, offset, lastNode, offset);
        range.select();
    },
    /**
     * 본문의 마지막으로 캐럿을 옮긴다.
     * @example
     * 	processor.focusOnBottom();
     */
    focusOnBottom: function() {
        this.focus();
        this.moveCaretTo(this.doc.body, _FALSE);
        this.doc.body.scrollTop = this.doc.body.scrollHeight; //NOTE: only html, not xhtml
    },
    /**
     * 특정 노드로 캐럿을 옮긴다.
     * @param {Element} node - 특정 노드
     * @param {Boolean} toStart - 위치, 시작 = true
     * @example
     * 	processor.moveCaretTo(node, true);
     */
    moveCaretTo: function(node, toStart, _selection) {
        if (!node) {
            return;
        }
        this.focus();
        this.bookmarkInto(node, toStart);
        if (_selection !== false) this.bookmark.select(this.txSelection);
    },
    /**
     * 특정 노드의 바깥으로 캐럿을 옮긴다.
     * @param {String} scope - 특정 노드 패턴
     * @example
     * 	processor.moveCaretWith(scope);
     */
    moveCaretWith: function(scope) {
        if (!scope) { return; }
        var _elOuter = this.findNode(scope);
        if (_elOuter) {
            this.focus();
            this.bookmark.saveNextTo(_elOuter);
            this.bookmark.select(this.txSelection);
        }
    },
    /**
     * 특정 노드를 감싸 선택한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	processor.selectAround(node);
     */
    selectAround: function(node) {
        if (!node) {
            return;
        }
        this.focus();
        this.bookmark.saveAroundNode(node);
        this.bookmark.select(this.txSelection);
    },
    /**
     * 특정 노드의 안으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	processor.bookmarkInto(node);
     */
    bookmarkInto: function(node, toStart) {
        if (!node) {
            return;
        }
        toStart = (toStart == _NULL) ? _TRUE : toStart;
        if (toStart) {
            this.bookmark.saveIntoFirst(node);
        } else {
            this.bookmark.saveIntoLast(node);
        }
    },
    /**
     * 특정 노드의 이전으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	processor.bookmarkToPrevious(node);
     */
    bookmarkToPrevious: function(node) {
        if (!node) {
            return;
        }
        this.bookmark.savePreviousTo(node);
    },
    /**
     * 특정 노드의 다음으로 북마크를 수정한다.
     * @param {Element} node - 특정 노드
     * @example
     * 	processor.bookmarkToNext(node);
     */
    bookmarkToNext: function(node) {
        if (!node) {
            return;
        }
        this.bookmark.saveNextTo(node);
    },
    /**
     * execute하기 전 range를 북마크한다.
     * @example
     * 	processor.bookmark();
     */
    bookmarkTo: function(rng) {
        rng = rng || this.txSelection.getRange();
        this.bookmark.save({
            startContainer: rng.startContainer,
            startOffset: rng.startOffset,
            endContainer: rng.endContainer,
            endOffset: rng.endOffset
        });
    },
    /**
     * marker에 따라 북마크를 수정한다.
     * @example
     * 	processor.bookmarkWithMarker(marker);
     */
    bookmarkWithMarker: function(marker) {
        this.bookmark.saveWithMarker(marker);
    },
    /**
     * 저장한 range를 선택한다.
     * @example
     * 	processor.restore();
     */
    restore: function() {
        this.bookmark.select(this.txSelection);
    },
    /*------------ execute action ------------*/
    /**
     * 인자에 따라 노드를 생성한다.
     * @param {String, Object, Element} argument - 가변 arguments<br/>
     * 			{String} name : 1st String은 노드명  <br/>
     * 			{Object} attributes : 적용할 속성들  <br/>
     * 			{Element, String, Number} children : 자식 노드
     * @example
     * 	processor.create('div', { 'className': 'txc-textbox' });
     */
    create: function() {
        var name = arguments[0];
        var _node = this.newNode(name);
        for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg.nodeType) {
                $tom.append(_node, arg);
            } else if (typeof(arg) == 'string' || typeof(arg) == 'number') {
                _node.innerHTML += arg;
            } else if (typeof(arg) == 'array') {
                for (var j = 0; j < arg.length; j++) {
                    $tom.append(_node, arg[j]);
                }
            } else {
                $tom.applyAttributes(_node, arg);
            }
        }
        return _node;
    },
    /**
     * 선택한 영역에 노드를 삽입한다.
     * @param {Array,Element} nodes - 삽입하고자 하는 노드 배열 또는 노드
     * @param {Boolean} newline - 현재 영역에서 한줄을 띄운 후 삽입할지 여부
     * @param {Object} wrapStyle - wrapper 노드에 적용할 스타일, <br/>
     * 					newline이 true 일 경우에만 의미를 갖는다.
     * @example
     * 	processor.pasteNode([node, node], true, { 'style': { 'textAlign': 'center' } });
     */
    pasteNode: function(nodes, newline, wrapStyle, _selection) {
        if (!nodes) {
            return;
        }
        if (!nodes.length) {
            nodes = [].concat(nodes);
        }

        this.txSelection.collapse(_FALSE);
        if (newline) {
            /* order
             * (curNode) > wpNode > dvNode
             */
            var _curNode, _wpNode, _dvNode;

            var _processor = this;
            this.execWithMarker(function(marker) {
                _dvNode = $tom.divideParagraph(marker.endMarker);
                var _detected = $tom.kindOf(_dvNode, 'p,li,dd,dt,h1,h2,h3,h4,h5,h6');
                if (_detected) {
                    _curNode = $tom.previous(_dvNode);
                    _wpNode = $tom.clone(_dvNode);
                } else {
                    _dvNode = _processor.newNode('p');
                    $tom.insertAt(_dvNode, marker.endMarker);
                    _wpNode = _processor.newNode('p');
                }
                $tom.insertAt(_wpNode, _dvNode);
                nodes.each(function(node) {
                    $tom.append(_wpNode, node);
                });
                if (wrapStyle) {
                    $tom.applyAttributes(_wpNode, wrapStyle);
                }
                // #FTDUEDTR-1442
                if (nodes.length == 1) {
                    var firstChildNode = nodes[0];
                    var disableBlockTag = $tom.kindOf(firstChildNode, 'table,hr,blockquote,pre,h1,h2,h3,h4,h5,h6,div');
                    var isParagraphTag = $tom.isTagName(_wpNode, 'p');
                    if (disableBlockTag && isParagraphTag) {
                        $tom.unwrap(_wpNode);
                    }
                }
            });
            if (_curNode) {
                if (!$tom.hasData(_curNode)) {
                    this.stuffNode(_curNode);
                }
            }
            this.stuffNode(_dvNode);
            this.bookmark.saveIntoFirst(_dvNode);
        } else {
            var self = this;
            this.executeUsingCaret(function(range, savedCaret) {
                var startCaret = savedCaret.getCaret(_FALSE),
                    endCaret = savedCaret.getCaret(_FALSE);
                var targetNode = $tx.msie_nonstd ? startCaret : _NULL;
                if ($tx.webkit) nodes.reverse(); /* Chrome에서 붙여넣는 Element가 여러개 일경우 꺼꾸로 들어감. */
                nodes.each(function(node) {
                    range.insertNode(node, targetNode);
                });
                if (endCaret && endCaret.nextSibling) {
                    self.moveCaretTo(endCaret.nextSibling, 0, _selection);
                } else if (endCaret) {
                    self.moveCaretTo(endCaret, 0, _selection);
                }
            });
        }
        return nodes[0];
    },
    /**
     * 선택한 영역에 HTML 컨텐츠를 삽입한다.
     * @param {String} html - 삽입하고자 하는 HTML 컨텐츠
     * @param {Boolean} newline - 현재 영역에서 한줄을 띄운 후 삽입할지 여부 true/false
     * @param {Object} wrapStyle - wrapper 노드에 적용할 스타일, <br/>
     * 					newline이 true 일 경우에만 의미를 갖는다.
     * @example
     * 	processor.pasteNode('<img src="이미지경로"/>', true, { 'style': { 'textAlign': 'center' } });
     */
    pasteContent: function(html, newline, wrapStyle, _selection) {
        var _tmpNode = this.create('div');
        _tmpNode.innerHTML = html;
        var _dataNodes = $tom.children(_tmpNode);
        return this.pasteNode(_dataNodes, newline, wrapStyle, _selection);
    },
    /**
     * pasteHtml
     * @param {String} html - 삽입하고자 하는 HTML 컨텐츠
     */
    pasteHtml: function(html, _canvas, _range) {
        var _self = this;
        var selection = (this.doc.getSelection ? this.doc.getSelection() : this.doc.selection);
        var node = null;
        var range = null;
        function _paste() {
            var txt = null;
            if(_range && $tx.msie) txt = _self.doc.createTextNode(' ');
            if (selection.getRangeAt && selection.rangeCount != null) {
                if (selection.rangeCount == 0 && !_range) return;
                if(_range) range = _range;
                if(_canvas && !range) range = _canvas.getProcessor().getSelectionRange(_canvas);
                if(!range) range = selection.getRangeAt(selection.rangeCount - 1);
                range.deleteContents();
                if (range.createContextualFragment) {
                    node = range.createContextualFragment(html);
                } else {
                    var div = _self.doc.createElement("div");
                    div.innerHTML = html;
                    node = document.createDocumentFragment();
                    var child = div.firstChild;
                    while (child != null) {
                        node.appendChild(child);
                        child = div.firstChild;
                    }
                }
                try { range.selectNode(node); } catch (e) {}
                if(txt) try{range.insertNode(txt);}catch(e){}
                range.insertNode(node);
                selection.collapseToEnd();
            } else if (selection.type && selection.type != "Control") {
                if(_range) range = _range;
                if (_canvas) range = _canvas._SELECTION_RANGE;
                if (!range) range = selection.createRange();
                if(txt) try{range.insertNode(txt);}catch(e){}
                range.pasteHTML(html);
            }
            try{
                if(range){ // _range를 range로 변경함 붙여넣기 후 Backspace를 누르면 전체 삭제되는 case 발생.
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    if(txt){
                        if(txt.nextSibling && txt.nextSibling.nodeType == '#text'){
                            var tmp = txt.nextSibilng;
                            txt.parentNode.removeChild(txt);
                            txt = tmp;
                        }
                        range.selectNode(txt);
                    }
                }
            }catch(ee){}
        }
        try {
            if ($tx.msie) {
                _paste();
            } else {
                this.doc.execCommand("insertHTML", false, html);
            }
        } catch (ee) {
            _paste();
        }
    },
    getSelectionRange:function(_canvas){
        var _doc = this.doc;
        var selection = (_doc.getSelection ? _doc.getSelection() : _doc.selection);
        var range = null;
        if (selection.getRangeAt && selection.rangeCount != null) {
            if (selection.rangeCount == 0) return;
            range = selection.getRangeAt(selection.rangeCount - 1);
        }else if (selection.type && selection.type != "Control") {
            if (_canvas) range = _canvas._SELECTION_RANGE;
            if (!range) range = selection.createRange();
        }
        return range;
    },
    /**
     * pasetNodeCustom
     * _range : 붙여넣기 옵션 사용시 IE가 붙여넣을 위치를 못잡는 경우 때문에 사용.
     * ' ' TextNode는 붙여넣은 후 cursor 위치를 잡기 위함. 다른 방법을 모르겠음.
     */
    pasteNodeCustom: function(node, _canvas, _range) {
        var _self = this;
        var selection = (this.doc.getSelection ? this.doc.getSelection() : this.doc.selection);
        var range = null;
        function _paste() {
            var txt = null;
            if(_range && $tx.msie) txt = _self.doc.createTextNode(' ');
            if (selection.getRangeAt && selection.rangeCount != null) {
                if (selection.rangeCount == 0 && !_range) return;
                if(_range) range = _range;
                if(!range) range = selection.getRangeAt(selection.rangeCount - 1);
                range.deleteContents();
                if(txt) try{range.insertNode(txt);}catch(e){}
                range.insertNode(node);
                try { range.selectNode(node); } catch (e) {}
                selection.collapseToEnd();
            } else if (selection.type && selection.type != "Control") {
                if(_range) range = _range;
                if (_canvas && !range) range = _canvas._SELECTION_RANGE;
                if (!range) range = selection.createRange();
                if(txt) try{range.insertNode(txt);}catch(e){}
                range.insertNode(node);
            }
            try{
                if(_range){
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    if(txt){
                        if(txt.nextSibling && txt.nextSibling.nodeType == '#text'){
                            var tmp = txt.nextSibilng;
                            txt.parentNode.removeChild(txt);
                            txt = tmp;
                        }
                        range.selectNode(txt);
                    }
                }
            }catch(ee){}
        }
        try{
            _paste();
            return node;
        }catch(e){
            return this.pasteNode(node, false, _range);
        }
    },
    /**
     * 주어진 노드를 새로운 노드로 교체한다.
     * @param {Element} node - 기존 노드
     * @param {String} tag - 새로운 노드 명
     * @param {Object} attributes - 새로운 노드에 적용할 속성들
     * @returns {Element} - 생성한 노드
     * @example
     * 	processor.replace(p, 'li');
     */
    replace: function(node, tag, attributes) {
        this.bookmark.saveAroundNode(node);
        return $tom.replace(node, this.create(tag, attributes));
    },
    /**
     * 선택한 영역안에 있는 노드 중에 패턴을 만족하는 블럭 노드들을 리턴한다.
     * @param {Array} filter - 수집할 노드 패턴 조건
     * @returns {Array} - 선택한 영역안에 있는 노드 중에 패턴을 만족하는 노드들
     * @example
     * 	processor.blocks(function() {
    		return '%paragraph';
    	});
     */
    blocks: function(filter) {
        var _nodes = [];
        var _patterns = filter();
        if (this.hasControl()) {
            var _control = this.getControl();
            if ($tom.kindOf(_control.parentNode, _patterns)) {
                _nodes.push(_control.parentNode);
            }
        } else {
            var _processor = this;
            this.execWithMarker(function(marker) {
                var _itr = _processor.getBlockRangeIterator(_patterns, marker.startMarker, marker.endMarker);
                var _node;
                while (_itr.hasNext()) {
                    _node = _itr.next();
                    if ($tom.kindOf(_node, '#tx_start_marker,#tx_end_marker')) {
                        //ignore
                    } else {
                        _nodes.push(_node);
                    }
                }
            });
        }
        return _nodes;
    },
    /**
     * 선택한 영역안에 있는 노드 중에 패턴을 만족하는 인라인 노드들을 리턴한다.
     * @param {Array} filter - 수집할 노드 패턴 조건
     * @returns {Array} - 선택한 영역안에 있는 노드 중에 패턴을 만족하는 노드들
     * @example
     * 	processor.inlines(function(type) {
    		if(type === 'control') {
    			return 'hr,table';
    		}
    		return '%inline';
    	});
     */
    inlines: function(filter) {
        var _nodes = [];
        var _patterns = filter();

        var _processor = this;
        var _createInline = function() {
            return _processor.create($tom.inlineOf());
        };

        if (this.hasControl()) {
            var _control = this.getControl();
            if ($tom.kindOf(_control, _patterns)) {
                _nodes.push(_control);
            } else {
                var _iNode = _createInline();
                $tom.insertNext(_iNode, _control);
                $tom.append(_iNode, _control);
            }
        } else {
            this.execWithMarker(function(marker) {
                if (marker.checkCollapsed()) { //collapsed
                    var _iNode = _createInline();
                    $tom.append(_iNode, _processor.newDummy());
                    $tom.insertNext(_iNode, marker.startMarker);
                    _processor.bookmarkTo({
                        startContainer: _iNode,
                        startOffset: 1,
                        endContainer: _iNode,
                        endOffset: 1
                    });
                    _nodes.push(_iNode);
                } else {
                    var _itr = _processor.getInlineRangeIterator(_patterns, marker.startMarker, marker.endMarker);
                    var _node;
                    while (_itr.hasNext()) {
                        _node = _itr.next();
                        if ($tom.kindOf(_node, '#tx_start_marker,#tx_end_marker')) {
                            //ignore
                        } else if ($tom.kindOf(_node, 'br')) {
                            //ignore
                        } else {
                            _nodes.push(_node);
                        }
                    }
                }
            });
        }
        return _nodes;
    },
    /**
     * 선택한 영역안에 있는 노드 중에 패턴을 만족하는 컨트롤 노드(img,object,hr,table,button)들을 리턴한다.
     * @param {Array} filter - 수집할 노드 패턴 조건
     * @returns {Array} - 선택한 영역안에 있는 노드 중에 패턴을 만족하는 노드들
     * @example
     * 	processor.controls(function() {
    		return 'hr,table';
    	});
     */
    controls: function(filter) {
        var _nodes = [];
        if (this.hasControl()) {
            if ($tom.kindOf(this.getControl(), filter())) {
                _nodes.push(this.getControl());
            }
        }
        return _nodes;
    },
    /**
     * 더미용 nbsp를 넣는 함수.
     * webkit 용에 구현되어있습니다.
     * Safari 에서 apply 시
     * 폰트에 대한 속성을 잃어버리기 때문에 필요.
     */
    addDummyNbsp: function() {},
    /**
     * 배열 내의 모든 노드에게 지정한 속성을 적용한다.
     * @param {Array} nodes - 속성을 적용할 노드 배열
     * @param {Object} attributes - 노드에 적용할 속성들
     * @returns {Array} - 입력 노드들
     * @example
     * 	processor.apply([p,p,p], { style: { textAlign: 'center'}});
     */
    apply: function(nodes, attributes) {
        if (!nodes) {
            return _NULL;
        }
        if (!nodes.length) {
            nodes = [].concat(nodes);
        }
        nodes.each(function(node) {
            $tom.applyAttributes(node, attributes);
        });
        return nodes;
    },
    /**
     * 배열 내의 모든 노드를 주어진 블럭으로 감싼다.
     * @param {Array} nodes - 블럭으로 감쌀 노드 배열
     * @param {String} tag - 블럭 노드 명
     * @param {Object} attributes - 블럭에 적용할 속성
     * @returns {Element} - 생성한 블럭노드
     * @example
     * 	processor.wrap([p,p,p], 'div', { style: { backgroundColor: 'black'}});
     */
    wrap: function(nodes, tag, attributes) {
        if (!nodes) {
            return _NULL;
        }
        if (!nodes.length) {
            nodes = [].concat(nodes);
        }
        attributes = attributes || {};
        var res = $tom.wrap(this.create(tag, attributes), nodes);
        if ($tx.msie && !$tom.nextContent(res)) {
            var e = this.doc.createElement('p');
            e.innerHTML = $tom.EMPTY_BOGUS;
            this.doc.body.appendChild(e);
        }
        return res;
    },
    /**
     * 블럭으로 감싸진 노드들을 빼내고 블럭을 삭제한다.
     * @param {Element} node - 블럭 노드
     * @returns {Element} - 블럭의 첫번째 노드 또는 블럭의 다음 노드
     * @example
     * 	processor.unwrap(node);
     */
    unwrap: function(node) {
        if (!node) {
            return _NULL;
        }
        this.bookmark.saveAroundNode(node);
        return $tom.unwrap(node);
    },
    createGoogRange: function() {
        return goog.dom.Range.createFromWindow(this.win)
    },
    createGoogRangeFromNodes: function(startNode, startOffset, endNode, endOffset) {
        return goog.dom.Range.createFromNodes(startNode, startOffset, endNode, endOffset);
    },
    executeUsingCaret: function(handler) {
        try {
            var range = this.createGoogRange();
            if(!range){
                this.doc.body.focus();
                range = this.createGoogRange();
            }
            var savedCaret = null;
            if(range.saveUsingCarets) savedCaret = range.saveUsingCarets();
            return handler(range, savedCaret);
        } finally {
            if (!savedCaret.isDisposed()) {
                savedCaret.restore();
            }
        }
    }
};

Trex.module("observe that @when control elements are focused at",
    function(editor, toolbar, sidebar, canvas) {
        if ($tx.webkit || $tx.presto) {
            canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev) {
                var _processor = canvas.getProcessor();
                var _node = $tx.element(ev);
                if ($tom.kindOf(_node, "img,hr,iframe,table")) {
                    var _button = $tom.find(_node, 'button');
                    if (_button) {
                        _processor.selectControl(_button);
                    } else {
                        _processor.selectControl(_node);
                    }
                } else if ($tom.kindOf(_node, "button")) {
                    _processor.selectControl(_node);
                }
            });
        }
    }
);

Trex.module("bind iframe activate or deactivate event",
    function(editor, toolbar, sidebar, canvas) {
        //        if ($tx.msie_nonstd) {
        canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(panelDoc) {
            var _processor = canvas.getProcessor(Trex.Canvas.__WYSIWYG_MODE);

            $tx.observe(panelDoc, 'beforedeactivate', function(ev) {
                _processor.isRangeInsideWysiwyg = true;
                _processor.lastRange = _processor.getRange();
            });

            $tx.observe(panelDoc, 'deactivate', function(ev) {
                if (_processor.hasControl()) {
                    return;
                }
                _processor.isRangeInsideWysiwyg = false;
            });

            $tx.observe(panelDoc, 'activate', function() {
                _processor.isRangeInsideWysiwyg = true;
                _processor.lastRange = _NULL;
            });
        });
        //        }
    }
);


Trex.I.Processor.Trident = {
    /**
     * Paragraph 를 채운다.
     * @private
     * @param {Node} node - paragraph 노드
     */
    stuffNode: function(node) {
        if ($tom.getLength(node) == 0) {
            node.innerHTML = '&nbsp;';
        }
        return node;
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorP
     * Trident에서 newlinepolicy가 p일 경우 Enter Key 이벤트가 발생하면 실행한다.
     */
    controlEnterByParagraph: function() {
        var _bNode = this.findNode('div');
        var _dvNode;
        if (!_bNode) {
            throw $propagate;
        }
        var _pNode = this.findNode('%paragraph');
        if ($tom.kindOf(_pNode, 'p')) {
            if ($tom.first(_bNode, 'p') == _pNode) {
                this.execWithMarker(function(marker) {
                    _dvNode = $tom.divideParagraph(marker.endMarker);
                });
                this.stuffNode(_pNode);
                this.stuffNode(_dvNode);
                this.moveCaretTo(_dvNode);
            } else {
                throw $propagate;
            }
        } else if ($tom.kindOf(_pNode, 'li,td,th,dd,dt')) {
            throw $propagate;
            // TODO KEDITOR
        } else if (_pNode && $(_pNode).hasClass('txc-textbox')) {
            _dvNode = this.newParagraph('p');
            this.execWithMarker(function(marker) {
                $tom.insertNext(_dvNode, marker.endMarker);
            });
            this.moveCaretTo(_dvNode);
        } else {
            throw $propagate;
            //  _dvNode = this.newParagraph('p');
            // this.execWithMarker(function(marker) {
            // 	$tom.insertNext(_dvNode, marker.endMarker);
            // });
            // this.moveCaretTo(_dvNode);
        }
    }
};

Trex.module("delete image element @when backspace key event fires",
    function(editor, toolbar, sidebar, canvas) {
        if ($tx.msie_nonstd) {
            canvas.observeKey({
                ctrlKey: _FALSE,
                altKey: _FALSE,
                shiftKey: _FALSE,
                keyCode: Trex.__KEY.BACKSPACE
            }, function() {
                var _processor = canvas.getProcessor();
                if (_processor.hasControl() && _processor.getControl()) {
                    try {
                        var _node = _processor.getControl();
                        $tom.remove(_node);
                    } catch (e) {}
                    throw $stop;
                }
                throw $propagate;
            });
        }
    }
);


/*-------------------------------------------------------*/

Object.extend(Trex.I.Processor.Trident, {
    restoreRange: function() { //TODO: rename
        if (!this.isRangeInsideWysiwyg && this.lastRange) {
            try {
                this.lastRange.select();
            } catch (e) {
                var _sel = this.getSel();
                var _type = _sel.type.toLowerCase();
                if (_type === "control") {
                    _sel.empty();
                    var _rng = _sel.createRange();
                    _rng.collapse(_FALSE);
                    _rng.select();
                }
            } finally {
                this.lastRange = _NULL;
            }
        }
    }
});

Trex.I.Processor.TridentStandard = {
    /**
     * Paragraph 를 채운다.
     * @private
     * @param {Node} node - paragraph 노드
     */
    stuffNode: function(node) {
        return $tom.stuff(node, this.newNode('br'));
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorP
     * Webkit에서 newlinepolicy가 p일 경우 Enter Key 이벤트가 발생하면 실행한다.
     * @param {Event} ev - Enter Key 이벤트
     */
    controlEnterByParagraph: function(ev) {
        /**
         * <p><span><br></span></p> 구조에서 Enter를 입력하면
         * <p></p>
         * <p></p>
         * <span><p>...</p></span>
         * 구조로 되는 문제 처리
         */
        var _rng = this.getRange(false);
        var node = _rng.endContainer;
        if((node.nodeType == 1 && node.nodeName != "P") 
            && node.childNodes.length == 1 && node.childNodes[0].nodeName == "BR") {
            $tom.remove(node.childNodes[0]);
            // var tmp = this.doc.createTextNode(Trex.__WORD_JOINER);
            // node.appendChild(tmp);
        // }else if(node.childNodes.length == 1 && node.childNodes[0].nodeName == "SPAN"
        //     && (node.childNodes[0].childNodes.length == 0 
        //         || (node.childNodes[0].childNodes.length == 1 && node.childNodes[0].childNodes[0].nodeName == "BR")
        //         || (node.childNodes[0].childNodes.length == 1 && node.childNodes[0].childNodes[0].nodeName == "SPAN"
        //             && (node.childNodes[0].childNodes[0].childNodes.length  == 0
        //                 || (node.childNodes[0].childNodes[0].childNodes.length == 1 && node.childNodes[0].childNodes[0].childNodes[0].nodeName == "BR")
        //             )
        //         )
        //     )
        // ) {
        }else if(node.childNodes.length == 1){
            /**
             * Enter 입력 후 새 줄이 <p><span><span><br></span></span></p> 구조가 된 경우 바로 enter를 입력하면 브라우져 다운됨.
             * Enter 입력 후 새 줄이 <p><span><span></span><br></span></p> 구조가 된 경우 바로 enter를 입력하면 브라우져 다운됨.
             */
            var _check = false;
            var _loop = node.childNodes[0];
            var _limit = 10;
            while(_loop){
                _limit--;
                if(_limit < 0) {
                    _check = false;
                    break;
                }
                if(_loop.childNodes && _loop.childNodes.length <= 1 
                    && (_loop.nodeName == "BR" || _loop.nodeName == "SPAN" || _loop.nodeName == "STRONG" 
                        || _loop.nodeName == "B" || _loop.nodeName == "U" || _loop.nodeName == "I" 
                        || _loop.nodeName == "EM"  || _loop.nodeName == "STRIKE")){
                    _loop = _loop.childNodes[0];
                    _check = true;
                }else{
                    _check = false;
                    break;
                }
            }
            if(_check) $tom.remove(node.childNodes[0]);
        }else if(node.childNodes.length == 0 && 
            node.nextSibling && node.nextSibling.nodeName == "BR" &&
            node.parentNode.childNodes.length  == 2 &&
            (node.parentNode.nodeName == "SPAN" || node.parentNode.nodeName == "STRONG" || node.parentNode.nodeName == "B" 
                || node.parentNode.nodeName == "U" || node.parentNode.nodeName == "I" 
                || node.parentNode.nodeName == "EM"  || node.parentNode.nodeName == "STRIKE")
        ){
            $tom.remove(node.nextSibling);
        }
        throw $propagate;
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorBR
     * Webkit에서 newlinepolicy가 br일 경우 Enter Key 이벤트가 발생하면 실행한다.
     * @param {Event} ev - Enter Key 이벤트
     */
    controlEnterByLinebreak: function(ev) {
        var _processor = this;
        var _rng = this.getRange(false);
        var _parent = _rng.endContainer.parentNode;

        if (_parent && (_parent.tagName == "P" || _parent.tagName == "DIV" || _parent.tagName == "BODY" || _parent.tagName == "BLOCKQUOTE")) {

            if (_parent.tagName == "BLOCKQUOTE" || $tx.hasClassName(_parent, "txc-textbox") || $tx.hasClassName(_parent, "txc-moreless")) {
                $tx.stop(ev);
                var _brNode = _processor.win.br();
                _rng.insertNode(_brNode);
                _rng.selectNode(_brNode);
                _rng.collapse(false);
                _brNode = _processor.win.br();
                _rng.insertNode(_brNode);
                _rng.selectNode(_brNode);
                _rng.collapse(false);

                var _rng = _processor.getRange(false);
                _rng.selectNodeContents(_brNode.nextSibling);

                var _sel = _processor.getSel();
                _sel.removeAllRanges();
                _sel.addRange(_rng);
                _sel.collapseToStart();
            }
        }
    },
    /**
     * 선택된 영역의 native queryCommandState 값을 얻어온다.
     * @param {String} command - 커맨드 명
     * @returns {Boolean} - 해당 영역이 커맨드 상태인지 여부
     * @example
     * 	processor.queryCommandState('bold');
     * @description
     * webkit 계열의 브라우저(크롬,사파리)에서 img 에 대한 queryCommandState 가 부정확하여 수정.
     */
    queryCommandState: function(command) {
        var range = this.getRange();
        if (this.hasControl() && range.collapsed === _FALSE && range.endOffset - range.startOffset === 1) {
            if (command === "bold" || command === "underline" || command === "italic" || command === "strikethrough") {
                var elem = this.getControl();
                if (elem.tagName === "IMG" || elem.tagName === "BUTTON") {
                    return _FALSE;
                }
            }
        } //<-여기까지 webkit 계열의 브라우저 queryCommandState 에러 처리.
        //위 코드와 관련된 티켓: #FTDUEDTR-1107
        try {
            return this.doc.queryCommandState(command);
        } catch (e) { return _FALSE; }
    },
    /**
     * for safari bug. 빈노드에 글자크기, 글자폰트 기억 못시킴.
     */
    addDummyNbsp: function(nodes) {
        var _node;
        if (nodes.length === 1) {
            _node = nodes[0];
            if (_node.tagName.toLowerCase() === "span" &&
                _node.childNodes.length === 1 &&
                _node.firstChild.nodeType === 3 &&
                _node.firstChild.data === "") {
                _node.firstChild.data = "\u00A0";
            }
        }
    }
};


/*-------------------------------------------------------*/

Object.extend(Trex.I.Processor.TridentStandard, {
    restoreRange: function() { //TODO: rename
        if (!this.isRangeInsideWysiwyg && this.lastRange) {
            var sc =  this.lastRange.startContainer;
            if(sc && sc.nodeType == 1 && sc.nodeName == "BODY") return;
            var _sel = this.getSel();
            _sel.removeAllRanges();
            _sel.addRange(this.lastRange);
        }
    }
});

Trex.I.Processor.Gecko = {
    /**
     * Paragraph 를 채운다.
     * @private
     * @param {Node} node - paragraph 노드
     */
    stuffNode: function(node) {
        return $tom.stuff(node, this.newNode('br'));
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorP
     * Gecko에서 newlinepolicy가 p일 경우 Enter Key 이벤트가 발생하면 실행한다.
     * @param {Event} ev - Enter Key 이벤트
     */
    controlEnterByParagraph: function() {
        throw $propagate;
    }
};

Trex.I.Processor.Webkit = {
    /**
     * Paragraph 를 채운다.
     * @private
     * @param {Node} node - paragraph 노드
     */
    stuffNode: function(node) {
        return $tom.stuff(node, this.newNode('br'));
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorP
     * Webkit에서 newlinepolicy가 p일 경우 Enter Key 이벤트가 발생하면 실행한다.
     */
    controlEnterByParagraph: function() {
        throw $propagate;
    },
    findParagraph: function(node) {
        var matched = function(node) {
            return $tom.kindOf(node, "div,p,blockquote");
        };
        var mustStop = function(node) {
            return $tom.kindOf(node, "body,li,%tablegroup");
        };
        return $tom.findAncestor(node, matched, mustStop);
    },
    findAncestorListItem: function(node) {
        var matched = function(node) {
            return $tom.kindOf(node, "li");
        };
        var mustStop = function(node) {
            return $tom.kindOf(node, "body,%tablegroup");
        };
        return $tom.findAncestor(node, matched, mustStop);
    },
    divideListItem: function(li) {
        var newLi, self = this;
        self.execWithMarker(function(marker) {
            newLi = $tom.divideTree(li, marker.endMarker);
        });

        if (!$tom.hasUsefulChildren(li, _TRUE)) {
            li.innerHTML = "";
        }
        if (!$tom.hasUsefulChildren(newLi, _TRUE)) {
            newLi.innerHTML = "";
        }
        self.stuffNode(li);
        self.stuffNode(newLi);
        self.moveCaretTo(newLi);
    },
    /**
     * 선택된 영역의 native queryCommandState 값을 얻어온다.
     * @param {String} command - 커맨드 명
     * @returns {Boolean} - 해당 영역이 커맨드 상태인지 여부
     * @example
     * 	processor.queryCommandState('bold');
     * @description
     * webkit 계열의 브라우저(크롬,사파리)에서 img 에 대한 queryCommandState 가 부정확하여 수정.
     */
    queryCommandState: function(command) {
        var range = this.getRange();
        if (this.hasControl() && range.collapsed === _FALSE && range.endOffset - range.startOffset === 1) {
            if (command === "bold" || command === "underline" || command === "italic" || command === "strikethrough") {
                var elem = this.getControl();
                if (elem.tagName === "IMG" || elem.tagName === "BUTTON") {
                    return _FALSE;
                }
            }
        } //<-여기까지 webkit 계열의 브라우저 queryCommandState 에러 처리.
        //위 코드와 관련된 티켓: #FTDUEDTR-1107
        try {
            return this.doc.queryCommandState(command);
        } catch (e) { return _FALSE; }
    },
    /**
     * for safari bug. 빈노드에 글자크기, 글자폰트 기억 못시킴.
     */
    addDummyNbsp: function(nodes) {
        var _node;
        if (nodes.length === 1) {
            _node = nodes[0];
            if (_node.tagName.toLowerCase() === "span" &&
                _node.childNodes.length === 1 &&
                _node.firstChild.nodeType === 3 &&
                _node.firstChild.data === "") {
                _node.firstChild.data = "\u00A0";
            }
        }
    }
};


Trex.I.Processor.Presto = {
    /**
     * Paragraph 를 채운다.
     * @private
     * @param {Node} node - paragraph 노드
     */
    stuffNode: function(node) {
        return $tom.stuff(node, this.newNode('br'));
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorP
     * Presto에서 newlinepolicy가 p일 경우 Enter Key 이벤트가 발생하면 실행한다.
     * @param {Event} ev - Enter Key 이벤트
     */
    controlEnterByParagraph: function(ev) {
        throw $propagate;
    }
};



Trex.I.Processor.StandardP = {
    putBogusParagraph: function() {
        var _body = this.doc.body;
        var _lastChild = $tom.last(_body);
        if (_lastChild && ($tom.kindOf(_lastChild, 'p') || $tom.kindOf(_lastChild, 'div'))) {
            return;
        }
        var _newChild = this.newParagraph('p');
        if ($tom.kindOf(_lastChild, "br")) {
            $tom.replace(_lastChild, _newChild);
        } else {
            $tom.append(_body, _newChild);
        }
    }
};


Trex.module("put bogus paragraph @when any key event fires",
    function(editor, toolbar, sidebar, canvas) { //NOTE: #FTDUEDTR-695
        if ($tx.msie_nonstd) {
            return;
        }
        if (canvas.config.newlinepolicy == "p") {
            canvas.reserveJob(Trex.Ev.__CANVAS_PANEL_KEYUP, function() {
                if (!canvas.isWYSIWYG()) {
                    return;
                }
                var _processor = canvas.getProcessor();
                _processor.putBogusParagraph();
            }, 10);
        }
    }
);

Trex.module("interrupt enter key action @ wysiwyg panel", function(editor, toolbar, sidebar, canvas /*, config*/ ) {
    var _config = TrexConfig.get('canvas');
    if (_config.newlinepolicy != "p") {
        return;
    }

    canvas.observeKey({
        ctrlKey: _FALSE,
        altKey: _FALSE,
        shiftKey: _FALSE,
        keyCode: Trex.__KEY.ENTER
    }, function(ev) {
        if (!canvas.isWYSIWYG()) {
            return;
        }
        var _processor = canvas.getProcessor();
        try {
            _processor.getTxSel().collapse(_FALSE);
            _processor.controlEnterByParagraph(ev);
        } catch (e) {
            if (e == $propagate) {
                throw e;
            }
        }
    });
});


Trex.I.Processor.TridentP = {

};


Trex.I.Processor.TridentStandardP = {

};

Trex.I.Processor.GeckoP = {

};

Trex.I.Processor.WebkitP = {

};

Trex.I.Processor.PrestoP = {

};

(function() {
    var BlockRangeIterator = Trex.Class.create({
        initialize: function(processor, patterns, start, end) {
            this.processor = processor;
            this.start = start;
            this.end = end || this.start;
            this.current = this.start;

            this.wTranslator = $tom.translate(patterns).extract('%wrapper');
            this.pTranslator = $tom.translate(patterns).extract('%paragraph');
        },
        hasNext: function() {
            return !!this.current;
        },
        next: function() {
            var _current = this.current;
            _current = this.find(_current);

            var _next = _current;

            if ($tom.include(_current, this.end)) {
                _next = _NULL;
            } else {
                while (_next && !$tom.next(_next)) {
                    _next = $tom.parent(_next);
                    if ($tom.isBody(_next)) {
                        _next = _NULL;
                    }
                }
                if (_next) {
                    _next = $tom.next(_next);
                }
            }
            if (_next == this.end) {
                _next = _NULL;
            }
            this.current = _next;
            return _current;
        },
        find: function(node) {
            var _bNode;
            var _node = node;

            if (!$tom.hasContent(_node)) {
                return _node;
            }

            while (_node) {
                _bNode = _node;
                if ($tom.isBody(_node)) {
                    break;
                }

                if ($tom.kindOf(_node, this.wTranslator.getExpression())) {
                    return _node;
                }

                if ($tom.kindOf(_node, '%wrapper,%outergroup')) {
                    _node = $tom.descendant(_bNode, this.pTranslator.getExpression());
                    if (_node) {
                        return _node;
                    }
                    _node = $tom.descendant(_bNode, '%paragraph');
                    if (_node) {
                        _bNode = _node;
                        break;
                    }
                }

                if ($tom.kindOf(_node, this.pTranslator.getExpression())) {
                    return _node;
                }
                if (_node.nextSibling && _node.nodeType == 3) {
                    // BlockIterator 이니까 TextNode 는 찾는 대상이 아님.
                    _node = _node.nextSibling;
                } else {
                    _node = _node.parentNode;
                }
            }
            var _innerName = $tom.paragraphOf($tom.getName(_bNode));
            var _wNode = this.processor.newNode(_innerName);
            var _pNodes = $tom.extract(_bNode, node, '%text,%inline,img,object,embed,hr');
            $tom.wrap(_wNode, _pNodes);
            this.processor.stuffNode(_wNode);
            return _wNode;
        }
    });

    Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */ {
        /**
         * @private
         * 선택한 영역안에 있는 노드 중에 패턴을 만족하는 블럭 노드들을 리턴한다.
         * @param {String} pattern - 수집할 노드 패턴 조건
         * @param {Element} start - 시작하는 노드(#tx_start_marker)
         * @param {Element} end - 끝나는 노드(#tx_end_marker)
         * @returns {Array} - 선택한 영역안에 있는 노드 중에 패턴을 만족하는 노드들
         * @example
         * 	processor.getBlockRangeIterator('div,p,li', node, node);
         */
        getBlockRangeIterator: function(pattern, start, end) {
            return new BlockRangeIterator(this, pattern, start, end);
        }
    });
})();

(function() {
    var InlineRangeIterator = Trex.Class.create({
        initialize: function(processor, patterns, start, end) {
            this.processor = processor;
            this.start = start;
            this.end = end || this.start;
            this.current = this.start;

            this.iTranslator = $tom.translate(patterns).extract('%inline');
        },
        hasNext: function() {
            return !!this.current;
        },
        next: function() {
            var _current = this.current;
            _current = this.find(_current);

            var _next = _current;
            if (_current == this.end) {
                _next = _NULL;
            } else {
                while (_next && !$tom.next(_next)) {
                    _next = $tom.parent(_next);
                    if ($tom.isBody(_next)) {
                        _next = _NULL;
                    }
                }
                if (_next) {
                    _next = $tom.next(_next);
                }
            }
            if ($tom.include(_next, this.end)) {
                _next = $tom.top(_next, _TRUE);
            }
            this.current = _next;
            return _current;
        },
        find: function(node) {
            var _node = node;
            if ($tom.kindOf(_node, '%paragraph,%outergroup,%block') || $tom.isBody(_node)) {
                var _bNode = _node;
                _node = $tom.top(_bNode, _TRUE);
                if (!_node) {
                    var _innerName = $tom.inlineOf();
                    var _iNode = this.processor.create(_innerName);
                    $tom.append(_bNode, _iNode);
                    return _iNode;
                }
            }

            if ($tom.kindOf(_node, 'br')) {
                return _node;
            } else if (!$tom.hasContent(_node)) {
                return _node;
            }

            if ($tom.kindOf(_node, this.iTranslator.getExpression())) {
                return _node;
            }

            var _innerName = $tom.inlineOf();
            var _iNode = this.processor.create(_innerName);
            $tom.insertAt(_iNode, _node);
            if (_node) {
                $tom.append(_iNode, _node);
            }
            return _iNode;
        }
    });

    Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */ {
        /**
         * @private
         * 선택한 영역안에 있는 노드 중에 패턴을 만족하는 인라인 노드들을 리턴한다.
         * @param {String} pattern - 수집할 노드 패턴 조건
         * @param {Element} start - 시작하는 노드(#tx_start_marker)
         * @param {Element} end - 끝나는 노드(#tx_end_marker)
         * @returns {Array} - 선택한 영역안에 있는 노드 중에 패턴을 만족하는 노드들
         * @example
         * 	processor.getInlineRangeIterator('span,font,a', node, node);
         */
        getInlineRangeIterator: function(pattern, start, end) {
            return new InlineRangeIterator(this, pattern, start, end);
        }
    });
})();

(function() {
    var __CACHING_DOC = _NULL;
    var __CACHING_NODE = {};
    var __CACHING_PARAGRAPH = {};
    Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */ {
        /**
         * 노드를 생성하여 리턴한다. 캐싱을 사용하여 이미 생성했던 노드는 복사한다.
         * @private
         * @param {String} name - 노드명
         * @example
         * 	processor.newNode('div');
         */
        newNode: function(name) {
            if (__CACHING_DOC != this.doc) {
                __CACHING_NODE = {};
                __CACHING_DOC = this.doc;
            }
            if (!__CACHING_NODE[name]) {
                __CACHING_NODE[name] = this.win[name]();
            }
            return $tom.clone(__CACHING_NODE[name], _FALSE);
        },
        /**
         * 텍스트 노드를 생성한다.
         * @private
         * @param {String} text - 텍스트내용
         */
        newText: function(text) {
            return this.doc.createTextNode(text);
        },
        /**
         * 노드를 생성하여 리턴한다. 캐싱을 사용하여 이미 생성했던 노드는 복사한다.
         * @private
         * @param {String} name - 노드명
         * @example
         * 	processor.newParagraph('p');
         */
        newParagraph: function(name) {
            if (__CACHING_DOC != this.doc) {
                __CACHING_PARAGRAPH = {};
                __CACHING_DOC = this.doc;
            }
            if (!__CACHING_PARAGRAPH[name]) {
                __CACHING_PARAGRAPH[name] = this.stuffNode(this.newNode(name));
            }
            return $tom.clone(__CACHING_PARAGRAPH[name], _TRUE);
        }
    });
})();


(function() {
    var __CACHING_DOC = _NULL;
    var __CACHING_NODE = _NULL;
    var __HAS_DUMMY = _FALSE;
    var __TEXT_GC_LIST = [];

    Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */ {
        /**
         * 빈 텍스트 노드를 생성한다.
         * @private
         * @param {Boolean} keep - 계속 유지할 것인지 여부 optional
         */
        newDummy: function(keep) {
            if (__CACHING_DOC != this.doc) {
                __CACHING_NODE = _NULL;
                __TEXT_GC_LIST = [];
                __CACHING_DOC = this.doc;
            }
            if (!__CACHING_NODE) {
                __CACHING_NODE = this.doc.createTextNode(Trex.__WORD_JOINER);
            }
            var _dummy = $tom.clone(__CACHING_NODE);
            if (!keep) {
                __TEXT_GC_LIST.push(_dummy);
                __HAS_DUMMY = _TRUE;
            }
            //            try {
            //                throw new Error();
            //            } catch (e) {
            //                console.log((++newDummyCalled) + "\n" + e.stack);
            //            }
            return _dummy;
        },
        /**
         * 생성된 빈 텍스트 노드들을 삭제한다.
         * @private
         */
        /* TODO
         * Bug : __TEXT_GC_LIST에 저장된 dummy를 splitText를 하면, reference가 사라지는 효과가 발생한다.
         * dummy를 넣기 위한 splitText 부분을 수정할 필요가 있다.
         * startConatiner를 지우면 (현재까지 확인된 바에 따르면) Chrome에서는 커서가 사라지고 더 이상 range를 가져오지 못하게 된다.
         */
        clearDummy: function() {
            if (!__HAS_DUMMY) {
                return;
            }
            var range, startNode;
            try {
                range = this.createGoogRange();
                startNode = range && range.getStartNode();
            } catch (ignore4ie678) {}

            var remained = _NULL;
            //            console.log(__TEXT_GC_LIST.length);
            for (var i = 0, len = __TEXT_GC_LIST.length - 1; i < len; i++) {
                try {
                    var _dummy = __TEXT_GC_LIST.shift();
                    //                    console.log(!!(_dummy && _dummy.nodeValue))
                    if (_dummy && _dummy.nodeValue) {
                        if (_dummy.nodeValue == Trex.__WORD_JOINER) {
                            if (startNode != _dummy) {
                                //                                console.log('remove');
                                $tom.remove(_dummy);
                            } else {
                                remained = _dummy;
                            }
                        } else {
                            //                            console.log('replace');
                            _dummy.nodeValue = _dummy.nodeValue.replace(Trex.__WORD_JOINER_REGEXP, "");
                        }
                    } else {
                        //                        console.log("this's not dummy");
                    }
                } catch (e) {}
            }
            remained && __TEXT_GC_LIST.splice(0, 0, remained);
            __HAS_DUMMY = _FALSE;
        }
    });
})();

/**
 * Wysiwyg 영역의 컨텐츠를 조작하기 위해 사용되며,  <br/>
 * browser와 newlinepolicy에 따라 필요한 함수들을 mixin한다. <br/>
 * 이 객체를 통해서 Bookmark, txSelection, Marker 객체에 접근한다. <br/>
 * canvas.getProcessor()를 통해서 얻거나 <br/>
 * canvas.execute(), canvas.query()를 통해서 processor를 얻어서 사용한다. <br/>
 *
 * @abstract
 * @class
 * @param {Object} win - Wysiwyg 영역의 window 객체
 * @param {Object} doc - Wysiwyg 영역의 document 객체
 *
 * @example
 *	canvas.execute(function(processor) {
 *		processor.pasteContent('<img />', _FALSE);
 *	});
 *
 *	var value = canvas.query(function(processor) {
 *		return processor.getText();
 *	});
 *
 *	var _processor = canvas.getProcessor();
 *	_processor.focusOnTop();
 */
Trex.Canvas.Processor = Trex.Class.draft({
    /** @ignore */
    $mixins: [
        Trex.I.Processor.Standard,
        (($tx.msie_nonstd) ? Trex.I.Processor.Trident : {}),
        (($tx.msie_std) ? Trex.I.Processor.TridentStandard : {}),
        (($tx.gecko) ? Trex.I.Processor.Gecko : {}),
        (($tx.webkit) ? Trex.I.Processor.Webkit : {}),
        (($tx.presto) ? Trex.I.Processor.Presto : {})
    ]
});

/**
 * newlinepolicy가 p인 Wysiwyg Processor
 * @class
 * @extends Trex.Canvas.Processor
 * @param {Object} win - Wysiwyg 영역의 window 객체
 * @param {Object} doc - Wysiwyg 영역의 document 객체
 */
Trex.Canvas.ProcessorP = Trex.Class.create({
    /** ignore */
    $extend: Trex.Canvas.Processor,
    /** @ignore */
    $mixins: [
        Trex.I.Processor.StandardP,
        (($tx.msie_nonstd) ? Trex.I.Processor.TridentP : {}),
        (($tx.msie_std) ? Trex.I.Processor.TridentStandardP : {}),
        (($tx.gecko) ? Trex.I.Processor.GeckoP : {}),
        (($tx.webkit) ? Trex.I.Processor.WebkitP : {}),
        (($tx.presto) ? Trex.I.Processor.PrestoP : {})
    ]
});

Trex.register("filter > mode change", function(editor, toolbar, sidebar, canvas, config) {

    /* -> Text Convert */
    function toText(html) {
        // FTDUEDTR-1360
        var filterList = [
            [Trex.__WORD_JOINER_REGEXP, ""], // word_joiner 제거
            //모든 태그 속성제거
            [new RegExp("<(\\/?[a-z]+)[^>]*>", "gi"), "<$1>"],
            //모든 태그 줄바꿈 제거
            [new RegExp("\\n\\s*", "g"), ""],
            //head, script, style, 주석 제거
            [new RegExp("<head>.*?<\\/head>", "gi"), ""], //<head ~ <\\/head> delete
            [new RegExp("<s" + "cript>.*?<\\/s" + "cript>", "gi"), ""],
            [new RegExp("<style>.*?<\\/style>", "gi"), ""], //<style ~ <\\/style> delete
            [new RegExp("<!--.*?-->", "gi"), ""], //comment delete
            //빈 태그삭제
            [new RegExp("<span></span>", "gi"), ""], //<br>
            //기본태그삭제
            [new RegExp("^<p>&nbsp;</p>$", "gi"), ""],
            [new RegExp("^<p><br></p>$", "gi"), ""],
            //테이블 처리.
            [new RegExp("<td>(.+?)<\\/td>", "gi"), "\t$1"], //<td>
            [new RegExp("<th>(.+?)<\\/th>", "gi"), " \t$1"], //<th>
            [new RegExp("<\\/tr>", "gi"), ""], //</tr>
            [new RegExp("<tr>", "gi"), "\n"], //<tr>
            [new RegExp("<\\?tbody>", "gi"), ""], //<tbody> 14
            //개행 처리
            [new RegExp("<div>([^<]*)<\\/div>", "gi"), "\n$1"],
            [new RegExp("<p>&nbsp;</p>", "gi"), "\n"],
            [new RegExp("<p><br></p>", "gi"), "\n"],
            [new RegExp("<br>(<\\/p>)", "gi"), "$1"],
            [new RegExp("<h[1-6]>(.+?)<\\/h[1-6]>", "gi"), "\n$1\n\n"], //<h1(h6) ~ <\\/h1(h6]> 제거
            [new RegExp("(<p>(.+?)<\\/p>)", "gi"), "$1\n"], //<td>
            [new RegExp("<br>\\n", "gi"), "\n"], //<br>+개행
            [new RegExp("<br>", "gi"), "\n"], //<br>
            [new RegExp("(<ul>|<\\/ul>|<ol>|<\\/ol>|<\\/table>)", "gi"), "\n\n"], //<ul>
            //공백 처리
            [new RegExp("(<li>(.+?)<\\/li>)", "gi"), "\t$1\n"], //<li>
            //나머지 모든 태그 삭제
            [new RegExp("<div><\\/div>\n", "gi"), "~"],
            [new RegExp("<[\\/a-zA-Z!]+>", "g"), ""],
            //특수문자 치환
            [new RegExp("&nbsp;?", "g"), " "],
            [new RegExp("&quot;?", "g"), "\""],
            [new RegExp("&gt;?", "g"), '>'],
            [new RegExp("&lt;?", "g"), '<'],
            [new RegExp("&amp;?", "g"), '&'],
            [new RegExp("&copy;?", "g"), '(c)'],
            [new RegExp("&trade;?", "g"), '(tm)'],
            [new RegExp("&#8220;?", "g"), "\""],
            [new RegExp("&#8221;?", "g"), "\""],
            [new RegExp("&#8211;?", "g"), "_"],
            [new RegExp("&#8217;?", "g"), "'"],
            [new RegExp("&#38;?", "g"), "&"],
            [new RegExp("&#169;?", "g"), "(c)"],
            [new RegExp("&#8482;?", "g"), "(tm)"],
            [new RegExp("&#151;?", "g"), "--"],
            [new RegExp("&#039;?", "g"), "'"],
            [new RegExp("&#147;?", "g"), "\""],
            [new RegExp("&#148;?", "g"), "\""],
            [new RegExp("&#149;?", "g"), "*"],
            [new RegExp("&reg;?", "g"), "(R]"],
            [new RegExp("&bull;?", "g"), "*"]
        ];


        var tmp = html;
        for (var i = 0; i < filterList.length; i++) {
            tmp = tmp.replace(filterList[i][0], filterList[i][1]);
        }
        return tmp;
    }

    function brn2n(html) {
        try {
            return html.replace(new RegExp("<br[^>]*>\\n", "gi"), "\n");
        } catch (ignore) {}
        return html;
    }

    function fromText(txt) {
        if (txt !== _NULL && txt.length !== 0) {
            txt = txt.replace(/&/g, "&amp;");
            txt = txt.replace(/ /g, "&nbsp;");
            txt = txt.replace(/\"/g, "&quot;");
            txt = txt.replace(/>/g, "&gt;");
            txt = txt.replace(/</g, "&lt;");
            if (txt.lastIndexOf("\n") === txt.length - 1) {
                txt = txt.substr(0, txt.length - 1);
            }
            if (txt.lastIndexOf("\r") === txt.length - 1) {
                txt = txt.substr(0, txt.length - 1);
            }
            txt = txt.replace(/\r\n|\r|\n/g, "<br>\n");
        }
        return txt;
    }

    // FTDUEDTR-794 : new line formatting on the source mode.
    function addNewlineToSource(html) {
        return html.replace(/<\/(p)><(p[\s>])/gi, '</$1>\n<$2');
    }

    function removeNewlineFromSource(source) {
        return source.replace(/<\/(p)>\n+<(p[\s>])/gi, '</$1><$2');
    }

    // FTDUEDTR-1387
    function removeEditorOriginDomain(content) {
        if (!($tx.msie && $tx.msie_docmode < 9))
            return content;
        if (!canvas.isWYSIWYG())
            return content;

        var wysiwygLocation = canvas.getCurrentPanel().getWindow().location,
            wysiwygLocationHost = wysiwygLocation.protocol + '//' + wysiwygLocation.host,
            wysiwygLocationHref = wysiwygLocation.href,
            editorHostPath = wysiwygLocationHref.substring(0, wysiwygLocationHref.lastIndexOf('/') + 1),
            hrefRegexPattern = new RegExp("(href=[\"'])" +
                "(" + wysiwygLocationHost.getRegExp() + "[^\"']*)" +
                "([\"'])", "gi");

        return content.replace(hrefRegexPattern, function(match, p1_prefix, p2_url, p3_postfix /*, offset, string*/ ) {
            var url = p2_url.replace(wysiwygLocationHref, '').
            replace(editorHostPath, '').
            replace(wysiwygLocationHost, '');
            return p1_prefix + url + p3_postfix;
        });
    }

    var _docparser = editor.getDocParser();
    _docparser.registerFilter('filter/converting', {
        'text@load': function(contents) {
            return toText(contents);
        },
        'source@load': function(contents) {
            return contents;
        },
        'html@load': function(contents) {
            return contents;
        },
        'text4save': function(contents) {
            var content;
            if (config.canvas.escapeTextModeContents) {
                content = fromText(contents);
            } else {
                content = contents;
            }
            if (config.canvas.removeTextModeBr) {
                content = brn2n(content);
            }
            return content;
        },
        'source4save': function(contents) {
            return contents;
        },
        'html4save': function(contents) {
            return removeEditorOriginDomain(contents);
        },
        'text2source': function(contents) {
            return fromText(contents);
        },
        'text2html': function(contents) {
            return fromText(contents);
        },
        'source2text': function(contents) {
            return toText(removeNewlineFromSource(contents));
        },
        'source2html': function(contents) {
            return removeNewlineFromSource(contents);
        },
        'html2text': function(contents) {
            return toText(contents);
        },
        'html2source': function(contents) {
            return removeEditorOriginDomain(addNewlineToSource(contents));
        }
    });
});



Trex.register("filter > non-breaking space", function(editor /*, toolbar, sidebar, canvas, config*/ ) {

    function convertNonBreakingSpaceToNoramlSpace(contents) {
        return contents.replace(/\u00A0/g, ' ');
    }

    var _docparser = editor.getDocParser();
    _docparser.registerFilter('filter/converting/nonbreakingsapce', {
        'text@load': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'source@load': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'html@load': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'text4save': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'source4save': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'html4save': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        //        'text2source': function(contents) {
        //            return contents;
        //        },
        'text2html': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        //        'source2text': function(contents) {
        //            return contents;
        //        },
        'source2html': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        //        'html2text': function(contents) {
        //            return contents;
        //        },
        'html2source': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        }
    });
});
Trex.register("filter > clear redundancy",
    function(editor) {
        function clearRedundancy(contents) {
            var clearHandler = function(content, style, loop) {
                var matchCount = 0;
                var matchHandler = function(all, value, text) {
                    matchCount++;
                    if (text.length == 0 || text.trim().length == 0) {
                        return "";
                    } else {
                        return ['<span style="', style, ':', value, ';">', text, '</span>'].join("");
                    }
                };
                var regex = new RegExp("(?:<span[^>;]*style=\"" + style + ":[^\";]*;?\"[^>;]*>){" + loop + "}<span\\s*style=['\"]?" + style + ":\\s*(\\w+)[;'\"]*>([\\S\\s]*?)<\/span>(?:<\/span>){" + loop + "}", "gi"); //#FTDUEDTR-1119
                do {
                    matchCount = 0;
                    content = content.replace(regex, matchHandler);
                } while (matchCount > 0);

                return content;
            };

            contents = contents.replace(/<(span|font)([^>]*)><\/\1>/gi, function(fullMatched, tagName, subMatched) {
                if (/ (?:id|class)=/i.test(subMatched)) { //NOTE: #FTDUEDTR-1041
                    return fullMatched;
                }
                return "";
            });

            var styles = ['font-size', 'font-family'];
            for (var i = 0; i < styles.length; i++) {
                contents = clearHandler(contents, styles[i], 2);
                contents = clearHandler(contents, styles[i], 1);
            }
            return contents;
        }

        function removeSpacerParagraph(contents) {
            // FTDUEDTR-1319
            return $tx.msie ? contents.replace(/<p>\s*<\/p>/gi, '') : contents;
        }

        function makeSpacerParagraph(contents) {
            // FTDUEDTR-1319
            return $tx.msie ? contents.replace(/<p>\s*<\/p>/gi, $tom.EMPTY_PARAGRAPH_HTML) : contents;
        }

        var docparser = editor.getDocParser();
        docparser.registerFilter(
            'filter/redundancy', {
                'text@load': function(contents) {
                    return contents;
                },
                'source@load': function(contents) {
                    return removeSpacerParagraph(clearRedundancy(contents));
                },
                'html@load': function(contents) {
                    return removeSpacerParagraph(clearRedundancy(contents));
                },
                'text4save': function(contents) {
                    return contents;
                },
                'source4save': function(contents) {
                    return makeSpacerParagraph(contents);
                },
                'html4save': function(contents) {
                    return makeSpacerParagraph(contents);
                },
                'text2source': function(contents) {
                    return contents;
                },
                'text2html': function(contents) {
                    return contents;
                },
                'source2text': function(contents) {
                    return contents;
                },
                'source2html': function(contents) { //source2wysiwyg
                    return contents;
                },
                'html2text': function(contents) {
                    return contents;
                },
                'html2source': function(contents) { //wysiwyg2source
                    return clearRedundancy(contents);
                }
            }
        );
    }
);

/**
 * @fileoverview
 * attachments.js
 *
 */
TrexMessage.addMsg({
    '@attacher.only.wysiwyg.alert': Trex._I18N.g('attacher.only.wysiwyg.alert', "에디터 상태에서만 본문에 삽입할 수 있습니다.\n에디터모드에서 첨부박스의 썸네일을 클릭해서 삽입할 수 있습니다.")
});
/**
 * Trex.Attachment
 * 첨부된 data를 wrapping하는 class
 *
 * @abstract
 * @class
 * @extends Trex.Entry
 *
 * @param {Object} actor
 * @param {Object} data
 */
Trex.Attachment = Trex.Class.draft( /** @lends Trex.Attachment.prototype */ {
    /** @ignore */
    $extend: Trex.Entry,
    isChecked: _FALSE,
    focused: _FALSE,
    attrs: {
        align: "left"
    },
    initialize: function(actor, data) {
        this.actor = actor;
        this.canvas = actor.canvas;
        this.entryBox = actor.entryBox;

        this.type = this.constructor.__Identity;
        this.setProperties(data);

        if (this.oninitialized) {
            this.oninitialized(actor, data);
        }
    },
    /**
     * focused 값을 설정한다.
     * @function
     */
    setFocused: function(focused) {
        if (this.focused !== focused) {
            this.focused = focused;
        }
    },
    /**
     * existStage 값을 설정한다.
     * @function
     */
    setExistStage: function(existStage) { //just attachments~
        /**
         * attachment가 content에 존재하는지 확인할 때 사용되는 속성
         */
        this.existStage = existStage;
        if (this.entryBox.changeState) {
            this.entryBox.changeState(this);
        }
    },
    /**
     * content에서 attachment를 지운다.
     * @function
     */
    remove: function() {
        var _content = this.canvas.getContent();
        if (this.canvas.isWYSIWYG()) {
            if (_content.search(this.regHtml) > -1) {
                _content = _content.replace(this.regHtml, "");
                this.canvas.setContent(_content);
            }
        } else {
            if (_content.search(this.regText) > -1) {
                _content = _content.replace(this.regText, "");
                this.canvas.setContent(_content);
            }
        }
    },
    /**
     * attachment HTML을 에디터 본문에 붙여넣는다.
     * @function
     */
    register: function() {
        if (Editor.getSidebar().addOnlyBox) {
            return;
        }
        var _actor = this.actor;
        if (_actor.boxonly) {
            return;
        }

        if (this.canvas.isWYSIWYG()) {
            var _pastescope = this.pastescope;
            var _dispHtml = this.dispHtml;
            var objectElemTagName = "img";
            var findRegex = this.matchRegexStartTag; // /<(\w+)/
            var matched = _dispHtml.match(findRegex);
            //for other elements(Exam: button of file attachment).
            if (matched && matched[1]) {
                objectElemTagName = matched[1];
            }
            if (this.objectStyle) {
                var objectElemeReg = new RegExp("<" + objectElemTagName + " ", "i");
                _dispHtml = _dispHtml.replace(objectElemeReg, "<" + objectElemTagName + " style=\"" + Trex.Util.toStyleString(this.objectStyle) + "\" ");
            }
            if (this.objectAttr) {
                _dispHtml = _dispHtml.replace(objectElemeReg, "<" + objectElemTagName + " " + Trex.Util.toAttrString(this.objectAttr) + " ");
            }
            var _style = this.paragraphStyle || {};
            if ($tx.webkit) {
                this.canvas.getPanel('html').el.focus(); // FTDUEDTR-1281
            }
            this.canvas.execute(function(processor) {
                processor.moveCaretWith(_pastescope);
                processor.pasteContent(_dispHtml, _TRUE, {
                    'style': _style
                });
            });
        } else {
            if (this.actor.wysiwygonly) {
                alert(TXMSG("@attacher.only.wysiwyg.alert"));
            } else {
                this.canvas.getProcessor().insertTag('', this.dispText);
            }
        }
    },
    /**
     * 인자로 받은 old regex로 attachment를 식별해서 HTML을 교체한다.
     * @function
     */
    replace: function(oldReg) {
        var _canvas = this.canvas;
        var _content = _canvas.getContent();
        var _actor = this.actor;
        if (!_actor.boxonly) {
            if (_canvas.isWYSIWYG()) {
                if (_content.search(oldReg.regHtml) > -1) {
                    _content = _content.replace(oldReg.regHtml, this.dispHtml);
                    _canvas.setContent(_content);
                } else {
                    _canvas.pasteContent(this.dispHtml, _TRUE);
                }
            } else {
                if (_content.search(oldReg.regText) > -1) {
                    _content = _content.replace(oldReg.regText, "");
                    _canvas.setContent(_content);
                }
                alert(TXMSG("@attacher.only.wysiwyg.alert"));
            }
        }
    },
    /**
     * attachment 관련하여 필요한 속성을 this 객체에 할당한다.
     * @function
     */
    setProperties: function(data) {
        var _data = data;
        this.data = _data;
        this.key = this.actor.getKey(_data) || 'K' + Trex.Util.generateKey();
        this.field = this.getFieldAttr(_data);
        this.boxAttr = this.getBoxAttr(_data);

        this.objectAttr = this.getObjectAttr.bind(this)(_data);
        this.objectStyle = this.getObjectStyle.bind(this)(_data);
        this.paragraphStyle = this.getParaStyle.bind(this)(_data);

        this.saveHtml = this.getSaveHtml.bind(this)(_data);
        this.dispHtml = this.getDispHtml.bind(this)(_data);
        this.dispText = this.getDispText.bind(this)(_data);
        this.regLoad = this.getRegLoad.bind(this)(_data);
        this.regHtml = this.getRegHtml.bind(this)(_data);
        this.regText = this.getRegText.bind(this)(_data);
    },
    refreshProperties: function() {
        this.setProperties(this.data);
    },
    /**
     * object의 attribute 값을 가져온다.
     * @function
     */
    getObjectAttr: function() {
        return this.actor.config.objattr;
    },
    getObjectStyle: function() {
        var objstyle = {};
        if (this.actor.config.objstyle) {
            objstyle = Object.extend(objstyle, this.actor.config.objstyle);
        }
        return objstyle;
    },
    getParaStyle: function(data) {
        var parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
        return parastyle;
    },
    updateEntryElement: function(targetElement) {
        if (!targetElement) {
            return;
        }

        var tempNode = _DOC.createElement('div');
        tempNode.innerHTML = this.dispHtml;
        targetElement.innerHTML = $tom.first(tempNode).innerHTML;
    }
});

TrexConfig.addSidebar('attachbox', {
    show: _FALSE,
    destroy: _FALSE
});

/**
 * Trex.AttachBox
 * Trex.Attachment instance들이 저장되는 class
 * @class
 * @extends Trex.EntryBox
 */
Trex.AttachBox = Trex.Class.create({
    /** @ignore */
    $extend: Trex.EntryBox,
    isChecked: _FALSE,
    initialize: function() {

    },
    checkAvailableCapacity: function() { //Before Popup
        return _TRUE;
    },
    getAvailableCapacity: function() { //Within Flash
        return _TRUE;
    },
    checkInsertableSize: function() { //Before Attach
        return _TRUE;
    }
});

Trex.install("editor.getAttachBox & sidebar.getAttachments",
    function(editor, toolbar, sidebar, canvas, config) {
        var _attachBox = new Trex.AttachBox(config, editor);
        sidebar.entryboxRegistry['attachbox'] = _attachBox;
        editor.getAttachBox = function() {
            return _attachBox;
        };
        sidebar.getAttachments = _attachBox.getEntries.bind(_attachBox);
    }
);

Trex.register("filter > attachers",
    function(editor) {
        var _attachBox = editor.getAttachBox();
        var _docparser = editor.getDocParser();
        _docparser.registerFilter(
            'filter/attachments', {
                'text@load': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('text@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, "");
                    });
                    return contents;
                },
                'source@load': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, entry.dispText);
                    });
                    return contents;
                },
                'html@load': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, entry.dispHtml);
                    });
                    return contents;
                },
                'text4save': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('text4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, "");
                    });
                    return contents;
                },
                'source4save': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, entry.saveHtml, ["id", "class"]);
                    });
                    return contents;
                },
                'html4save': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, entry.saveHtml, ["id", "class"]);
                    });
                    return contents;
                },
                'text2source': function(contents) {
                    return contents;
                },
                'text2html': function(contents) {
                    return contents;
                },
                'source2text': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source2text', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, "");
                    });
                    return contents;
                },
                'source2html': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source2html', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, entry.dispHtml);
                    });
                    return contents;
                },
                'html2text': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html2text', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, "");
                    });
                    return contents;
                },
                'html2source': function(contents) {
                    var entries = _attachBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html2source', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, entry.dispText, ["id", "class"]);
                    });
                    return contents;
                }
            }
        );
    }
);

Trex.module("push history @when entrybox has changes",
    function(editor, toolbar, sidebar, canvas) {
        var _attachBox = editor.getAttachBox();

        _attachBox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
            canvas.history.saveHistory({ deleted: _FALSE }, { deleted: _TRUE },
                function(data) {
                    entry.deletedMark = data.deleted;
                    _attachBox.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, entry);
                }
            );
        });
        /*
         * IE에서는 canvas.execute 가 setTimeout 을 통하여 실행이 되기 때문에
         * 이하 실행되어야 하는 로직과 순서가 뒤바뀌는 문제가 있다.
         * saveHistory, injectHistory 와 같이 쌍으로 실행이 되며,
         * 순서 보장이 중요한 작업의 경우에 이를 맞춰주기 위해 뒤에 실행되어야 하는 로직도
         * setTimeout 을 이용한다.
         */
        var runOrRunLaterIfIE = function(fn) {
            if ($tx.msie) {
                setTimeout(function() {
                    fn();
                }, 0);
            } else {
                fn();
            }
        };

        _attachBox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
            runOrRunLaterIfIE(function() {
                canvas.history.injectHistory({ deleted: _TRUE }, { deleted: _FALSE },
                    function(data) {
                        entry.deletedMark = data.deleted;
                        _attachBox.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, entry);
                    }
                );
            });
        });
    }
);
TrexMessage.addMsg({
    '@attacher.ins': Trex._I18N.g('attacher.ins', "삽입"),
    '@attacher.del': Trex._I18N.g('attacher.del', "삭제"),
    '@attacher.preview.image': "#iconpath/pn_preview.gif",
    '@attacher.delete.confirm': Trex._I18N.g('attacher.delete.confirm', "삭제하시면 본문에서도 삭제됩니다. 계속하시겠습니까?"),
    '@attacher.delete.all.confirm': Trex._I18N.g('attacher.delete.all.confirm', "모든 첨부 파일을 삭제하시겠습니까? 삭제하시면 본문에서도 삭제됩니다."),
    '@attacher.exist.alert': Trex._I18N.g('attacher.exist.alert', "이미 본문에 삽입되어 있습니다.")
});

Trex.install("attachbox.onAttachBoxInitialized @if config.sidebar.attachbox.show = true", function(editor, toolbar, sidebar, canvas, config) {
    var attachbox = editor.getAttachBox();
    if (config.sidebar.attachbox.show == _TRUE) {
        Object.extend(attachbox, Trex.I.AttachBox);
        attachbox.onAttachBoxInitialized(config, canvas, editor);
    }
});
Trex.I.AttachBox = {
    useBox: _TRUE,
    isDisplay: _FALSE,
    lastSelectedEntry: _NULL,
    onAttachBoxInitialized: function(config, canvas) {
        var _entryBox = this;
        this.canvas = canvas;

        var _initializedId = ((config.initializedId) ? config.initializedId : "");
        this.elBox = $must("tx_attach_div" + _initializedId, "Trex.I.AttachBox");

        this.elList = $must("tx_attach_list" + _initializedId, "Trex.I.AttachBox");
        var _elPreview = $must('tx_attach_preview' + _initializedId, "Trex.I.AttachBox");
        this.elPreviewKind = $tom.collect(_elPreview, "p");
        var _elPreviewImg = $tom.collect(_elPreview, "img");
        this.elPreviewImg = _elPreviewImg;
        this.imageResizer = new Trex.ImageResizer(_elPreviewImg, {
            maxWidth: 147,
            maxHeight: 108,
            defImgUrl: TXMSG("@attacher.preview.image"),
            onComplete: function(width, height) { //vertical positioning
                _elPreviewImg.style.marginTop = Math.floor((108 - height) / 2).toPx();
            }
        });

        this.elDelete = $tom.collect("#tx_attach_delete" + _initializedId + " a");
        $tx.observe(this.elDelete, 'click', function() {
            if (config.sidebar.attachbox.confirmForDeleteAll) {
                _entryBox.onDeleteAll(false);
            } else {
                _entryBox.onDeleteAll(true);
            }
        });

        if (typeof showAttachBox == "function") { //NOTE: 첨부박스가 보여질 때 실행할 서비스 콜백
            this.observeJob(Trex.Ev.__ATTACHBOX_SHOW, function() {
                showAttachBox();
            });
        }
        if (typeof hideAttachBox == "function") { //NOTE: 첨부박스가 감춰질 때 실행할 서비스 콜백
            this.observeJob(Trex.Ev.__ATTACHBOX_HIDE, function() {
                hideAttachBox();
            });
        }

        var _elProgress = $must('tx_upload_progress' + _initializedId, 'Trex.I.AttachBox');
        this.elProgress = _elProgress;
        this.elProgressPercent = $tom.collect(_elProgress, "div");
        this.elProgressTicker = $tom.collect(_elProgress, "p");

        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
            _entryBox.registerEntryNode(entry);
            _entryBox.displayBox();
        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_MODIFIED, function(entry) {
            _entryBox.modifyEntryNode(entry);
            _entryBox.refreshPreview();
        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
            _entryBox.removeEntryNode(entry);
            _entryBox.displayBox();
            if (_entryBox.lastSelectedEntry && _entryBox.lastSelectedEntry.key == entry.key) {
                _entryBox.refreshPreview();
            }

        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED, function() {
            _entryBox.datalist.each(function(entry) {
                _entryBox.removeEntryNode(entry, _TRUE);
            });
            _entryBox.displayBox();
            if (_entryBox.lastSelectedEntry) {
                _entryBox.refreshPreview();
            }
        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, function(entry) {
            _entryBox.displayBox();
            _entryBox.refreshEntryNode(entry);
        });

        var _elUploadedSize = $tx('tx_attach_up_size' + _initializedId),
            _elMaximumSize = $tx('tx_attach_max_size' + _initializedId),
            _elGroupUsedSize = $tx('tx_attach_group_used_size' + _initializedId),
            _elGroupMaximumSize = $tx('tx_attach_group_max_size' + _initializedId);

        this.observeJob(Trex.Ev.__ENTRYBOX_CAPACITY_UPDATE, function() {
            var capacity = config.sidebar.capacity;
            if (capacity.show == _FALSE) {
                return;
            }

            if (_elUploadedSize) {
                _elUploadedSize.innerText = capacity.uploaded.toByteUnit();
            }
            if (_elMaximumSize) {
                // maximum을 안쓰고 available을 사용하는 이유는 group 값 이용시 group.used의 사용여하에 따라 최대치가 달라지기 때문
                _elMaximumSize.innerText = capacity.available.toByteUnit();
            }
            if (capacity.group) {
                if (_elGroupUsedSize) {
                    _elGroupUsedSize.innerText = (capacity.group.used + capacity.uploaded).toByteUnit();
                }
                if (_elGroupMaximumSize) {
                    _elGroupMaximumSize.innerText = capacity.group.maximum.toByteUnit();
                }
            }
        });

        // canvas에서 제거된 첨부파일은 첨부박스에는 1차로는 남아있기 때문에 아래와 같은 삭제 과정이 필요하지 않다
        //        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING, function(ev){
        //            // 데이터중에 존재하지 stage에 존재하지 않는 entry는 박스에서 바로 제거
        //            _entryBox.datalist.each(function (entry) {
        //                if (entry.type =='image' && entry.actor.name == 'image' && entry.existStage == false) {
        //                    entry.execRemove();
        //                }
        //            });
        //            _entryBox.refreshPreview();
        //        });
    },
    onDeleteAll: function(force) {
        if (this.datalist.length === 0) {
            return;
        }
        if (!force && !confirm(TXMSG("@attacher.delete.all.confirm"))) {
            return;
        }
        this.datalist.each(function(entry) {
            if (entry.deletedMark == _FALSE) {
                entry.execRemove();
            }
        });
        //		this.imageResizer.execResize(TXMSG("@attacher.preview.image"));
        this.initPreviewImage();
    },
    checkDisplay: function() {
        return this.isDisplay;
    },
    setDisplay: function(isDisplay) {
        this.isDisplay = isDisplay;
    },
    displayBox: function() {
        var isDisplay = _FALSE;
        for (var i = 0; i < this.datalist.length; i++) {
            if (this.datalist[i].deletedMark == _FALSE) {
                isDisplay = _TRUE;
            }
        }
        //var isDisplay = (this.datalist.length > 0);
        if (this.isDisplay == isDisplay) {
            return;
        }
        if (isDisplay) {
            $tx.show(this.elBox);
            this.fireJobs(Trex.Ev.__ATTACHBOX_SHOW, _TRUE);
        } else {
            $tx.hide(this.elBox);
            this.fireJobs(Trex.Ev.__ATTACHBOX_HIDE, _FALSE);
        }
        this.isDisplay = isDisplay;
    },
    registerEntryNode: function(entry) {
        var _elData = tx.li({
            className: "type-" + entry.type
        });
        if (entry.actor.boxonly) {
            $tx.addClassName(_elData, "tx-boxonly");
        }
        this.elList.appendChild(_elData);
        entry.elData = _elData;

        entry.makeSelection = function(isPreviewed) {
                if (isPreviewed) {
                    this.showEntryThumb(entry);
                } else {
                    this.hideEntryThumb(entry);
                }
            }
            .bind(this);

        //NOTE: only blog cuz iframe area
        $tx.observe(_elData, 'mouseover', this.onEntryMouseOver.bind(this, entry));
        $tx.observe(_elData, 'mouseout', this.onEntryMouseOut.bind(this, entry));

        var _elRow = tx.dl();
        _elData.appendChild(_elRow);

        var _elName = tx.dt({
            className: "tx-name",
            unselectable: "on"
        }, entry.boxAttr.name); //파일명
        entry.elName = _elName;
        _elRow.appendChild(_elName);
        $tx.observe(_elData, 'click', function(e) {
                var _el = $tx.element(e);
                if (_el.className == "tx-delete" || _el.className == "tx-insert") {
                    return;
                }
                if (e.ctrlKey) {
                    this.clickEntryWithCtrl(entry);
                } else if (e.shiftKey) {
                    this.clickEntryWithShift(entry);
                } else {
                    this.clickEntry(entry);
                }
                if (entry.actor.name == 'image') { //NOTE: get image scale
                    if (!entry.data.width || !entry.data.height) {
                        new Trex.ImageScale(entry.data);
                    }
                }
            }
            .bind(this), _FALSE);

        var _elButton = tx.dd({
            className: "tx-button"
        }); //버튼
        _elRow.appendChild(_elButton);

        var _elDelete = tx.a({
            className: "tx-delete"
        }, TXMSG("@attacher.del")); //삭제
        _elButton.appendChild(_elDelete);
        $tx.observe(_elDelete, 'click', function() {
            if (!confirm(TXMSG("@attacher.delete.confirm"))) {
                return;
            }
            entry.execRemove();
        }, _FALSE);


        var _elInsert = tx.a({
            className: "tx-insert"
        }, TXMSG("@attacher.ins")); //삽입
        entry.elInsert = _elInsert;
        _elButton.appendChild(_elInsert);
        $tx.observe(_elInsert, 'click', function() {
            if (entry.existStage && !entry.actor.config.multipleuse) {
                alert(TXMSG("@attacher.exist.alert"));
            } else {
                entry.execAppend();
            }
        }, _FALSE);


    },
    changeState: function(entry) {
        var _existStage = entry.existStage;
        if (_existStage && !entry.actor.config.multipleuse) {
            $tx.addClassName(entry.elData, "tx-existed");
        } else {
            $tx.removeClassName(entry.elData, "tx-existed");
        }
    },
    modifyEntryNode: function(entry) {
        entry.elName.innerText = entry.boxAttr.name;
    },
    removeEntryNode: function(entry, force) {
        if (force) {
            entry.elData.parentNode.removeChild(entry.elData);
        } else if (entry.deletedMark) {
            $tx.hide(entry.elData);
        }
    },
    refreshEntryNode: function(entry) {
        if (entry.deletedMark) {
            $tx.hide(entry.elData);
        } else {
            $tx.show(entry.elData);
        }
    },
    refreshPreview: function() {
        // reload last selected entry
        for (var i = 0, l = this.datalist.length - 1; i < l; ++i) {
            var entry = this.datalist[i];
            if (this.lastSelectedEntry && this.lastSelectedEntry.key == entry.key && entry.deleteMark == false) {
                this.setPreivewImage(entry);
                return _TRUE;
            }
        }

        // reselect
        for (var i = 0, l = this.datalist.length - 1; i < l; ++i) {
            var entry = this.datalist[i];
            if (entry.deletedMark == false && $tx.hasClassName(entry.elData, "tx-clicked")) {
                this.setPreivewImage(entry);
                return _TRUE;
            }
        }

        // init
        this.initPreviewImage();
        return _FALSE;
    },
    setPreivewImage: function(entry) {
        this.imageResizer.execResize(entry.boxAttr.image);
        this.lastSelectedEntry = entry;
    },
    initPreviewImage: function() {
        this.imageResizer.execResize(TXMSG("@attacher.preview.image"));
        this.lastSelectedEntry = _NULL;
    },
    showEntryThumb: function(entry) {
        $tx.addClassName(entry.elData, "tx-clicked");
        $tx.removeClassName(entry.elData, "tx-hovered");
    },
    hideEntryThumb: function(entry) {
        $tx.removeClassName(entry.elData, "tx-clicked");
    },
    onEntryMouseOver: function(entry) {
        $tx.addClassName(entry.elData, "tx-hovered");
    },
    onEntryMouseOut: function(entry) {
        $tx.removeClassName(entry.elData, "tx-hovered");
    },
    startUpload: function() {
        this.elProgressPercent.style.width = "0".toPx();
        $tx.setStyle(this.elList, {
            opacity: 0.3
        });
        $tx.show(this.elProgress);
    },
    doUpload: function(percent) {
        var progressWidth = 300;
        this.elProgressPercent.style.width = Math.floor(progressWidth * (isNaN(percent) ? 0 : parseFloat(percent) * 0.01)).toPx();
        this.elProgressTicker.innerText = Math.floor((isNaN(percent) ? 0 : parseFloat(percent))) + "%";
    },
    endUpload: function() {
        $tx.hide(this.elProgress);
        $tx.setStyle(this.elList, {
            opacity: 1
        });
    },
    clickEntry: function(entry) {
        if (this.lastSelectedEntry) {
            if (this.lastSelectedEntry.key == entry.key) {
                return;
            }
            this.datalist.each(function(entry) {
                entry.makeSelection(_FALSE);
            });
        }
        this.elPreviewKind.className = ((entry.boxAttr.className) ? entry.boxAttr.className : "");
        entry.makeSelection(_TRUE);
        this.setPreivewImage(entry);
    },
    clickEntryWithCtrl: function(entry) {
        if ($tx.hasClassName(entry.elData, 'tx-clicked')) {
            entry.makeSelection(_FALSE);
            this.refreshPreview();
        } else {
            this.elPreviewKind.className = ((entry.boxAttr.className) ? entry.boxAttr.className : "");
            entry.makeSelection(_TRUE);
            this.setPreivewImage(entry);
        }
    },
    clickEntryWithShift: function(entry) {
        if ($tx.hasClassName(entry.elData, 'tx-clicked')) {
            entry.makeSelection(_FALSE);
            this.lastSelectedEntry = _NULL;
        } else {
            var idx = this.getIndexOf(entry);
            var targetIdx;
            if (this.lastSelectedEntry) {
                targetIdx = this.getIndexOf(this.lastSelectedEntry);
            }

            var from = targetIdx,
                to = idx;
            if (idx == targetIdx) {
                from = to = idx;
            } else if (idx < targetIdx) {
                from = idx;
                to = targetIdx;
            }

            this.elPreviewKind.className = ((entry.boxAttr.className) ? entry.boxAttr.className : "");
            for (var i = from; i < to + 1; i++) {
                this.datalist[i].makeSelection(_TRUE);
            }
            this.setPreivewImage(entry);
        }
    },
    getIndexOf: function(entry) {
        var i, matched;
        for (i = 0; i < this.datalist.length; i++) {
            if (this.datalist[i] === entry) {
                matched = _TRUE;
                break;
            }
        }
        return matched ? i : -1;
    },
    getSelectedList: function(attachType) {
        var _list = [];
        var _source;
        if (attachType) {
            _source = this.getAttachments(attachType);
        } else {
            _source = this.datalist;
        }
        _source.each(function(entry) {
            if ($tx.hasClassName(entry.elData, "tx-clicked")) {
                _list.push(entry);
            }
        });
        return _list;
    },
    removeSelection: function(datalist) {
        datalist.each(function(data) {
            $tx.removeClassName(data.elData, "tx-clicked");
        })
    }
};
Trex.install("attachbox.onFileCapacityInitialized @if sidebar.capacity.show = true",
    function(editor, toolbar, sidebar, canvas, config) {
        var attachbox = editor.getAttachBox();
        if (config.sidebar.capacity.show === _TRUE) {
            Object.extend(attachbox, Trex.I.FileCapacity);
            attachbox.onFileCapacityInitialized(config, canvas);
        }
    }
);
Trex.module("attachbox.updateCapacity on Trex.Ev.__ATTACHBOX_SHOW",
    function(editor /*, toolbar, sidebar, canvas, config*/ ) {
        var attachbox = editor.getAttachBox();
        attachbox.observeJob(Trex.Ev.__ATTACHBOX_SHOW, function() {
            attachbox.updateCapacity();
        });
    }
);

TrexConfig.addSidebar('capacity', {
    show: _TRUE,
    maximum: 3145728, //3M <= 1024
    filemaximum: _NULL,
    filter: {
        use: '', //sound,movie
        sound: {
            title: 'sound file',
            maximum: 3145728,
            extensions: ",mp3,wav,ogg,wma,mp4,ape,wmv,asf,ra,ram,"
        },
        movie: {
            title: 'movie file',
            maximum: 3145728,
            extensions: ",wmv,mpg,avi,"
        }
    }
});
Trex.I.FileCapacity = {
    onFileCapacityInitialized: function(config, canvas) {
        var _initializedId = (config.initializedId) ? config.initializedId : "";
        var _fileConfig = config.sidebar.capacity;

        //#FTDUEDTR-1260
        //아래 부분이 소스상 전혀 사용되는 부분이 없어서 일단 주석처리하였습니다.
        //this.elList = $must("tx_attach_list" + _initializedId, "Trex.I.FileCapacity");

        _fileConfig.uploaded = 0; //Initialize capacity
        _fileConfig.available = _fileConfig.maximum; //Remaining capacity
        _fileConfig.uploadedFileNum = 0; //Uploaded file number.

        var _setCapacity = function(name, size) {
            size = parseInt(size, 10);
            if (isNaN(size) || _fileConfig[name] == _UNDEFINED) {
                return _FALSE; // invalid setting
            }

            if (_fileConfig.group && name == 'available') {
                _fileConfig[name] = Math.min(size, _fileConfig.maximum, _fileConfig.group.maximum - _fileConfig.group.used); //사용가능한 용량 - 그룹용량 포함
            } else {
                _fileConfig[name] = size;
            }

            return _fileConfig[name];
        };

        this.checkAvailableCapacity = function() { //Before Popup override
            return (_fileConfig.uploaded < _fileConfig.available);
        };
        this.checkInsertableSize = function(attachSize) { //Before Attach override
            return (parseInt(_fileConfig.uploaded, 10) + parseInt(attachSize, 10) <= parseInt(_fileConfig.available, 10));
        };

        /**
         * Gets capacity by attachment type
         * @memberOf Trex.AttachBox.prototype
         * @alias getCapacity
         * @param {Object} name
         */
        this.getCapacity = function(name) {
            return (_fileConfig[name] || 0);
        };

        /**
         * Change available capacity
         * @memberOf Trex.AttachBox.prototype
         * @alias changeAvailableCapacity
         * @param {Number} size
         */
        this.changeAvailableCapacity = function(size) {
            if (_setCapacity("available", size)) {
                capacityUpdateEvent();
                return size;
            }

            return _FALSE;
        };

        /**
         * Change maximum capacity
         * @memberOf Trex.AttachBox.prototype
         * @alias changeMaximumCapacity
         * @param {Number} size
         */
        this.changeMaximumCapacity = function(size) {
            if (_setCapacity("maximum", size)) {
                return size;
            }
            return _FALSE;
        };

        /**
         * Change one file maximum capacity
         * @memberOf Trex.AttachBox.prototype
         * @alias changeFileMaximumCapacity
         * @param {Number} size
         */
        this.changeFileMaximumCapacity = function(size) {
            if (_setCapacity("filemaximum", size)) {
                return size;
            }
            return _FALSE;
        };

        this.updateCapacity = function() {
            capacityUpdateEvent();
        }

        /**
         *  Resets uploaded file count & size
         *
         *  @memberOf Trex.AttachBox.prototype
         *  @alias empty
         */
        var _setAttachSize = function(fileSize) {
            var uploaded = _fileConfig.uploaded + fileSize.toNumber();
            if (uploaded < 0) {
                uploaded = 0;
            }
            _fileConfig.uploaded = uploaded;
        };
        var decreaseCapacity = function(fileSize) {
            _setAttachSize(-1 * fileSize);
            _fileConfig.uploadedFileNum -= 1;
        };
        var increaseCapacity = function(fileSize) {
            _setAttachSize(fileSize);
            _fileConfig.uploadedFileNum += 1;
        };

        var _filters = {};
        if (_fileConfig.filter.use.length > 0) {
            _fileConfig.filter.use.split(",").each(function(filterName) {
                if (_fileConfig.filter[filterName]) {
                    _filters[filterName] = Object.extend({}, _fileConfig.filter[filterName]);
                }
            });
        }
        this.getFiltersNameByExt = function(ext) {
            var _filterNames = [];
            for (var _filterName in _filters) {
                if (_filters[_filterName].extensions.indexOf("," + ext.toLowerCase() + ",") > -1) {
                    _filterNames.push(_filterName);
                }
            }
            return _filterNames;
        };
        this.getFilterExtensions = function(filterName) {
            if (_filters[filterName]) {
                return _filters[filterName].extensions;
            } else {
                return _NULL;
            }
        };
        this.getFilterMaximum = function(filterName) {
            if (_filters[filterName]) {
                return _filters[filterName].maximum;
            } else {
                return _NULL;
            }
        };
        this.getUploadedSizeByFilter = function(filterName) {
            var _uploadedSize = 0;
            var _extensions = _filters[filterName].extensions;
            this.datalist.each(function(entry) {
                if (entry.data && entry.data.filename) {
                    var _ext = entry.data.filename.split(".").pop().toLowerCase();
                    if (_extensions.indexOf("," + _ext + ",") > -1) {
                        _uploadedSize += entry.data.filesize;
                    }
                }
            });
            return _uploadedSize;
        };

        //그룹용량사용
        if (_fileConfig.group) {
            //사용가능한 용량 - 그룹용량 포함
            _setCapacity("available", Math.min(_fileConfig.maximum, _fileConfig.group.maximum - _fileConfig.group.used));
        }
        this.getGroupCapacity = function(name) {
            return ((_fileConfig.group) ? (_fileConfig.group[name] || 0) : 0);
        };

        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
            if (entry.actor.isCheckSize) {
                increaseCapacity(entry.data.filesize || 0);
                capacityUpdateEvent();
            }
        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
            if (entry.actor.isCheckSize) {
                decreaseCapacity(entry.data.filesize || 0);
                capacityUpdateEvent();
            }
        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED, function() {
            _fileConfig.uploaded = 0;
            _fileConfig.uploadedFileNum = 0;
            capacityUpdateEvent();
        });
        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, function(entry) {
            if (!entry.actor.isCheckSize) {
                return;
            }
            var size = entry.data.filesize || 0;
            if (entry.deletedMark) {
                decreaseCapacity(size);
            } else {
                increaseCapacity(size);
            }
            capacityUpdateEvent();
        });

        var self = this;
        var capacityUpdateEvent = function() {
            // 필요한 정보만 넘겨 줘야할까? _fileConfig를 그냥 넘겨도 될까??
            var senddata = {
                uploaded: _fileConfig.uploaded,
                available: _fileConfig.available,
                maximum: _fileConfig.maximum,
                uploadedFileNum: _fileConfig.uploadedFileNum,
                group: _fileConfig.group
            };
            self.fireJobs(Trex.Ev.__ENTRYBOX_CAPACITY_UPDATE, senddata);
        };
    }
};
/**
 * @filewoverview
 * attacher.js - 첨부 관련 source로 이 소스에서 존재하는 Attacher들을 직접 생성한다.
 * Editor가 생성될때 initialize된다.
 */

TrexMessage.addMsg({
    '@attacher.can.modify.alert': Trex._I18N.g('attacher.can.modify.alert', "기존에 등록된 #{title}을(를) 수정할 수 있는 화면으로 이동합니다."),
    '@attacher.can.modify.confirm': Trex._I18N.g('attacher.can.modify.confirm', "#{title}은(는) 하나만 등록이 가능합니다.\n다시 올리시면 기존의 #{title}이(가) 삭제됩니다. 계속하시겠습니까?"),
    '@attacher.insert.alert': Trex._I18N.g('attacher.insert.alert', "에디터 상태에서만 삽입할 수 있습니다."),
    '@attacher.capacity.alert': Trex._I18N.g('attacher.capacity.alert', "용량을 초과하였습니다."),
    '@attacher.size.alert': Trex._I18N.g('attacher.size.alert', "용량을 초과하여 더이상 등록할 수 없습니다.")
});

Trex.install("sidebar.getAttacher & sidebar.getUploadAdaptor",
    function(editor, toolbar, sidebar) {
        var _attachers = sidebar.attachers = {};

        /**
         * memberOf Trex.Sidebar.prototype
         * @param {Object} name
         */
        sidebar.getAttacher = function(name) {
            if (_attachers[name] != _NULL) {
                return _attachers[name];
            } else if (arguments.length == 0) {
                return _attachers;
            } else {
                return _NULL;
            }
        };

    }
);

Trex.register("new attachers",
    function(editor, toolbar, sidebar, canvas, config) {
        var _attachBox = editor.getAttachBox();
        var _attachers = sidebar.attachers;

        for (var i in Trex.Attacher) {
            var _name = Trex.Attacher[i]['__Identity'];
            if (_name) {
                _attachers[_name] = new Trex.Attacher[i](editor, _attachBox, config);
            }
        }

        if (_attachers["file"]) {
            sidebar.getUploadAdaptor = function() {
                return _attachers["file"].getAdaptor();
            };
        }
    }
);

/**
 * Class Trex.Attacher
 *
 * @abstract
 * @class
 * @extends Trex.Actor
 * @param {Object} editor
 * @param {Object} entryBox
 * @param {Object} config
 */
Trex.Attacher = Trex.Class.draft( /** @lends Trex.Attacher.prototype */ {
    /** @ignore */
    $extend: Trex.Actor,
    canModified: _FALSE,
    canResized: _FALSE,
    initialize: function(editor, entryBox, config) {
        this.editor = editor;
        this.canvas = editor.getCanvas();
        this.entryBox = entryBox;

        var _config = this.config = TrexConfig.getAttacher(this.constructor.__Identity, config);
        if (config.pvpage && !!_config.usepvpage) {
            this.pvUrl = TrexConfig.getUrl(config.pvpage, { "pvname": this.name });
        }
        this.boxonly = ((_config.boxonly != _NULL) ? _config.boxonly : _FALSE);
        this.isMultiple = ((_config.multiple != _NULL) ? _config.multiple : _FALSE);
        this.isCheckSize = ((_config.checksize != _NULL) ? _config.checksize : _FALSE);
        this.wysiwygonly = ((_config.wysiwygonly != _NULL) ? _config.wysiwygonly : _TRUE);
        this.pastescope = _config.pastescope;

        if (this.oninitialized) {
            this.oninitialized(config);
        }
        this.attachHandler = this.attachHandler.bind(this);
    },
    /**
     * Attacher를 실행, 첨부를 하기 위한 popup window를 띄워주거나 필요한 action을 수행한다.
     * @param {String} param - 팝업을 띄울때 추가할 파라미터 문자열
     * @function
     */
    execute: function(param) {
        if (this.wysiwygonly && !this.canvas.isWYSIWYG()) {
            alert(TXMSG("@attacher.insert.alert"));
            return;
        }

        if (this.isCheckSize && !this.entryBox.checkAvailableCapacity()) {
            alert(TXMSG("@attacher.capacity.alert"));
            return;
        }

        if (!this.checkInsertable()) {
            if (this.canModified) {
                var _jstObj = new Template(TXMSG("@attacher.can.modify.alert"));
                alert(_jstObj.evaluate({ title: this.title }));
            } else {
                var _jstObj = new Template(TXMSG("@attacher.can.modify.confirm"));
                if (!confirm(_jstObj.evaluate({ title: this.title }))) {
                    return;
                }
            }
        }
        if (this.clickHandler) {
            this.clickHandler();
        } else {
            try {
                var _url = this.config.popPageUrl;
                if (param) {
                    _url = _url + ((_url.indexOf("?") > -1) ? "&" : "?open&") + param;
                }
                var isDocumentDomainDeclaredExplicitly = (document.location.hostname != document.domain);
                if (isDocumentDomainDeclaredExplicitly) {
                    _url = _url + ((_url.indexOf("?") > -1) ? "&" : "?open&") + "xssDomain=" + document.domain;
                }

                _url = (this.pvUrl ? this.pvUrl + ((this.pvUrl.indexOf("?") > -1) ? "&" : "?open&") + "u=" + escape(_url) : _url);
                var win = _WIN.open(_url, (this.name == "image_edit"?"":"at" + this.name), this.config.features);
                win.focus();
            } catch (e) {}
        }
    },
    /**
     * Argument의 data를 이용해서 editor에 첨부하며, Attacher type에 때라 data의 format은 다르다.
     * @function
     * @param {Object} data
     * @param {Object} attachmentType - optional
     */
    attachHandler: function(data, attachmentType) {
        if (this.checkInsertable()) {
            if (this.isCheckSize && !this.entryBox.checkInsertableSize(data.filesize)) {
                alert(TXMSG("@attacher.size.alert"));
                return;
            }
            this.execAttach(data, attachmentType);
        } else {
            this.execReattach(data, attachmentType);
        }
    },
    createEntry: function(data, type) {
        return this.createAttachment(data, type);
    },
    createAttachment: function(data, type) {
        var _attachmentType = this.constructor.__Identity;
        if (type) {
            _attachmentType = type;
        }
        return new Trex.Attachment[_attachmentType.capitalize()](this, data);
    },
    checkInsertable: function() {
        if (this.isMultiple) {
            return _TRUE;
        }

        var list = this.getDatalist().findAll(function(entry) {
            return entry.deletedMark != _TRUE;
        });
        return list.length === 0;
    }
});
TrexMessage.addMsg({
    '@embeder.alert': Trex._I18N.g('embeder.alert', "에디터 상태에서만 삽입할 수 있습니다.")
});

/**
 * Trex.EmbedBox
 * 본문에 삽입한 embed들이 저장되는 class
 *
 * @class
 * @extends Trex.EntryBox
 * @param {Object} config
 * @param {Object} canvas
 * @param {Object} editor
 */
Trex.EmbedBox = Trex.Class.create({
    /** @ignore */
    $extend: Trex.EntryBox,
    initialize: function() {}
});

Trex.install("editor.getEmbedBox & sidebar.getEmbeder & sidebar.getEmbeddedData",
    function(editor, toolbar, sidebar, canvas, config) {
        var _embedBox = new Trex.EmbedBox(config, canvas, editor);

        sidebar.entryboxRegistry['embedbox'] = _embedBox;
        editor.getEmbedBox = function() {
            return _embedBox;
        };
        sidebar.getEmbeddedData = _embedBox.getEntries.bind(_embedBox);

        var _embeders = sidebar.embeders = {};
        sidebar.getEmbeder = function(name) {
            if (_embeders[name] != _NULL) {
                return _embeders[name];
            } else if (arguments.length == 0) {
                return _embeders;
            } else {
                return _NULL;
            }
        };
    }
);

Trex.register("new embeders",
    function(editor, toolbar, sidebar, canvas, config) {
        var _embedBox = editor.getEmbedBox();
        var _embeders = sidebar.embeders;

        for (var i in Trex.Embeder) {
            var _name = Trex.Embeder[i]['__Identity'];
            if (_name) {
                if (!toolbar.tools[_name]) {
                    //					console.log(["No tool '",_name,"', but Embeder '", _name,"' is initialized."].join(""));
                }
                _embeders[_name] = new Trex.Embeder[i](editor, _embedBox, config);
            }
        }
    }
);

Trex.Embeder = Trex.Class.draft({
    $extend: Trex.Actor,
    canResized: _FALSE,
    initialize: function(editor, entryBox, config) {
        this.editor = editor;
        this.canvas = editor.getCanvas();
        this.entryBox = entryBox;

        var _config = this.config = TrexConfig.getEmbeder(this.constructor.__Identity, config);
        if (config.pvpage && !!_config.usepvpage) {
            this.pvUrl = TrexConfig.getUrl(config.pvpage, { "pvname": this.name });
        }
        this.wysiwygonly = ((_config.wysiwygonly != _NULL) ? _config.wysiwygonly : _TRUE);
        this.pastescope = _config.pastescope;

        this.embedHandler = this.embedHandler.bind(this);

        //NOTE: Cuz Specific Case
        if (this.oninitialized) {
            this.oninitialized.bind(this)(config);
        }
    },
    execute: function(param) {
        if (this.wysiwygonly && !this.canvas.isWYSIWYG()) {
            alert(TXMSG("@embeder.alert"));
            return;
        }

        if (this.clickHandler) {
            this.clickHandler();
        } else {
            try {
                var _url = this.config.popPageUrl;
                var isDocumentDomainDeclaredExplicitly = (document.location.hostname != document.domain);
                if (isDocumentDomainDeclaredExplicitly) {
                    _url = _url + ((_url.indexOf("?") > -1) ? "&" : "?open&") + "xssDomain=" + document.domain;
                }
                if (param) {
                    _url = _url + ((_url.indexOf("?") > -1) ? "&" : "?open&") + param;
                }
                _url = (this.pvUrl ? this.pvUrl + ((this.pvUrl.indexOf("?") > -1) ? "&" : "?open&") + "u=" + escape(_url) : _url);
                var win = _WIN.open(_url, "at" + this.name, this.config.features);
                win.focus();
            } catch (e) {}
        }
    },
    embedHandler: function(data) {
        this.execAttach(data);
    },
    createEntry: function(data, type) {
        var _embeddedItemType = this.constructor.__Identity;
        if (type) {
            _embeddedItemType = type;
        }
        return new Trex.EmbedEntry[_embeddedItemType.capitalize()](this, data);
    },
    execAttach: function(data) {
        var _pastescope = this.pastescope;
        var _html = this.getCreatedHtml(data);
        var _style = this.config.parastyle || this.config.defaultstyle || {};
        this.canvas.execute(function(processor) {
            processor.moveCaretWith(_pastescope);
            processor.pasteContent(_html, _TRUE, _style);
        });
    },
    execReattach: function( /*data, type*/ ) {},
    execReload: function( /*data, type*/ ) {},
    getReloadContent: function(data, content) {
        if (!data.dispElId) {
            return content;
        }
        var _html = this.getCreatedHtml(data);
        var _reg = new RegExp("<(?:img|IMG)[^>]*id=\"?" + data.dispElId + "\"?[^>]*\/?>", "gm");
        if (content.search(_reg) > -1) {
            return content.replace(_reg, _html);
        }
        return content;
    }
});


Trex.register("filter > embeder",
    function(editor) {
        var _embedBox = editor.getEmbedBox();
        var _docparser = editor.getDocParser();
        _docparser.registerFilter(
            'filter/embeder', {
                'text@load': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('text@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, "");
                    });
                    return contents;
                },
                'source@load': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, entry.dispText);
                    });
                    return contents;
                },
                'html@load': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, entry.dispHtml);
                    });
                    return contents;
                },
                'text4save': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('text4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, "");
                    });
                    return contents;
                },
                'source4save': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, entry.saveHtml, ["id", "class"]);
                    });
                    return contents;
                },
                'html4save': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, entry.saveHtml, ["id", "class"]);
                    });
                    return contents;
                },
                'text2source': function(contents) {
                    return contents;
                },
                'text2html': function(contents) {
                    return contents;
                },
                'source2text': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source2text', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, "");
                    });
                    return contents;
                },
                'source2html': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source2html', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, entry.dispHtml);
                    });
                    return contents;
                },
                'html2text': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html2text', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, "");
                    });
                    return contents;
                },
                'html2source': function(contents) {
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html2source', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, entry.dispText, ["id", "class"]);
                    });
                    return contents;
                }
            }
        );
    }
);
Trex.module("embad entry data", function(editor, toolbar, sidebar, canvas, config) {
    var _embedBox = editor.getEmbedBox();
    var _embeders = sidebar.embeders;
    editor.observeJob(Trex.Ev.__EDITOR_LOAD_DATA_BEGIN, function(jsonData) {
        _embedBox.empty();
        var content = jsonData.content;

        function setEmbedEntrys(embedEntrys, contents) { //NOTE: data format = JSON
            embedEntrys = embedEntrys || [];
            contents = contents || "";
            embedEntrys.each(function(embedEntry) {
                try {
                    var _actor = _embeders[embedEntry.embeder];
                    if (_actor) {
                        _actor.execReload(embedEntry.data, contents, embedEntry.type);
                    }
                } catch (ignore) {
                    // 첨부데이터 일부를 정상적으로 불러오지 못했습니다.
                    // try{console.error("첨부데이터 일부를 정상적으로 불러오지 못했습니다:", ignore);}catch(e){}
                }
            });
        }
        for (var name in _embeders) {
            if (_embeders[name]["onloadData"]) {
                setEmbedEntrys(_embeders[name]["onloadData"](content), content)
            }
        }
    });
});
/**
 * Trex.EmbedEntry
 * 삽입된 embed들을 wrapping하는 class
 * @class
 * @extends Trex.Entry
 *
 * @param {Object} actor
 * @param {Object} data
 *
 * 1.5 되면서 IE에서는 변환하지 않음
 */
Trex.EmbedEntry = Trex.Class.create({
    $extend: Trex.Entry,
    attrs: {
        align: "left"
    },
    initialize: function(actor, data) {
        this.actor = actor;
        this.canvas = actor.canvas;
        this.entryBox = actor.entryBox;

        this.setProperties(data);
    },
    register: function() {
        if (this.canvas.isWYSIWYG()) {
            var _style = this.actor.config.defaultstyle;
            if (_style) {
                this.canvas.pasteContent(this.dispHtml, _TRUE, {
                    'style': _style
                });
            } else {
                this.canvas.pasteContent(this.dispHtml, _TRUE);
            }
        } else {
            this.canvas.getProcessor().insertTag('', this.dispText);
        }
    },
    setProperties: function(data) {
        this.type = this.constructor.__Identity;

        var _data = this.data = data;
        this.key = _data.key;

        this.dispHtml = this.getDispHtml(_data);
        this.saveHtml = this.dispText = this.getDispText(_data); //NOTE: embeder들은 dispText와 saveHtml가 같다.
        this.regHtml = this.getRegHtml(_data);
        this.regLoad = this.regText = this.getRegText(_data); //NOTE: embeder들은 dispText와 saveHtml가 같다.
    },
    refreshProperties: function() {
        this.setProperties(this.data);
    }
});

Trex.I.ButtonFontTool = Trex.Mixin.create({
    oninitialized: function(config) {
        var self = this;
        self.button = new Trex.Button(self.buttonCfg);
        self.weave(self.button, _NULL, self.handler);
        if (config.sync) {
            self.startSyncButtonWithStyle();
        }
        self.bindKeyboard(config.hotKey, self.handler.bind(self));
    },
    rangeExecutor: function(processor, newStyle, range) {
        var el = null;
        if ($tx.msie && this.wrapDummy && processor.isCollapsed()) {
            el = this.wrapDummy(processor, range);
            processor.execCommand(this.getQueryCommandName());
            var rng = processor.createGoogRangeFromNodes(el, 1, el, 1);
            rng.select();
        } else {
            processor.execCommand(this.getQueryCommandName());
        }
    },
    onAfterHandler: function(data) {
        // TODO 현재 툴의 state만 변경하면 되는데, 불필요하게 Trex.Ev.__CANVAS_PANEL_QUERY_STATUS를 fire한다.
        var canvas = this.canvas;
        if (canvas.triggerQueryStatus) {
            canvas.triggerQueryStatus();
        }
    },
    startSyncButtonWithStyle: function() {
        var self = this;
        self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(goog_range) {
            self.syncButton(self.queryCurrentStyle(goog_range));
        });
    },
    queryCurrentStyle: function(goog_range) {
        var self = this;
        var state = self.canvas.query(function(processor) {
            var command = self.getQueryCommandName();
            var minGeckoVersion = 20;
            var geckoQueryCommandStateNotWorkingVersion = ($tx.gecko && $tx.gecko_ver < minGeckoVersion);
            if (command && !$tx.opera && !geckoQueryCommandStateNotWorkingVersion) {
                // gecko? : FTDUEDTR-1181
                // opera?: <span style="font-weight: bold">...</span> 인 경우에 bold 상태가 false로 나온다. <b>...</b>인 경우는 제대로 나옴.
                return processor.queryCommandState(command);
            } else {
                var targetNode = self.findQueryingNode(goog_range);
                return !!targetNode && self.isStyleApplied(targetNode);
            }
        });
        return state;
    },

    computeNewStyle: function() {
        return _NULL;
    },

    cachedProperty: _FALSE,
    syncButton: function(state) {
        if (this.cachedProperty != state) {
            this.button.setState(state);
            this.cachedProperty = state;
        }
    }
});

Trex.I.MenuFontTool = Trex.Mixin.create({
    oninitialized: function(config) {
        var self = this;
        self.beforeOnInitialized(config);
        var menuInitHandler = self.menuInitHandler && self.menuInitHandler.bind(self);
        self.weave(self.createButton(), self.createMenu(), self.handler, menuInitHandler);
        if (config.sync) {
            self.startSyncButtonWithStyle();
        }
    },
    rangeExecutor: function(processor, newStyle, range) {
        this.wrapTextAsStyledSpan(processor, newStyle, range);
    },
    startSyncButtonWithStyle: function() {
        var self = this;
        self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(goog_range) {
            self.syncButton(self.queryCurrentStyle(goog_range));
        });
    },
    queryCurrentStyle: function(goog_range) { // only for fontfamily, fontsize
        var self = this;
        var queriedValue = self.queryCommandValue();
        // try to get using queryCommand
        if (self.reliableQueriedValue(queriedValue) && queriedValue && self.getTextByValue(queriedValue)) {
            self._customQueryCurrStyle = queriedValue;
            return self.getTextByValue(queriedValue);
        }

        // try to get from style
        var currentStyle = self.canvas.query(function(processor) {
            var targetNode;
            if ($tx.msie && goog_range.isCollapsed()) { // FTDUEDTR-1233
                targetNode = processor.getNode();
            } else {
                targetNode = self.findQueryingNode(goog_range);
            }
            return self.queryElementCurrentStyle(targetNode);
        });
        if (currentStyle && self.getTextByValue(currentStyle)) {
            self._customQueryCurrStyle = currentStyle;
            return self.getTextByValue(currentStyle);
        }
        // fallback
        self._customQueryCurrStyle = queriedValue || currentStyle || self.getDefaultProperty();
        return queriedValue || currentStyle || self.getTextByValue(self.getDefaultProperty());
    },
    queryCommandValue: function() {
        var self = this;
        return self.canvas.query(function(processor) {
            return processor.queryCommandValue(self.getQueryCommandName());
        });
    },
    reliableQueriedValue: function(value) {
        return _TRUE;
    },
    queryElementCurrentStyle: function(element) {
        var cssPropertyName = this.getCssPropertyName();

        var queryingNode = element;
        var MAX_VISIT_PARENT = 10;
        for (var i = 0; i < MAX_VISIT_PARENT && $tom.kindOf(queryingNode, "%inline"); i++) {
            var currentStyleValue = queryingNode.style[cssPropertyName];
            if (currentStyleValue) {
                return currentStyleValue;
            }
            if ($tom.kindOf(queryingNode, 'font') && $tom.getAttribute(this.getFontTagAttribute())) {
                return $tom.getAttribute(this.getFontTagAttribute());
            }
            queryingNode = queryingNode.parentNode;
        }

        var processor = this.canvas.getProcessor();
        if (element) {
            return processor.queryStyle(element, cssPropertyName);
        } else {
            return _NULL;
        }
    },
    computeNewStyle: function(newStyle) {
        var style = {};
        style[this.getCssPropertyName()] = newStyle;
        return style;
    },

    cachedProperty: _FALSE,
    syncButton: function(text) {
        var self = this;
        self.button.setText(text);
        if (self.cachedProperty != text) {
            if (self.customSetButton) self.customSetButton(self._customQueryCurrStyle);
            self.button.setText(text);
            self.cachedProperty = text;
        }
        self.button.setText(text);
    }
});

Trex.I.FontTool = Trex.Mixin.create({
    initialize: function(editor, toolbar, config) {
        this.$super.initialize(editor, toolbar, config);
    },
    handler: function(data) {
        this.onBeforeHandler(data);
        this.doHandle(data);
        this.onAfterHandler(data);
    },
    onBeforeHandler: function() {},
    doHandle: function(data) {
        var self = this,
            range, newStyle = self.computeNewStyle(data);
        self.canvas.execute(function(processor) {
            var selectedCells = (processor.table) ? processor.table.getTdArr() : [];
            if (selectedCells.length > 0) {
                range = goog.dom.Range.createFromNodeContents(selectedCells[0]);
                processor.executeUsingCaret(function() {
                    self.tableCellsExecutor(processor, newStyle, selectedCells);
                });
            } else {
                range = processor.createGoogRange();
                if (range) {
                    self.rangeExecutor(processor, newStyle, range);
                }
            }
        });
    },
    onAfterHandler: function() {},
    tableCellsExecutor: function(processor, newStyle, cells) {
        var self = this;
        cells.each(function(cell) {
            var range = goog.dom.Range.createFromNodeContents(cell);
            range.select();
            self.rangeExecutor(processor, newStyle, range);
        });
    },
    findQueryingNode: function(goog_range) {
        if (goog_range) {
            var textNode;
            try {
                textNode = this.findFirst(goog_range.__iterator__(), function(node) {
                    return node.nodeType == 3 && node.nodeValue.trim();
                });
            } catch (ignore4ie678) {}
            if (textNode) {
                return textNode.parentNode;
            } else { // fallback condition
                var startNode = goog_range.getStartNode();
                if (startNode && startNode.nodeType == 3) {
                    return startNode.parentNode;
                }
                return startNode;
            }
        }
    },
    findFirst: function(iterator, condition) {
        try {
            return goog.iter.filter(iterator, condition).next();
        } catch (e) {
            return null;
        }
    }
});

Trex.I.WrappingSpanFontTool = Trex.Mixin.create({
    wrapTextAsStyledSpan: function(processor, newStyle, range) {
        var affectedNodes;
        if (processor.isCollapsed()) {
            var startNode = range.getStartNode();
            if (startNode.nodeType == 3) {
                startNode = startNode.parentNode;
            }
            var targetNode = this.findOrCreateDummySpan(startNode, processor, range);
            if(targetNode && targetNode.childNodes.length == 0){ /* 2018-01-09 빈 <span></span> 처리 */
                affectedNodes = [targetNode];
            }else{
                var wordJoiner = targetNode.firstChild;
                processor.createGoogRangeFromNodes(wordJoiner, wordJoiner.length, wordJoiner, wordJoiner.length).select();
                affectedNodes = [targetNode];
            }            
        } else {
            processor.executeUsingCaret(function(range, savedCaret) {
                var iterator = createTextRangeIterator(savedCaret);
                var textNodes = collectTextNodes(iterator);
                affectedNodes = collectTextOnlySpans(textNodes);
            });
        }
        if(newStyle && newStyle.backgroundColor){
            // P tag 적용안함.
            for(var i = affectedNodes.length - 1; i >= 0; i--){
                if(affectedNodes[i].nodeType == 1 && affectedNodes[i].nodeName == "P"){
                    affectedNodes.splice(i, 1);
                }
            }
        }
        if(newStyle && newStyle.fontFamily 
            && this.editor && this.editor.kEditor 
            && this.editor.kEditor.config && this.editor.kEditor.config.fallbackFont){
            var _fontFamily = newStyle.fontFamily;
            var _dup = new Set();
            for(var i = 0; i < affectedNodes.length; i++){
                var __node = affectedNodes[i];
                if(_dup.has(__node)) {
                    continue;
                }
                _dup.add(__node);
                var __ff = _fontFamily;
                if(__node.style.fontFamily){
                    __ff += ',' + __node.style.fontFamily.split(',').splice(0, 3).join(',');
                }
                newStyle.fontFamily = __ff;
                processor.apply([__node], {
                    style: newStyle
                });
            }
            _dup.clear();
            _dup = null;
        }else{
            processor.apply(affectedNodes, {
                style: newStyle
            });
        }

        this.processAffectedNodes(affectedNodes);

        function createTextRangeIterator(savedCaret) {
            var startCaret = savedCaret.getCaret(_TRUE),
                endCaret = savedCaret.getCaret(_FALSE);
            return new goog.dom.TextRangeIterator(startCaret, 0, endCaret, 0);
        }

        // Known Issue : <p>&nbsp;</p>에 대해 p의 childNodes.length === 0 이라  적용이 안된다.
        function collectTextNodes(iterator) {
            var result = [];
            goog.iter.forEach(iterator, function(node) {
                // 잘못된 위치의 TextNode는 제외
                if (node.nodeType == 3 && !$tom.kindOf(node.parentNode, "table,thead,tbody,tr,ul,ol")) {
                    // console.log('text', node);
                    result.push(node);
                }else if(node.nodeType == 1 && node.nodeName 
                    && (node.nodeName == "P"|| node.nodeName == "SPAN") 
                    && (node.childNodes.length == 0 || 
                            (node.childNodes.length == 1 
                                && 
                                    (
                                        node.childNodes[0].nodeName == "BR"
                                        || (node.firstChild.nodeType == 3 
                                            && node.firstChild.nodeValue == Trex.__WORD_JOINER)
                                    )
                            )
                        )
                ){
                    if(!(node.id && node.id.indexOf('goog') != -1)){
                        // console.log('space', node);
                        result.push(node);
                    }
                } else if (node.nodeType == 1 && node.nodeName && (node.nodeName == "P"|| node.nodeName == "SPAN") ){
                    if(node.innerHTML.search(/<span\s+id="goog/i) <= 0) {
                        // console.log('all', node.innerHTML);
                        result.push(node);
                    }
                }
            });
            return result;
        }

        function collectTextOnlySpans(textNodes) {
            var result = [];
            textNodes.each(function(node) {
                var parentNode = node.parentNode;
                if (node.nodeType == '1' && node.nodeName == "P"){
                    if(node.childNodes.length == 0){
                        var newSpan = processor.create("span");
                        node.appendChild(newSpan);
                        result.push(newSpan);
                    }else{
                        result.push(node)
                    }
                }else if(node.nodeType == "1" && node.nodeName == "SPAN"){
                    result.push(node);
                }
                if ((parentNode.nodeName == "SPAN" || parentNode.nodeName == "P") && hasOnlyOneChild(parentNode)) {
                    if (node.nodeType == '3' && parentNode.nodeName == "P") {
                        var newSpan = processor.create("span");
                        $tom.wrap(newSpan, node);
                        result.push(newSpan);
                        result.push(parentNode);
                    }else {
                        result.push(parentNode);
                    }                    
                } else if( node.nodeType != '1') {
                    var newSpan = processor.create("span");
                    $tom.wrap(newSpan, node);
                    result.push(newSpan);
                }
            });
            return result;
        }

        function hasOnlyOneChild(node) {
            var childNodes = node.childNodes;
            var childCount = childNodes.length;            
            if (childCount > 3) { // early return
                return _FALSE;
            }
            for (var i = 0, len = childCount; i < len; i++) {
                if ($tom.isGoogRangeCaret(childNodes[i]) || (childNodes[i].nodeName == "BR")) {
                    childCount = childCount - 1;
                }
            }
            return childCount == 1;
        }
    },
    /**
     * 추가 작업
     */
    processAffectedNodes:function(){},
    /**
     * collapsed 일 때에 style을 적용할 수 있는 span을 찾거나, 새로 span을 만든다.
     */
    findOrCreateDummySpan: function(node, processor, goog_range) {
        /* 2018-01-09 빈 <span></span> 처리 */
        var reuseExistNode = 
            (node.tagName == "SPAN" && node.childNodes.length == 0)
            ||(node.tagName == "SPAN" && node.childNodes.length == 1 && node.childNodes[0].nodeName == "BR")
            ||(node.tagName == "SPAN" 
                && node.childNodes.length == 1 
                && node.firstChild.nodeType == 3 
                && node.firstChild.nodeValue == Trex.__WORD_JOINER);
        if (reuseExistNode) {
            return node;
        } else {
            return this.createDummySpan(node, processor, goog_range);
        }
    },
    createDummySpan: function(parentNode, processor, goog_range) {
        var newNode = null;
        if (parentNode.tagName == "SPAN") {
            newNode = $tom.clone(parentNode);
        } else {
            newNode = processor.create('span');
        }
        newNode.appendChild(processor.newDummy());
        newNode = goog_range.insertNode(newNode); // NOTE: IE에서는 return된 value를 사용해야 한다.

        // insertNode로 인해 빈 TextNode가 생긴 경우, 바로 삭제해준다.
        $tom.removeEmptyTextNode(newNode.previousSibling);
        $tom.removeEmptyTextNode(newNode.nextSibling);
        return newNode;
    }
});

Trex.I.WrappingDummyFontTool = Trex.Mixin.create({
    wrapDummy: function(processor, range) {
        var targetNode = this.createDummySpan(processor, range);
        var wordJoiner = targetNode.firstChild;
        $tom.unwrap(targetNode);
        processor.createGoogRangeFromNodes(wordJoiner, 0, wordJoiner, wordJoiner.length).select();
        return wordJoiner;
    },
    createDummySpan: function(processor, goog_range) {
        var newNode = null;
        newNode = processor.create('span');
        newNode.appendChild(processor.newDummy());
        newNode = goog_range.insertNode(newNode); // NOTE: IE에서는 return된 value를 사용해야 한다.
        // insertNode로 인해 빈 TextNode가 생긴 경우, 바로 삭제해준다.
        $tom.removeEmptyTextNode(newNode.previousSibling);
        $tom.removeEmptyTextNode(newNode.nextSibling);
        return newNode;
    }
});

/**
 * @fileoverview
 *  wysiwyg, source, text 세모드로의 변경을 가능하게하는 dropdown 형식의 tool 'Switcher' Source,
 * Class Trex.Tool.Switcher 와 configuration을 포함
 *
 */

TrexMessage.addMsg({
    '@switcher.wysiwyg': Trex._I18N.g('switcher.wysiwyg', '에디터'),
    '@switcher.source': Trex._I18N.g('switcher.source', 'HTML'),
    '@switcher.text': Trex._I18N.g('switcher.text', '텍스트')
});

TrexConfig.addTool(
    "switcher", {
        wysiwygonly: _FALSE,
        status: _TRUE,
        options: [
            { label: TXMSG('@switcher.wysiwyg'), title: TXMSG('@switcher.wysiwyg'), data: 'html' },
            { label: TXMSG('@switcher.source'), title: TXMSG('@switcher.source'), data: 'source' },
            { label: TXMSG('@switcher.text'), title: TXMSG('@switcher.text'), data: 'text' }
        ]
    }
);

Trex.Tool.Switcher = Trex.Class.create({
    $const: {
        __Identity: 'switcher'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;

        var _map = {};
        config.options.each(function(option) {
            _map[option.data] = {
                title: option.title
            };
        });

        var _cachedProperty = "";
        var _defaultProperty = config.options[0];

        var _isChangeToTextMode = function(mode) {
            if (mode === "text") {
                if (_canvas.mode !== "text") {
                    return _TRUE;
                }
            }
            return _FALSE;
        };
        var _hasContent = function() {
            var content, curText, baseText;
            content = _canvas.getContent();
            curText = content.toLowerCase().trim();
            baseText = $tom.EMPTY_PARAGRAPH_HTML.toLowerCase().trim();
            if (curText && curText !== baseText && curText !== "&nbsp;") {
                return _TRUE;
            }
            return _FALSE;
        };
        var _toolHandler = function(data) {
            if (config.changeModeConfirmMsg) {
                if (_isChangeToTextMode(data)) {
                    if (_hasContent()) {
                        if (_FALSE === confirm(config.changeModeConfirmMsg)) {
                            return $stop;
                        }
                    }
                }
            }
            _canvas.changeMode(data);
        };

        var _changeMode = function(from, to) {
            if (from == to) return;
            if (_cachedProperty == to) {
                return;
            }
            if (!_map[to]) {
                return;
            }
            this.button.setValue(to);
            this.button.setText(_map[to].title);
            _cachedProperty = to; //NOTE: Editor.modify()를 통한 로딩일 경우 switcher 동기화를 위해.
        }.bind(this);

        _canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, _changeMode);
        _canvas.observeJob(Trex.Ev.__CANVAS_MODE_INITIALIZE, _changeMode);

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
                selectedValue: _defaultProperty.data,
                selectedText: _defaultProperty.label
            })),
            /* menu */
            new Trex.Menu.Select(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }

});
/**
 * @fileoverview
 *  wysiwyg, source 두 모드의 변경을 가능하게하는 checkbox형식의 tool 'SwitcherToggle' Source,
 * Class Trex.Tool.SwitcherToggle 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "switchertoggle", {
        wysiwygonly: _FALSE,
        sync: _TRUE,
        status: _TRUE,
        options: [
            { label: Trex._I18N.g('tx_switchertoggle-editor', "에디터"), title: Trex._I18N.g('tx_switchertoggle-editor', "에디터"), data: 'html' },
            { label: Trex._I18N.g('tx_switchertoggle-html', "HTML"), title: Trex._I18N.g('tx_switchertoggle-html', "HTML"), data: 'source' }
        ]
    }
);

Trex.Tool.SwitcherToggle = Trex.Class.create({
    $const: {
        __Identity: 'switchertoggle'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _canvas = this.canvas;

        var _toolHandler = function() {
            switch (_canvas.mode) {
                case 'html':
                    _canvas.changeMode('source');
                    break;
                case 'source':
                    _canvas.changeMode('html');
                    break;
            }
            return _FALSE;
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Toggle(TrexConfig.merge(this.buttonCfg, {
                borderClass: 'tx-switchtoggle'
            })),
            /* menu */
            _NULL,
            /* handler */
            _toolHandler
        );
        var _htmlTitle = Trex._I18N.g('tx_switchertoggle-title-html', 'HTML 타입');
        var _sourceTitle = Trex._I18N.g('tx_switchertoggle-title', '에디터 타입');
        var _toggleCheckbox = function(from, to) {
            this.button.setValue(to == 'source');
            this.button.elIcon.title = to == 'source' ? _sourceTitle : _htmlTitle;
        }.bind(this);
        _canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, _toggleCheckbox);
        _canvas.observeJob(Trex.Ev.__CANVAS_MODE_INITIALIZE, _toggleCheckbox);
    }

});


/**
 * @fileoverview
 * 설정에서 지정된 여러 글꼴들을 선택할 수 있는 메뉴를 포함하는 tool인 '글꼴' Icon을 위한 source로,
 * 필요한 configuration과 Class Trex.Tool.FontFamily을/를 포함
 *
 *
 */

TrexMessage.addMsg({
    '@fontfamily.nanumgothic': '나눔고딕',
    '@fontfamily.malgungothic': '맑은 고딕',
    '@fontfamily.gulim': '굴림',
    '@fontfamily.batang': '바탕',
    '@fontfamily.dotum': '돋움',
    '@fontfamily.gungsuh': '궁서'
});

TrexConfig.addTool(
    "fontfamily", {
        sync: _TRUE,
        status: _TRUE,
        useFavorite: _TRUE,
        options: Trex._I18N.g('_FONT_LIST', [
            { label: TXMSG('@fontfamily.malgungothic') + ' (<span class="tx-txt">가나다라</span>)', title: TXMSG('@fontfamily.malgungothic'), data: 'Malgun Gothic,맑은 고딕,sans-serif', klass: 'tx-malgun' },
            { label: TXMSG('@fontfamily.gulim') + ' (<span class="tx-txt">가나다라</span>)', title: TXMSG('@fontfamily.gulim'), data: 'Gulim,굴림,AppleGothic,sans-serif', klass: 'tx-gulim' },
            { label: TXMSG('@fontfamily.batang') + ' (<span class="tx-txt">가나다라</span>)', title: TXMSG('@fontfamily.batang'), data: 'Batang,바탕,serif', klass: 'tx-batang' },
            { label: TXMSG('@fontfamily.dotum') + ' (<span class="tx-txt">가나다라</span>)', title: TXMSG('@fontfamily.dotum'), data: 'Dotum,돋움,sans-serif', klass: 'tx-dotum' },
            { label: TXMSG('@fontfamily.gungsuh') + ' (<span class="tx-txt">가나다라</span>)', title: TXMSG('@fontfamily.gungsuh'), data: 'Gungsuh,궁서,serif', klass: 'tx-gungseo' },
            { label: 'Arial (<span class="tx-txt">abcde</span>)', title: 'Arial', data: 'Arial,sans-serif', klass: 'tx-arial' },
            { label: 'Verdana (<span class="tx-txt">abcde</span>)', title: 'Verdana', data: 'Verdana,sans-serif', klass: 'tx-verdana' },
            { label: 'Courier New (<span class="tx-txt">abcde</span>)', title: 'Courier New', data: 'Courier New,monspace', klass: 'tx-courier-new' }
        ])
    }
);
/* legacy fontfamily *
{ label: ' 굴림 (<span class="tx-txt">가나다라</span>)', title: '굴림', data: 'Gulim,굴림,AppleGothic,sans-serif', klass: 'tx-gulim' },
{ label: ' 바탕 (<span class="tx-txt">가나다라</span>)', title: '바탕', data: 'Batang,바탕', klass: 'tx-batang' },
{ label: ' 돋움 (<span class="tx-txt">가나다라</span>)', title: '돋움', data: 'Dotum,돋움', klass: 'tx-dotum' },
{ label: ' 궁서 (<span class="tx-txt">가나다라</span>)', title: '궁서', data: 'Gungsuh,궁서', klass: 'tx-gungseo' },
{ label: ' Arial (<span class="tx-txt">abcde</span>)', title: 'Arial', data: 'Arial', klass: 'tx-arial' },
{ label: ' Verdana (<span class="tx-txt">abcde</span>)', title: 'Verdana', data: 'Verdana', klass: 'tx-verdana' },
{ label: ' Arial Black (<span class="tx-txt">abcde</span>)', title: 'Arial Black', data: 'Arial Black', klass: 'tx-arial-black' },
{ label: ' Book Antiqua (<span class="tx-txt">abcde</span>)', title: 'Book Antiqua', data: 'Book Antiqua', klass: 'tx-book-antiqua' },
{ label: ' Comic Sans MS (<span class="tx-txt">abcde</span>)', title: 'Comic Sans MS', data: 'Comic Sans MS', klass: 'tx-comic-sans-ms' },
{ label: ' Courier New (<span class="tx-txt">abcde</span>)', title: 'Courier New', data: 'Courier New', klass: 'tx-courier-new' },
{ label: ' Georgia (<span class="tx-txt">abcde</span>)', title: 'Georgia', data: 'Georgia', klass: 'tx-georgia' },
{ label: ' Helvetica (<span class="tx-txt">abcde</span>)', title: 'Helvetica', data: 'Helvetica', klass: 'tx-helvetica' },
{ label: ' Impact (<span class="tx-txt">abcde</span>)', title: 'Impact', data: 'Impact', klass: 'tx-impact' },
{ label: ' Symbol (<span class="tx-txt">abcde</span>)', title: 'Symbol', data: 'Symbol', klass: 'tx-symbol' },
{ label: ' Tahoma (<span class="tx-txt">abcde</span>)', title: 'Tahoma', data: 'Tahoma', klass: 'tx-tahoma' },
{ label: ' Terminal (<span class="tx-txt">abcde</span>)', title: 'Terminal', data: 'Terminal', klass: 'tx-terminal' },
{ label: ' Times New Roman (<span class="tx-txt">abcde</span>)', title: 'Times New R..', data: 'Times New Roman', klass: 'tx-times-new-roman' },
{ label: ' Trebuchet MS (<span class="tx-txt">abcde</span>)', title: 'Trebuchet MS', data: 'Trebuchet MS', klass: 'tx-trebuchet-ms' },
{ label: ' Webdings (<span class="tx-txt">abcde</span>)', title: 'Webdings', data: 'Webdings', klass: 'tx-webdings' },
{ label: ' Wingdings (<span class="tx-txt">abcde</span>)', title: 'Wingdings', data: 'Wingdings', klass: 'tx-wingdings' }
 */
Trex.Tool.FontFamily = Trex.Class.create({
    $const: {
        __Identity: 'fontfamily'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.CookieBaker, Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
    beforeOnInitialized: function(config) {
        function findAvailableFonts(config) {
            self.usedWebFonts = (($tx.msie && config.webfont && config.webfont.use) ? config.webfont.options : []);
            self.usedFonts = config.options.concat(self.usedWebFonts);
        }

        function setUseFavoriteFont(config) {
            if (config.useFavorite && self.usedWebFonts.length > 0) {
                self.useFavorite = _TRUE;
                self.initCookie('txFontFamilyFavorite');
            } else {
                self.useFavorite = _FALSE;
            }
        }

        var self = this;
        self.focusLoosed = _FALSE;

        findAvailableFonts(config);
        setUseFavoriteFont(config);
        if (self.editor.config.fontList &&
            self.editor.config.fontList.length) self.usedFonts = self.editor.config.fontList;
        self.createFontFamilyMap(self.usedFonts);
    },
    createFontFamilyMap: function(usedFonts) {
        var self = this,
            fontFamilyMap = {},
            fontFamilyOptionMap = {};
        this.fontFamilyMap = fontFamilyMap;
        this.fontFamilyOptionMap = fontFamilyOptionMap;
        usedFonts.each(function(option) {
            var fontNames, title, i, key;
            fontNames = option.data.split(",");
            title = option.title;
            // font-family에 다중값이 있을경우 첫번째 값만 사용하여 font명 표시
            // 뒤에 나오는값은 무시하거나 새로 font list에 생성.
            // for (i = 0; i < fontNames.length; i += 1) {
            // 	key = self.preprocessFontFamily(fontNames[i]);
            // 	fontFamilyMap[key] = title;
            // }
            key = self.preprocessFontFamily(fontNames[0]);
            fontFamilyMap[key] = title;
            fontFamilyOptionMap[key] = option;
            if (!fontFamilyMap[title.toLowerCase()]) {
                fontFamilyMap[title.toLowerCase()] = title;
                fontFamilyOptionMap[title.toLowerCase()] = option;
            }
        });
        self._isCreatedFontFamilyMap = true;
    },
    createButton: function() {
        var button = new Trex.Button.Select(this.buttonCfg);
        this.button = button;
        // this.button._fontFamily = this.getDefaultProperty();
        button.customLabelStyle = function() {
            this.elText.style.fontFamily = this.lastValue;
            this.elText.style.fontSize = '12px';
            this.elText.style.lineHeight = '12px';
            this.elText.style.paddingTop = '4px';
        }
        button.setValue(this.getDefaultProperty());
        var txtVal = this.getTextByValue(this.getDefaultProperty());
        button.setText(txtVal);
        try{button.elIcon.title = (txtVal||'').replace(/['"]/g, '');}catch(e){}
        return button;
    },
    createMenu: function() {
        var self = this;
        var menu = new Trex.Menu.Select(TrexConfig.merge(self.menuCfg, {
            options: self.usedFonts
        }));
        this.menu = menu;
        //overwrite generateListItem
        menu.generateListItem = function(option) {
            var result = [],
                i, item, labalBackup, klassBk;
            var _ds = self.editor.canvas.config.styles || {};
            var _dsf = _ds.fontFamily||'';
            _dsf = _dsf.split(',')[0].replace(/['"]/g, '');
            for (i = 0; i < option.length; i += 1) {
                item = option[i];
                labalBackup = item.label;
                item.label = item.label.replace(/<span class="tx\-txt">/g, '<span class="tx-txt" f-style>')
                    .replace(/f\-style/g, 'style="font-family:' + item.data + ';"');
                //item.label = '<span style="font-family:' + item.data + ';">' + item.label + '</span>';
                klassBk = item.klass;

                if(_dsf && item.data.indexOf(_dsf) != -1) item.klass += ' default_item';
                result.push(Trex.MarkupTemplate.get("menu.select.item").evaluate(item));
                item.label = labalBackup;
                item.klass = klassBk;
            }
            return result.join("");
        };
        if (self.usedWebFonts.length > 0) {
            $tx.addClassName(menu.elMenu, "tx-fontfamily-webfont-menu");
            var elDummyForFocus = tx.input({ 'type': 'text', 'className': 'tx-dummyfocus' });
            $tom.append(menu.elMenu, elDummyForFocus);
            $tx.observe(menu.elMenu, 'mousedown', function(ev) {
                if (ev.offsetX < self.menu.elMenu.clientWidth) { //not scrollbar
                    return;
                }
                elDummyForFocus.style.top = ev.offsetY.toPx();
                if (!self.focusLoosed) {
                    elDummyForFocus.focus();
                    elDummyForFocus.blur();
                    self.menu.elMenu.focus();
                    self.focusLoosed = _TRUE;
                }
            });
        }
        return menu;
    },
    menuInitHandler: function() {
        var self = this;
        var menu = self.menu;
        self.focusLoosed = _FALSE;

        menu.elMenu.style.overflow = "hidden";
        menu.elMenu.style.overflowY = "auto";
        var maxHeight = self.editor.getCanvas().getPanel('html').iframe.offsetHeight;
        menu.elMenu.style.maxHeight = maxHeight + 'px';
        if (this._updateMenu) {
            var elGroup = $tom.collect(menu.elMenu, "ul.tx-menu-list");
            if (elGroup) {
                $tom.remove(elGroup);
            }
            menu.config.options = self.usedFonts;
            menu.generate();
            this._updateMenu = false;
        }
        var elGroup = $tom.collect(menu.elMenu, "ul.tx-menu-list");
        elGroup.style.display = "inline-block";

        var favorite = null;
        if (!self.useFavorite) {
            favorite = [];
        } else {
            menu.elMenu.scrollTop = 0;
            var elGroup = $tom.collect(menu.elMenu, "ul.tx-menu-favlist");
            if (elGroup) {
                $tom.remove(elGroup);
            }
            favorite = self.extractOptions(self.usedFonts, self.readCookie());
            elGroup = menu.generateList(favorite);
            $tom.insertFirst(menu.elMenu, elGroup);
            $tx.addClassName(elGroup, 'tx-menu-favlist');
        }
        if ($tx.msie && $tx.msie_docmode < 8) {
            menu.elMenu.style.height = '10px';
            var height = menu.elMenu.scrollHeight + 4;
            if (maxHeight < height) height = maxHeight;
            menu.elMenu.style.height = height + 'px';
        }
        var sbw = menu.elMenu.offsetWidth - menu.elMenu.clientWidth;
        menu.elMenu.style.width = (elGroup.offsetWidth + sbw) + 'px';
        return favorite;
    },
    onBeforeHandler: function(data) {
        this.canvas.includeWebfontCss("font-family: " + data);
    },
    onAfterHandler: function(data) {
        var self = this;
        try{self.button.elIcon.title = self.getTextByValue(data||'').replace(/['"]/g, '');}catch(e){}
        if (self.useFavorite) {
            self.writeCookie(self.mergeValues(self.readCookie(), data));
        }
    },
    getDefaultProperty: function() {
        return this.canvas.getStyleConfig().fontFamily;
    },
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontFamily";
    },
    getQueryCommandName: function() {
        return "fontname";
    },
    getFontTagAttribute: function() {
        return "face";
    },
    preprocessFontFamily: function(name) {
        //브라우저에 따라 qoute 등으로 감싸주는 경우가 있음.
        //폰트 이름중에 _9 나 9 로 끝나는게 있어 문제가 있었다고 주석이 있었음.
        return name.toLowerCase().replace(/'|"/g, "").replace(/_?9$/, "");
    },
    getTextByValue: function(value) {
        if (value.include(",")) {
            value = value.split(",")[0];
        }
        value = this.preprocessFontFamily(value);
        return this.fontFamilyMap[value];
    },
    customSetButton: function(_key) {
        if (!this._isCreatedFontFamilyMap) return;
        var value = _key;
        if (_key.include(",")) {
            value = value.split(",")[0];
        }
        value = value.replace(/'|"/g, "");
        if (!value) return;
        var key = this.preprocessFontFamily(value);
        var info = this.fontFamilyOptionMap[key];
        if (!info) {
            info = { label: '<span f-style>' + value + '</span> ' + Trex._I18N.g('_FONT_SAMPLE', '(<span class="tx-txt">가나다라</span>)'), title: value, data: _key, klass: '' };
            this.usedFonts.push(info);
            this.fontFamilyMap[key] = value;
            this.fontFamilyOptionMap[key] = info;
            this._updateMenu = true;
            // if(this.menu && this.menu.elMenu){
            // 	var elGroup = $tom.collect(this.menu.elMenu, "ul.tx-menu-favlist");
            // 	elGroup = this.menu.generateList([info]);
            // 	$tom.insertLast(this.menu.elMenu, elGroup);
            // 	$tx.addClassName(elGroup, 'tx-menu-favlist');
            // }
        }
        // this.button._fontFamily = info.data;
        this.button.setValue(info.data);
    }
});

/**
 * @fileoverview
 * 설정에서 지정된 여러 fontsize들을 선택할 수 있는 메뉴를 포함하는 tool인 '글자크기' Icon을 위한 source로,
 * Class Trex.Tool.FontSize, configuration 을 포함
 *
 *
 */
TrexConfig.addTool(
    "fontsize", {
        sync: _TRUE,
        status: _TRUE,
        options: [
            { label: Trex._I18N.g('font-size-l7', '(8pt)', '가나다라마바사 (8pt)'), title: '8pt', data: '8pt', klass: 'tx-8pt' },
            { label: Trex._I18N.g('font-size-l7', '(9pt)', '가나다라마바사 (9pt)'), title: '9pt', data: '9pt', klass: 'tx-9pt' },
            { label: Trex._I18N.g('font-size-l7', '(10pt)', '가나다라마바사 (10pt)'), title: '10pt', data: '10pt', klass: 'tx-10pt' },
            { label: Trex._I18N.g('font-size-l7', '(11pt)', '가나다라마바사 (11pt)'), title: '11pt', data: '11pt', klass: 'tx-11pt' },
            { label: Trex._I18N.g('font-size-l7', '(12pt)', '가나다라마바사 (12pt)'), title: '12pt', data: '12pt', klass: 'tx-12pt' },
            { label: Trex._I18N.g('font-size-l7', '(14pt)', '가나다라마바사 (14pt)'), title: '14pt', data: '14pt', klass: 'tx-14pt' },
            { label: Trex._I18N.g('font-size-l7', '(18pt)', '가나다라마바사 (18pt)'), title: '18pt', data: '18pt', klass: 'tx-18pt' },
            { label: Trex._I18N.g('font-size-l5', '(24pt)', '가나다라마 (24pt)'), title: '24pt', data: '24pt', klass: 'tx-24pt' },
            { label: Trex._I18N.g('font-size-l3', '(36pt)', '가나다 (36pt)'), title: '36pt', data: '36pt', klass: 'tx-36pt' }
        ]
    }
);

Trex.Tool.FontSize = Trex.Class.create({
    $const: {
        __Identity: 'fontsize'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
    beforeOnInitialized: function(config) {
        this.createFontSizeMap(config);
    },
    createButton: function() {
        var defaultProperty = this.getDefaultProperty();
        var button = this.button = new Trex.Button.Select(this.buttonCfg);
        button.setValue(defaultProperty);
        button.setText(this.getTextByValue(defaultProperty));
        return button;
    },
    createMenu: function() {
        var _ds = this.editor.canvas.config.styles || {};
        goog.iter.forEach(this.menuCfg.options, function(opt){
            if(opt.data == _ds.fontSize) opt.klass += ' default_item';
        });
        return new Trex.Menu.Select(this.menuCfg);
    },
    createFontSizeMap: function(config) {
        var fontSizeMap = this.fontSizeMap = {};
        config.options.each(function(option) {
            fontSizeMap[option.data] = option.title;
        });
        [
            //NOTE: font tag의 속성으로 글자 크기를 지정했을 경우
            { title: '8pt', data: '1' },
            { title: '10pt', data: '2' },
            { title: '12pt', data: '3' },
            { title: '14pt', data: '4' },
            { title: '18pt', data: '5' },
            { title: '24pt', data: '6' },
            { title: '36pt', data: '7' },
            { title: '7.5pt', data: '10px' },
            { title: '8pt', data: '11px' },
            { title: '9pt', data: '12px' },
            { title: '10pt', data: '13px' },
            { title: '11pt', data: '15px' },
            { title: '12pt', data: '16px' },
            { title: '14pt', data: '19px' },
            { title: '18pt', data: '24px' },
            { title: '24pt', data: '32px' },
            { title: '36pt', data: '48px' },
            { title: '8pt', data: 'x-small' },
            { title: '10pt', data: 'small' },
            { title: '12pt', data: 'medium' },
            { title: '14pt', data: 'large' },
            { title: '18pt', data: 'x-large' },
            { title: '24pt', data: 'xx-large' },
            { title: '36pt', data: '-webkit-xxx-large' } //NOTE: webkit 계열에서 사용하는 글자 크기
        ].each(function(option) {
            fontSizeMap[option.data] = option.title;
        });
    },
    reliableQueriedValue: function(value) {
        return $tx.webkit === false;
    },
    getTextByValue: function(value) {
        var matchedText = this.fontSizeMap[value];
        if (!matchedText) {
            var round = Math.round(parseFloat(value)).toPx();
            matchedText = this.fontSizeMap[round];
        }
        return matchedText;
    },
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontSize";
    },
    getQueryCommandName: function() {
        return "fontsize";
    },
    getDefaultProperty: function() {
        return this.canvas.getStyleConfig().fontSize;
    },
    getFontTagAttribute: function() {
        return "size";
    }
});

/**
 * @fileoverview
 * Toolbar의 Bold Icon을 위해 필요한 configuration과 Class Trex.Tool.Bold을/를 포함
 *
 */
TrexConfig.addTool(
    "bold", {
        wysiwygonly: _TRUE,
        sync: _TRUE,
        status: _TRUE,
        hotKey: { // ctrl + b
            ctrlKey: _TRUE,
            keyCode: 66
        }
    }
);

Trex.Tool.Bold = Trex.Class.create({
    $const: {
        __Identity: 'bold'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.ButtonFontTool, Trex.I.WrappingDummyFontTool],
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontWeight";
    },
    getQueryCommandName: function() {
        return "bold";
    },
    isStyleApplied: function(node) {
        return ["bold", "700"].contains($tx.getStyle(node, "fontWeight"));
    }
});

/**
 * @fileoverview
 *  Tool 'Underline' Source,
 *  Class Trex.Tool.Underline  configuration 을 포함 하고있다.
 *
 */
TrexConfig.addTool(
    "underline", {
        wysiwygonly: _TRUE,
        sync: _TRUE,
        status: _TRUE,
        hotKey: {
            // ctrl + u
            ctrlKey: _TRUE,
            keyCode: 85
        }
    }
);

/**
 * Underline 기본은 <u>tag
 * u tag 사용시 font color가 적용되지 않음.
 * <span style=text-decoration:underline>으로 변경함.
 */
Trex.Tool.Underline = Trex.Class.create({
    $const: {
        __Identity: 'underline'
    },
    $extend: Trex.Tool,
    $mixins: [
        Trex.I.FontTool,
        Trex.I.ButtonFontTool,
        // Trex.I.WrappingDummyFontTool,
        Trex.I.WrappingSpanFontTool,
        ($tx.gecko ? Trex.I.Tool.QueryStyle.Gecko : Trex.I.Tool.QueryStyle.Standard)
    ],
    rangeExecutor: function(processor, newStyle, range) {
        if(this.cachedProperty === true){
            var el = null;
            if ($tx.msie && this.wrapDummy && processor.isCollapsed()) {
                el = this.wrapDummy(processor, range);
                processor.execCommand(this.getQueryCommandName());
                var rng = processor.createGoogRangeFromNodes(el, 1, el, 1);
                rng.select();
            } else {
                processor.execCommand(this.getQueryCommandName());
            }
        }else{
            this.wrapTextAsStyledSpan(processor, newStyle, range);
        }
    },
    computeNewStyle: function(data) {
        var style = {};
        style[this.getCssPropertyName()] = this.getQueryCommandName();
        return style;
    },
    getDefaultProperty: function() {
        return this.canvas.getStyleConfig().textDecoration;
    },
    getRelatedCssPropertyNames: function() {
        return [this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "textDecoration";
    },
    getQueryCommandName: function() {
        return "underline";
    },
    isStyleApplied: function(node) {        
        var matchTagName = 'u';
        return this.queryNodeStyle(node, this.getCssPropertyName(), this.getQueryCommandName(), matchTagName);
    }
});

/**
 * @fileoverview
 * 'Italic' Icon Source,
 * Class Trex.Tool.Italic과 configuration을 포함
 *
 */
TrexConfig.addTool(
    "italic", {
        wysiwygonly: _TRUE,
        sync: _TRUE,
        status: _TRUE,
        hotKey: {
            // ctrl + i - 기울임
            ctrlKey: _TRUE,
            keyCode: 73
        }
    }
);

Trex.Tool.Italic = Trex.Class.create({
    $const: {
        __Identity: 'italic'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.ButtonFontTool, Trex.I.WrappingDummyFontTool],
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontStyle";
    },
    getQueryCommandName: function() {
        return "italic";
    },
    isStyleApplied: function(node) {
        return $tx.getStyle(node, "fontStyle") == "italic";
    }
});

/**
 * @fileoverview
 *  Tool '취소선' Source,
 * Class Trex.Tool.Strike 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "strike", {
        wysiwygonly: _TRUE,
        sync: _TRUE,
        status: _TRUE,
        hotKey: {
            // ctrl + d
            ctrlKey: _TRUE,
            keyCode: 68
        }
    }
);

Trex.Tool.Strike = Trex.Class.create({
    $const: {
        __Identity: 'strike'
    },
    $extend: Trex.Tool,
    $mixins: [
        Trex.I.FontTool,
        Trex.I.ButtonFontTool,
        Trex.I.WrappingDummyFontTool,
        // Trex.I.WrappingSpanFontTool,
        ($tx.gecko ? Trex.I.Tool.QueryStyle.Gecko : Trex.I.Tool.QueryStyle.Standard)
    ],
    // rangeExecutor: function(processor, newStyle, range) {
    //     if(this.cachedProperty === true){
    //         var el = null;
    //         if ($tx.msie && this.wrapDummy && processor.isCollapsed()) {
    //             el = this.wrapDummy(processor, range);
    //             processor.execCommand(this.getQueryCommandName());
    //             var rng = processor.createGoogRangeFromNodes(el, 1, el, 1);
    //             rng.select();
    //         } else {
    //             processor.execCommand(this.getQueryCommandName());
    //         }
    //     }else{
    //         this.wrapTextAsStyledSpan(processor, newStyle, range);
    //     }
    // },
    // computeNewStyle: function(data) {
    //     var style = {};
    //     style[this.getCssPropertyName()] = 'line-through'; //this.getQueryCommandName();
    //     return style;
    // },
    // getDefaultProperty: function() {
    //     return this.canvas.getStyleConfig().textDecoration;
    // },
    getRelatedCssPropertyNames: function() {
        return [this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "textDecoration";
    },
    getQueryCommandName: function() {
        return "strikethrough";
    },
    isStyleApplied: function(node) {
        var matchTagName = 'strike';
        return this.queryNodeStyle(node, this.getCssPropertyName(), this.getQueryCommandName(), matchTagName);
    }
});

/**
 * @fileoverview
 * 글자색을 변경하기 위해 쓰이는 '글자색' Icon을 위해 필요한 source,
 * Class Trex.Tool.ForeColor 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "forecolor", {
        defaultcolor: "#7c84ef",
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        useFavorite: _TRUE,
        thumbs: Trex.__CONFIG_COMMON.thumbs,
        needRevert: _TRUE
    }
);

Trex.Tool.ForeColor = Trex.Class.create({
    $const: {
        __Identity: 'forecolor'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.CookieBaker, Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool
    /*, ($tx.gecko ? Trex.I.Tool.QueryStyle.Gecko : Trex.I.Tool.QueryStyle.Standard)*/],
    beforeOnInitialized: function(config) {
        this.useFavorite = !!config.useFavorite;
        if (this.useFavorite) {
            this.initCookie('txForeColorFavorite');
        }
    },
    /**
     * 적용여역에 underline, line-through 색상 적용을 위함.
     */
    processAffectedNodes:function(nodes){
        for(var i = 0; i < nodes.length; i++){
            var elems = $(nodes[i]).parents().filter(function(idex){ 
                var t = (this.tagName||'').toLowerCase();
                // return t == 'u'|| t == 'strike' || $(this).css('text-decoration').search(/underline|line-through/gi) != -1
                return t == 'u' || $(this).css('text-decoration').search(/underline/gi) != -1
            });
            if(elems.length > 0) {
                var t = (elems[0].tagName||'').toLowerCase();
                // nodes[i].style.textDecoration = (t == "u" || $(elems[0]).css('text-decoration').search(/underline/i) != -1)?'underline':'line-through';
                nodes[i].style.textDecoration = 'underline';
            }
        }
    },
    createButton: function() {
        var initialColor = this.readCookie() || this.getDefaultProperty();

        var button = this.button = new Trex.Button.Splits(this.buttonCfg);
        button.setValue(initialColor);
        this.syncButton(initialColor);
        return button;
    },
    createMenu: function() {
        return new Trex.Menu.ColorPallete(this.menuCfg);
    },
    onAfterHandler: function(data) {
        this.syncButton(data);
        if (this.useFavorite) {
            this.writeCookie(data);
        }
    },
    getDefaultProperty: function() {
        return this.canvas.getStyleConfig().color;
    },
    getRelatedCssPropertyNames: function() {
        return [this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "color";
    },
    getQueryCommandName: function() {
        return "forecolor";
    },
    computeNewStyle: function(data) {
        var style = {};
        style[this.getCssPropertyName()] = data || this.getDefaultProperty();
        return style;
    },
    syncButton: function(color) {
        try {
            if (color) {
                $tx.setStyle(this.button.elButton, { 'backgroundColor': color });
            }
        } catch (e) {
            // console.log(e);
        }
    }
});


/**
 * @fileoverview
 *  글자 배경색을 적용 하기 위해 쓰이는, Toolbar의 글자배경색 Icon을 위해 필요한
 *  configuration과 Class Trex.Tool.BackColor을/를 포함
 *
 */
TrexConfig.addTool(
    "backcolor", {
        defaultcolor: "#9aa5ea",
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        useFavorite: _TRUE,
        texts: {
            options: [
                { color: '#ff0000', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#e545d0', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#000000', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#ff5e00', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#7c43b1', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#848484', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#ffbb00', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#4673ff', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#66e8ff', text: '#000000', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#ffe400', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#1fafda', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#8cfccb', text: '#000000', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#a8c40d', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#009999', text: '#ffffff', label: Trex._I18N.g('backcolor', '가나다') },
                { color: '#ffffff', text: '#000000', label: Trex._I18N.g('backcolor', '가나다') }
            ]
        },
        thumbs: Trex.__CONFIG_COMMON.thumbs,
        needRevert: _TRUE,
        needTrans: _FALSE
    }
);

Trex.Tool.BackColor = Trex.Class.create({
    $const: {
        __Identity: 'backcolor'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.CookieBaker, Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
    beforeOnInitialized: function(config) {
        this.useFavorite = !!config.useFavorite;
        if (this.useFavorite) {
            this.initCookie('txBackColorFavorite');
        }
    },
    createButton: function() {
        var initialColor = this.readCookie() || this.getDefaultProperty();

        var button = this.button = new Trex.Button.Splits(this.buttonCfg);
        button.setValue(initialColor);
        this.syncButton(initialColor);
        return button;
    },
    createMenu: function() {
        return new Trex.Menu.ColorPallete(this.menuCfg);
    },
    onAfterHandler: function(data) {
        this.syncButton(data);
        if (this.useFavorite) {
            this.writeCookie(data);
        }
    },
    getDefaultProperty: function() {
        return this.config.defaultcolor;
    },
    syncButton: function(data) {
        try {
            var color = data ? data.split("|")[0] : _NULL;
            if (color) {
                $tx.setStyle(this.button.elButton, {
                    backgroundColor: color
                });
            }
        } catch (e) {
            // console.log(e);
        }
    },
    getRelatedCssPropertyNames: function() {
        return ["color", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "backgroundColor";
    },
    getQueryCommandName: function() {
        return ($tx.gecko || $tx.opera) ? "hilitecolor" : "backcolor";
    },
    computeNewStyle: function(data) {
        if (this.shouldRevert(data) || this.includeTextColor(data)) {
            var split = data ? data.split("|") : [];
            return { backgroundColor: split[0], color: split[1] };
        }
        return { backgroundColor: data };
    },
    shouldRevert: function(data) {
        return data == _NULL;
    },
    includeTextColor: function(data) {
        return data && (data.indexOf("|") > -1);
    }
});
/**
 * @fileoverview
 * '들여쓰기' Icon Source,
 * Class Trex.Tool.Indent configuration을 포함
 *
 */
TrexConfig.addTool(
    "indent", {
        sync: _FALSE,
        status: _FALSE,        
        hotKey: {
            // tab - 들여쓰기
            keyCode: 9
        }
    }
);

Trex.Tool.Indent = Trex.Class.create({
    $const: {
        __Identity: 'indent'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        this.weave(new Trex.Button(this.buttonCfg), _NULL, this.handler);
        this.bindKeyboard(config.hotKey, this.tabKeyHandler.bind(this));
        this.createHandlers();
    },
    handler: function() {
        var self = this,
            canvas = self.canvas;
        canvas.execute(function(processor) {
            self.onIndentClicked.handle(processor);
        });
    },
    tabKeyHandler: function() {
        var self = this;
        this.canvas.execute(function(processor) {
            self.onTabPressed.handle(processor);
        });
    },
    createHandlers: function() {
        var IndentTool = Trex.Tool.Indent;
        var Judge = IndentTool.Judge;
        var Operation = IndentTool.Operation;
        var Handler = IndentTool.Handler;
        var ChainHandler = Trex.ChainHandler;
        var onDefaultIndent = ChainHandler.connect([
            new ChainHandler(Judge.ListItem, Operation.IndentListItem),
            new ChainHandler(Judge.BlockNode, Operation.IndentBlockNode)
        ]);
        var onCollapsedTabPressed = ChainHandler.connect([
            new ChainHandler(Judge.And(Judge.HeadOfParagraph, Judge.ListItem), Operation.IndentListItem),
            new ChainHandler(Judge.ChildOfLastTableCell, Operation.GoToBelowTable),
            new ChainHandler(Judge.ChildOfTableCell, Operation.GoToNextCell),
            // new ChainHandler(Judge.AlwaysTrue, Operation.IndentBlockNode)
            // new ChainHandler(Judge.And(Judge.HeadOfParagraph, Judge.BlockNode), Operation.IndentBlockNode),
            new ChainHandler(Judge.AlwaysTrue, Operation.AddFourSpaces)
        ]);
        this.onTabPressed = new Handler(onCollapsedTabPressed, onDefaultIndent, onDefaultIndent, this.editor);
        this.onIndentClicked = new Handler(onDefaultIndent, onDefaultIndent, onDefaultIndent, this.editor);
    }
});

Trex.Tool.Indent.Handler = Trex.Class.create({
    initialize: function(collasped, selection, tableCell, editor) {
        var IndentTool = Trex.Tool.Indent;
        var RangeIndenter = IndentTool.RangeIndenter;
        var TableCellIndenter = IndentTool.TableCellIndenter;
        this.collapsedRange = new RangeIndenter(collasped, editor);
        this.selectedRange = new RangeIndenter(selection, editor);
        this.tableCellSelected = new TableCellIndenter(tableCell);
    },
    handle: function(processor) {
        var tableCells = (processor.table) ? processor.table.getTdArr() : [];
        if (tableCells.length > 0) {
            this.tableCellSelected.indent(processor);
        } else if (processor.isCollapsed()) {
            this.collapsedRange.indent(processor);
        } else {
            this.selectedRange.indent(processor);
        }
    }
});

Trex.ChainHandler = Trex.Class.create({
    $const: {
        connect: function(handlers) {
            var firstHandler = handlers[0];
            for (var i = 1; i < handlers.length; i++) {
                handlers[i - 1].setNext(handlers[i]);
            }
            return firstHandler;
        }
    },
    initialize: function(judge, executor) {
        this.judge = judge;
        this.executor = executor;
        return this;
    },
    setNext: function(successor) {
        this.successor = successor;
        return this.successor;
    },
    handle: function() {
        var args = arguments;
        if (this.judge.apply(this, args)) {
            this.executor.apply(this, args);
        } else if (this.successor) {
            this.successor.handle.apply(this.successor, args);
        }
    }
});

(function() {
    Trex.Tool.Indent.Helper = {
        findBlocksToIndentFromRange: function(range, processor, savedCaret) {
            var startCaret = savedCaret.getCaret(_TRUE);
            var endCaret = savedCaret.getCaret(_FALSE);
            if (processor.isCollapsed()) {
                // getStartNode, getStartOffset 호출하지 않으면 오류가 발생한다.
                if(range && range.getStartNode) range.getStartNode();
                if(range && range.getStartOffset) range.getStartOffset();
                var node = null;
                if((startCaret.nextSibling == endCaret 
                    && endCaret.nextSibling 
                    && endCaret.nextSibling.nodeName == "TABLE")
                ){
                    return [endCaret.nextSibling];
                }else if((startCaret.nextSibling && startCaret.nextSibling.nodeName == "TABLE"
                    && endCaret.previousSibling && startCaret.nextSibling == endCaret.previousSibling)
                ){
                    return [startCaret.nextSibling];
                }
                node = this.findBlockToIndent(startCaret, processor);
                var isEmptyParagraph = (node.tagName == "P" && node.firstChild == startCaret && node.lastChild == endCaret);
                if (isEmptyParagraph) {
                    processor.stuffNode(node);
                }
                // TODO : block을 create한 경우만 restoreInternal을 해야한다. tab press[P로 감싸여 있지 않은 텍스트에서 tab 누르기] 테스트케이스와 관련있음
                savedCaret.restoreInternal();
                return [node];
            } else {
                var iterator = new goog.dom.TextRangeIterator(startCaret, 0, endCaret, 0);
                return this.findBlocksToIndentFromIterator(processor, iterator);
            }
        },
        findBlocksToIndentFromIterator: function(processor, iterator) {
            var self = this;
            var allNodes = self.collectAllNodes(iterator);
            var leafNodes = self.selectLeafNodes(allNodes);
            var validLeafNodes = self.filterUnableToIndent(leafNodes);

            var blocksToIndent = validLeafNodes.map(function(node) {
                return self.findBlockToIndent(node, processor);
            });
            blocksToIndent = blocksToIndent.compact().uniq();
            return blocksToIndent;
        },
        collectAllNodes: function(iterator) {
            var allNodes = [];
            goog.iter.forEach(iterator, function(node) {
                if (!allNodes.contains(node)) {
                    allNodes.push(node);
                }
            });
            return allNodes;
        },
        selectLeafNodes: function(nodes) {
            var leafNodes = [];
            nodes.each(function(node) {
                if (node.childNodes.length == 0) {
                    leafNodes.push(node);
                }
            });
            return leafNodes;
        },
        filterUnableToIndent: function(nodes) {
            var result = [];
            nodes.each(function(node) {
                // indent를 하지 못하는 TextNode를 걸러낸다.
                if ($tom.kindOf(node, "ul,ol,dl")) {
                    $tom.removeListIfEmpty(node);
                } else if ($tom.kindOf(node.parentNode, "table") && $tom.isText(node)) {

                } else if ($tom.kindOf(node.parentNode, "thead,tbody,tfooter") && !$tom.kindOf(node, "tr")) {

                } else if ($tom.kindOf(node.parentNode, "tr") && !$tom.kindOf(node, "th,td")) {

                } else if ($tom.kindOf(node.parentNode, "ul,ol,dl") && !$tom.kindOf(node, "li,dd,dt")) {

                } else {
                    result.push(node);
                }
            });
            return result;
        },
        findBlockToIndent: function(node) {
            var block = this.findOrCreateBlockForNode(node);
            return this.findIndentableHigherBlock(block);
        },
        findOrCreateBlockForNode: function(node) {
            if ($tom.isText(node) || $tom.kindOf(node, "%inline,img")) {
                var blockAncestor = $tom.ancestor(node, "p,li,dd,dt,h1,h2,h3,h4,h5,h6,div");
                if (blockAncestor && $tom.children(blockAncestor, "%block").length == 0) {
                    return blockAncestor;
                } else {
                    blockAncestor = $tom.ancestor(node, "%paragraph,pre,noscript,form,hr,address,fieldset,blockquote");
                    return $tom.wrapInlinesWithP(node, blockAncestor);
                }
            } else {
                return node;
            }
        },
        findIndentableHigherBlock: function(block) {
            var foundNode = _NULL;
            var visitNode = block;
            while (visitNode && visitNode.tagName != "BODY") {
                if (!foundNode && $tom.kindOf(visitNode, "p,div,h1,h2,h3,h4,h5,h6")) {
                    foundNode = visitNode;
                } else if ($tom.kindOf(visitNode, "li,dd,dt")) {
                    return visitNode;
                } else if (foundNode && $tom.kindOf(visitNode, "td,th")) {
                    return foundNode;
                }
                visitNode = visitNode.parentNode;
            }
            return foundNode;
        },
        findAncestorTableCell: function(node) {
            return $tom.ancestor(node, "td,th");
        },
        findNextCell: function(node) {
            var currentCell = this.findCurrentCell(node);
            var nextCell = $tom.next(currentCell, "td,th");
            if (!nextCell) {
                var nextRow = $tom.next($tom.parent(currentCell), "tr");
                if (nextRow) {
                    nextCell = $tom.first(nextRow, "td,th");
                }
            }
            return nextCell;
        },
        findPreviousCell: function(node) {
            var currentCell = this.findCurrentCell(node);
            var prevCell = $tom.previous(currentCell, "td,th");
            if (!prevCell) {
                var prevRow = $tom.previous($tom.parent(currentCell), "tr");
                if (prevRow) {
                    prevCell = $tom.last(prevRow, "td,th");
                }
            }
            return prevCell;
        },
        findCurrentCell: function(node) {
            return $tom.kindOf(node, "td,th") ? node : this.findAncestorTableCell(node);
        },
        isCaretOnStartOf: function(node, range) {
            var startNode = range.getStartNode();
            var startOffset = range.getStartOffset();
            while ($tom.isElement(startNode) && startNode.childNodes.length > 0) {
                startNode = startNode.childNodes[startOffset];
                startOffset = 0;
            }
            if (!startNode) {
                return _TRUE;
            }
            var iterator = new goog.dom.TextRangeIterator(node, 0, startNode, startOffset);
            var hasContent = _FALSE;
            goog.iter.forEach(iterator, function(visiting) {
                if (visiting.nodeType == 3 && !$tom.kindOf(visiting.parentNode, "script,style")) {
                    var text = (visiting === startNode) ? visiting.nodeValue.substring(0, startOffset) : visiting.nodeValue;
                    text = text.replace(Trex.__WORD_JOINER_REGEXP, "");
                    hasContent = $tom.removeMeaninglessSpace(text).length > 0;
                } else if ($tom.isElement(visiting)) {
                    if ($tom.kindOf(visiting, "img,embed,iframe")) {
                        hasContent = _TRUE;
                    }
                }
                if (hasContent) {
                    throw goog.iter.StopIteration;
                }
            });
            return !hasContent;
        }
    };
    var indentHelper = Trex.Tool.Indent.Helper;

    var $caret_moved = {};
    // range 사용해서 indent할 block을 찾아서 chain handler 작업 지시한다.
    Trex.Tool.Indent.RangeIndenter = Trex.Class.create({
        initialize: function(handler, editor) {
            this.editor = editor
            this.handler = handler;
        },
        indent: function(processor) {
            var self = this;
            processor.executeUsingCaret(function(range, savedCaret) {
                var blockNodes = null;
                if (self.editor && self.editor._imageResizeCtrl && self.editor._imageResizeCtrl.isActive) {
                    if(savedCaret) savedCaret.dispose();
                    var img = self.editor._imageResizeCtrl.activeElement;
                    self.editor._imageResizeCtrl.clearAll();
                    blockNodes = [indentHelper.findOrCreateBlockForNode(img)];
                    var doc = self.editor.canvas.getCurrentPanel().getWindow().document;
                    range = doc.createRange();
                    var _sel = doc.getSelection();
                    _sel.removeAllRanges();
                    range.selectNode(img);
                    range.collapse(true);
                    _sel.addRange(range);
                }else{
                    blockNodes = indentHelper.findBlocksToIndentFromRange(range, processor, savedCaret);
                }
                blockNodes.each(function(node) {
                    try {
                        self.handler.handle(node, processor, range);
                    } catch (e) {
                        if (e == $caret_moved) {
                            if(savedCaret) savedCaret.dispose();
                        } else {
                            throw e;
                        }
                    }
                });
            });
        }
    });

    Trex.Tool.Indent.TableCellIndenter = Trex.Class.create({
        initialize: function(handler) {
            this.handler = handler;
        },
        indent: function(processor) {
            var self = this;
            var tableCells = (processor.table) ? processor.table.getTdArr() : [];
            tableCells.each(function(cell) {
                var iterator = new goog.dom.TagIterator(cell);
                var blockNodes = indentHelper.findBlocksToIndentFromIterator(processor, iterator);
                blockNodes.each(function(node) {
                    self.handler.handle(node, processor, _NULL);
                });
            });
        }
    });



    Trex.Tool.Indent.Judge = {
        ChildOfFirstTableCell: function(node) {
            var tableCell = indentHelper.findAncestorTableCell(node);
            return tableCell && !indentHelper.findPreviousCell(tableCell);
        },
        ChildOfLastTableCell: function(node) {
            var tableCell = indentHelper.findAncestorTableCell(node);
            return tableCell && !indentHelper.findNextCell(tableCell);
        },
        ChildOfTableCell: function(node) {
            return indentHelper.findAncestorTableCell(node);
        },
        ListItem: function(node) {
            return $tom.kindOf(node, "li") && $tom.kindOf(node.parentNode, "ol,ul");
        },
        OneDepthList: function(node) {
            if ($tom.kindOf(node, "li")) {
                // TODO: depth계산을 할 것이냐 부모/조상만 확인하여 return 할 것이냐 고민..
                var listBuilder = new Trex.Tool.StyledList.ListBuilder();
                if (listBuilder.countDepthOfList(node) == 1) {
                    return _TRUE;
                }
            }
            return _FALSE;
        },
        IndentedBlockNode: function(node) {
            return $tom.kindOf(node, "%block") && node.style && node.style.marginLeft != "";
        },
        BlockNode: function(node) {
            // TODO %block vs %paragraph
            return $tom.kindOf(node, "%block");
        },
        HeadOfParagraph: function(node, processor, range) {
            return indentHelper.isCaretOnStartOf(node, range);
        },
        And: function(judge1, judge2) {
            return function() {
                return judge1.apply(this, arguments) && judge2.apply(this, arguments);
            }
        },
        AlwaysTrue: function() {
            return _TRUE;
        }
    };

    Trex.Tool.Indent.Operation = {
        /* indent */
        GoToBelowTable: function(node, processor) {
            var table = $tom.ancestor(node, 'table');
            processor.bookmarkToNext(table);
            throw $caret_moved;
        },
        GoToNextCell: function(node, processor) {
            var nextCell = indentHelper.findNextCell(node);
            if (nextCell) {
                processor.selectFirstText(nextCell);
                throw $caret_moved;
            }
        },
        IndentListItem: function(node) {
            var groupNode = $tom.ancestor(node, 'ul,ol,dl');
            if (groupNode) {
                var prevSibling = $tom.previous(node);
                var nextSibling = $tom.next(node);
                if ($tom.kindOf(prevSibling, "ul,ol,dl")) {
                    // move to previous Group
                    $tom.append(prevSibling, node);
                } else {
                    var newGroupNode = $tom.clone(groupNode);
                    $tom.applyStyles(newGroupNode, { marginLeft: _NULL, paddingLeft: _NULL });
                    $tom.wrap(newGroupNode, node);
                }
                // move next Siblings to same parent
                if ($tom.kindOf(nextSibling, "ul,ol,dl")) {
                    $tom.moveChild(nextSibling, node.parentNode);
                    $tom.remove(nextSibling);
                }
            }
        },
        getChildrenAsElement: function(node) {
            var blocks = [];
            var childNodes = node.childNodes;
            for (var i = 0, len = childNodes.length; i < len; i++) {
                var child = childNodes[i];
                if ($tom.isText(child)) {
                    var wrappedChild = $tom.wrapInlinesWithP(child, node);
                    blocks.push(wrappedChild);
                } else if ($tom.isElement(child)) {
                    blocks.push(child);
                }
            }
            return blocks;
        },
        IndentBlockNode: function(node) {
            $tom.applyStyles(node, { marginLeft: "+2em" });
        },
        AddFourSpaces: function(node, processor) {
            processor.pasteContent("&nbsp;&nbsp;&nbsp;&nbsp;", _FALSE, null, _FALSE);
            //processor.pasteHtml("&nbsp;&nbsp;&nbsp;&nbsp;");
        },
        /* outdent */
        GoToAboveTable: function(node, processor) {
            var table = $tom.ancestor(node, 'table');
            processor.bookmarkToPrevious(table);
            throw $caret_moved;
        },
        GoToPreviousCell: function(node, processor) {
            var previousCell = indentHelper.findPreviousCell(node);
            if (previousCell) {
                processor.moveCaretTo(previousCell, _TRUE);
                throw $caret_moved;
            }
        },
        OutdentListItem: function(node, processor) {
            var list = $tom.ancestor(node, 'ul,ol,dl');
            if (!list) {
                return;
            }
            var parentNode = list.parentNode;
            if ($tom.kindOf(parentNode, "li")) {
                $tom.unwrap(parentNode);
                parentNode = list.parentNode;
            }
            var grandParentList = $tom.kindOf(parentNode, 'ul,ol,dl') ? parentNode : _NULL;
            var newList;
            if (grandParentList) {
                newList = $tom.divideNode(list, $tom.indexOf(node));
                $tom.insertAt(node, newList);
            } else {
                newList = $tom.divideNode(list, $tom.indexOf(node));
                var cssText = $tom.getStyleText(node);
                // list의 스타일을 p에도 적용한다.
                var p = processor.newNode('p');
                $tom.setStyleText(p, cssText);
                $tom.replace(node, p);
                $tom.insertAt(p, newList);
            }
            $tom.removeListIfEmpty(list);
            $tom.removeListIfEmpty(newList);
        },
        OutdentBlockNode: function(node) {
            $tom.applyStyles(node, { marginLeft: "-2em" });
        },
        Propagate: function() {
            throw $propagate;
        }
    };
})();

/**
 * @fileoverview
 * Tool '내어쓰기' Source,
 * Class Trex.Tool.Outdent 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "outdent", {
        sync: _FALSE,
        status: _FALSE,        
        hotKey: { // shift + tab - 내어쓰기
            shiftKey: _TRUE,
            keyCode: 9
        }
    }
);

Trex.Tool.Outdent = Trex.Class.create({
    $const: {
        __Identity: 'outdent'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        this.weave(new Trex.Button(this.buttonCfg), _NULL, this.handler);
        this.createHandlers();
        if ($tx.opera == _FALSE) {
            this.observeBackspace();
        }
        /* HotKey Disable 
        this.bindKeyboard(config.hotKey, this.shiftTabKeyHandler.bind(this));
        */
    },
    handler: function() {
        var self = this;
        this.canvas.execute(function(processor) {
            self.onOutdentClicked.handle(processor);
        });
    },
    shiftTabKeyHandler: function() {
        var self = this;
        this.canvas.execute(function(processor) {
            self.onShiftTabPressed.handle(processor);
        });
    },
    observeBackspace: function() {
        var canvas = this.canvas;
        var self = this;
        canvas.observeKey({ keyCode: Trex.__KEY.BACKSPACE }, function() {
            canvas.query(function(processor) {
                self.onBackspace.handle(processor);
            });
        });
    },
    createHandlers: function() {
        var IndentTool = Trex.Tool.Indent;
        var Judge = IndentTool.Judge;
        var Operation = IndentTool.Operation;
        var Handler = IndentTool.Handler;
        var Chain = Trex.ChainHandler;

        var onDefaultOutdent = Chain.connect([
            new Chain(Judge.ListItem, Operation.OutdentListItem),
            new Chain(Judge.BlockNode, Operation.OutdentBlockNode)
        ]);
        var propagate = Chain.connect([
            new Chain(Judge.AlwaysTrue, Operation.Propagate)
        ]);
        var onCollapsedShiftTabPressed = Chain.connect([
            new Chain(Judge.ListItem, Operation.OutdentListItem),
            new Chain(Judge.ChildOfFirstTableCell, Operation.GoToAboveTable),
            new Chain(Judge.ChildOfTableCell, Operation.GoToPreviousCell),
            new Chain(Judge.BlockNode, Operation.OutdentBlockNode)
        ]);
        var onCollapsedBackspace = Chain.connect([
            new Chain(Judge.And(Judge.HeadOfParagraph, Judge.OneDepthList), Operation.Propagate),
            new Chain(Judge.And(Judge.HeadOfParagraph, Judge.ListItem), Operation.OutdentListItem),
            new Chain(Judge.And(Judge.HeadOfParagraph, Judge.IndentedBlockNode), Operation.OutdentBlockNode),
            new Chain(Judge.AlwaysTrue, Operation.Propagate)
        ]);

        this.onShiftTabPressed = new Handler(onCollapsedShiftTabPressed, onDefaultOutdent, onDefaultOutdent, this.editor);
        this.onOutdentClicked = new Handler(onDefaultOutdent, onDefaultOutdent, onDefaultOutdent, this.editor);
        this.onBackspace = new Handler(onCollapsedBackspace, propagate, propagate, this.editor);
    }
});
Trex.I.AlignExecution = Trex.Mixin.create( /** @lends Trex.I.AlignExecution */ {
    executeAlignImageMode: function(processor) {
        var _imageAlignProps = this.constructor.__ImageModeProps['image'];

        var _node = processor.getControl();
        if (this.editor._imageResizeCtrl && this.editor._imageResizeCtrl.isActive) {
            _node = $(this.editor._imageResizeCtrl.wrapper)[0];
        }
        if (!_node) {
            return;
        }

        processor.apply(_node, _imageAlignProps);

        // if(this.editor._imageResizeCtrl && this.editor._imageResizeCtrl.isActive){
        // 	var _wrapper = this.editor._imageResizeCtrl.wrapper;
        // 	$(_wrapper).css({'clear':_node.style.clear,
        // 					'float':_node.style.float,
        // 					'marginLeft':_node.style.marginLeft,
        // 					'marginRight':_node.style.marginRight});
        // 	_node.style.clear = '';
        // 	_node.style.float = '';
        // 	_node.style.marginLeft = '';
        // 	_node.style.marginRight = '';
        // }

        var _textAlignProps = this.constructor.__ImageModeProps['paragraph'];
        if (_textAlignProps) {
            if (this.editor._imageResizeCtrl && this.editor._imageResizeCtrl.isActive) {
                _node = _node.parentElement;
            }
            var _wNode = $tom.find(_node, "%paragraph");
            processor.apply(_wNode, _textAlignProps);
        }
        if (this.editor._imageResizeCtrl && this.editor._imageResizeCtrl.isActive) {
            this.editor._imageResizeCtrl.clearAll();
        }
    },
    executeAlignTextMode: function(processor) {
        var _textAlignProps = this.constructor.__TextModeProps['paragraph'];
        var _node = processor.getControl();
        if (_node && $tom.kindOf(_node, 'button')) {
            var _wNode = $tom.find(_node, '%paragraph');
            if (_wNode) {
                processor.apply(_wNode, _textAlignProps);
            }
            var _tNode = $tom.collect(_node, 'blockquote'); //NOTE: # FTDUEDTR-1027
            if (_tNode) {
                _tNode.style.margin = this.constructor.__TextModeProps['button']['style']['margin'];
            }
        } else {
            var _nodes = processor.blocks(function() {
                return '%paragraph';
            });
            processor.apply(_nodes, _textAlignProps);

            var _controlNodes = [];
            _nodes.each(function(node) {
                var tables;
                tables = $tom.collectAll(node, 'table,hr');
                tables.each(function(table) {
                    _controlNodes.push(table);
                });
            });
            processor.apply(_controlNodes, {
                'align': _textAlignProps['style']['textAlign']
            });
        }
    },
    queryImageFloat: function(processor) {
        var _node = processor.getControl();
        if (this.editor._imageResizeCtrl && this.editor._imageResizeCtrl.isActive) {
            _node = $(this.editor._imageResizeCtrl.wrapper)[0];
        }
        if (_node) {
            return processor.queryStyle(_node, 'float');
        } else {
            return _NULL;
        }
    },
    queryParaFloat: function(processor) {
        var _value, _node = processor.findNode('%paragraph');
        if (_node) {
            _value = processor.queryStyle(_node, 'float');
        }
        return _value || _NULL;
    },
    queryTextAlign: function(processor) {
        var _node = processor.findNode('%paragraph');
        var _value = processor.queryStyle(_node, 'textAlign');
        if (!_value) {
            _value = processor.queryAttr(_node, 'align');
        }
        if (!_value || _value == "start" || _value == "auto" || _value == "-webkit-auto") {
            _value = 'left';
        }
        return _value;
    },
    queryControlAlign: function(processor) {
        var node = processor.getControl();
        return processor.queryAttr(node, 'align');
    },
    executeAlign: function(processor) {
        var tool = this;
        var alignMode = tool.getAlignMode(processor);
        if (alignMode == "tableCell") {
            tool.executeTableCellMode(processor);
        } else if (alignMode == "image") {
            tool.executeAlignImageMode(processor);
        } else {
            tool.executeAlignTextMode(processor);
        }
    },
    getAlignMode: function(processor) {
        var selectedTdArr = (processor.table) ? processor.table.getTdArr() : [];
        if (selectedTdArr.length > 0) {
            return "tableCell";
        } else if (this.imageAlignMode) {
            return "image";
        } else {
            return "text";
        }
    },
    executeTableCellMode: function(processor) {
        if (!this.indenter) {
            var Judge = Trex.Tool.Indent.Judge;
            var ChainHandler = Trex.ChainHandler;
            var self = this;

            function alignBlockNode(node) {
                $tom.applyAttributes(node, self.constructor.__TextModeProps.paragraph);
            }

            var defaultAlign = ChainHandler.connect([
                new ChainHandler(Judge.ListItem, alignBlockNode),
                new ChainHandler(Judge.BlockNode, alignBlockNode)
            ]);

            this.indenter = new Trex.Tool.Indent.TableCellIndenter(defaultAlign);
        }
        this.indenter.indent(processor);
    },
    syncButtonState: function() {
        var self = this;
        var state = self.canvas.query(function(processor) {
            return self.queryCurrentStyle(processor);
        });
        self.button.setState(state);
    },
    queryCurrentStyle: function(processor) {
        if (this.imageAlignMode) {
            return this.queryImageMode(processor)
        }
        return this.queryTextMode(processor);
    },
    queryImageMode: function(processor) {
        var imageModeProps = this.constructor.__ImageModeProps;
        var currentImageFloat = this.queryImageFloat(processor);
        if (currentImageFloat && currentImageFloat != 'none') {
            if (imageModeProps.image && imageModeProps.image.style['float']) {
                return (currentImageFloat == imageModeProps.image.style['float']);
            }
        }
        var currentParaFloat = this.queryParaFloat(processor);
        if (currentParaFloat && currentParaFloat != 'none') {
            if (imageModeProps.paragraph && imageModeProps.paragraph.style['float']) {
                return (currentParaFloat == imageModeProps.paragraph.style['float']);
            }
        }
        var currentTextAlign = this.queryTextAlign(processor);
        if (imageModeProps.paragraph && imageModeProps.paragraph.style.textAlign) {
            return (currentTextAlign == imageModeProps.paragraph.style.textAlign);
        }
        return _FALSE;
    },
    queryTextMode: function(processor) {
        var textModeProps = this.constructor.__TextModeProps;
        var textAlign = textModeProps.paragraph.style.textAlign;
        var controlAlign = this.queryControlAlign(processor);
        if (controlAlign == _NULL) {
            var align = this.queryTextAlign(processor) || 'left';
            return (align == textAlign);
        } else {
            return (controlAlign == textAlign);
        }
    }
});

(function() {
    /**
     * @fileoverview
     * Toolbar의 AlignLeft Icon을 위해 필요한 configuration과 Class Trex.Tool.AlignLeft를 포함
     *
     */
    TrexConfig.addTool(
        "alignleft", {
            sync: _TRUE,
            status: _TRUE,
            hotKey: { // ctrl + ,
                ctrlKey: _TRUE,
                keyCode: 188
            }
        }
    );

    /*
     * Text : align left
     * Image : float none + align left
     */
    var __TextAlignProperty = "left";
    var __ImageFloatProperty = 'none';
    var __ImageClearProperty = 'none';
    var paragraphProp = {
        'align': _NULL,
        'style': {
            'textAlign': __TextAlignProperty
        }
    };

    Trex.Tool.AlignLeft = Trex.Class.create({
        $const: {
            __Identity: 'alignleft',
            __ImageModeProps: {
                'paragraph': paragraphProp,
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': "",
                        'marginRight': ""
                    }
                }
            },
            __TextModeProps: {
                'paragraph': paragraphProp,
                'button': {
                    'style': {
                        'margin': '0'
                    }
                }
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function(config) {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            /* HotKey Disable 
            self.bindKeyboard(config.hotKey, self.handler.bind(self));
            */
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_LEFT);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_LEFT);
                }
            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
                self.syncButtonState();
            });
        }
    });
})();
(function() {
    /**
     * @fileoverview
     * Toolbar의 AlignCenter Icon을 위해 필요한 configuration과 Class Trex.Tool.AlignCentrer를 포함
     *
     */
    TrexConfig.addTool(
        "aligncenter", {
            sync: _TRUE,
            status: _TRUE,
            hotKey: {
                ctrlKey: _TRUE, // ctrl + .
                keyCode: 190
            }
        }
    );

    /*
     * Text : align center
     * Image : float none + align center
     */
    var __TextAlignProperty = "center";
    var __ImageFloatProperty = 'none';
    var __ImageClearProperty = 'none';
    var paragraphProp = {
        'align': _NULL,
        'style': {
            'textAlign': __TextAlignProperty
        }
    };

    Trex.Tool.AlignCenter = Trex.Class.create({
        $const: {
            __Identity: 'aligncenter',
            __ImageModeProps: {
                'paragraph': paragraphProp,
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': "",
                        'marginRight': ""
                    }
                }
            },
            __TextModeProps: {
                'paragraph': paragraphProp,
                'button': {
                    'style': {
                        'margin': '0 auto'
                    }
                }
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function(config) {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            /* HotKey Disable 
            self.bindKeyboard(config.hotKey, self.handler.bind(self));
            */
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_CENTER);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_CENTER);
                }
            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
                self.syncButtonState();
            });
        }
    });
})();
(function() {
    /**
     * @fileoverview
     * Toolbar의 AlignRight Icon을 위해 필요한 configuration과 Class Trex.Tool.AlignRight을/를 포함
     *
     */
    TrexConfig.addTool(
        "alignright", {
            sync: _TRUE,
            status: _TRUE,
            hotKey: { // ctrl + /
                ctrlKey: _TRUE,
                keyCode: 191
            }
        }
    );

    /*
     * Text : align right
     * Image : float left
     */
    var __TextAlignProperty = "right";
    var __ImageFloatProperty = 'left';
    var __ImageClearProperty = 'both';
    var __ImageMarginProperty = "8px";
    var __ImageNoMarginProperty = "";

    Trex.Tool.AlignRight = Trex.Class.create({
        $const: {
            __Identity: 'alignright',
            __ImageModeProps: {
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': __ImageNoMarginProperty,
                        'marginRight': __ImageMarginProperty
                    }
                }
            },
            __TextModeProps: {
                'paragraph': {
                    'align': _NULL,
                    'style': {
                        'textAlign': __TextAlignProperty
                    }
                },
                'button': {
                    'style': {
                        'margin': '0 0 0 auto'
                    }
                }
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function(config) {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            /* HotKey Disable 
            self.bindKeyboard(config.hotKey, self.handler.bind(self));
            */
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_FLOAT_LEFT);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_RIGHT);
                }
            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
                self.syncButtonState();
            });
        }
    });
})();
(function() {
    /**
     * @fileoverview
     * Toolbar의 AlignFull Icon을 위해 필요한 configuration과 Class Trex.Tool.AlignFull을 포함
     *
     */
    TrexConfig.addTool(
        "alignfull", {
            sync: _TRUE,
            status: _TRUE
        }
    );

    /*
     * Text : align full
     * Image : float right
     */
    var __TextAlignProperty = "justify";
    var __ImageFloatProperty = 'right';
    var __ImageClearProperty = 'both';
    var __ImageMarginProperty = "8px";
    var __ImageNoMarginProperty = "";

    Trex.Tool.AlignFull = Trex.Class.create({
        $const: {
            __Identity: 'alignfull',
            __ImageModeProps: {
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': __ImageMarginProperty,
                        'marginRight': __ImageNoMarginProperty
                    }
                }
            },
            __TextModeProps: {
                'paragraph': {
                    'align': _NULL,
                    'style': {
                        'textAlign': __TextAlignProperty
                    }
                },
                'button': {
                    'style': {
                        'margin': '0'
                    }
                }
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function() {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_FLOAT_RIGHT);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_FULL);
                }
            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
                self.syncButtonState();
            });
        }
    });
})();
/**
 * @fileoverview
 * '행,열 삽입' Icon Source,
 * Class Trex.Tool.Insert configuration을 포함
 *
 */
TrexConfig.addTool(
    "insertcells", {
        sync: _FALSE,
        status: _TRUE,
        options: [{
                label: Trex._I18N.g('insertcells-addRowUpper', '위로 삽입'),
                title: Trex._I18N.g('insertcells-addRowUpper', '위로 삽입'),
                data: 'addRowUpper',
                klass: 'tx-insertcells-1'
            },
            {
                label: Trex._I18N.g('insertcells-addRowBelow', '아래 삽입'),
                title: Trex._I18N.g('insertcells-addRowBelow', '아래 삽입'),
                data: 'addRowBelow',
                klass: 'tx-insertcells-2'
            },
            {
                label: Trex._I18N.g('insertcells-addColLeft', '왼쪽 삽입'),
                title: Trex._I18N.g('insertcells-addColLeft', '왼쪽 삽입'),
                data: 'addColLeft',
                klass: 'tx-insertcells-3'
            },
            {
                label: Trex._I18N.g('insertcells-addColRight', '오른쪽 삽입'),
                title: Trex._I18N.g('insertcells-addColRight', '오른쪽 삽입'),
                data: 'addColRight',
                klass: 'tx-insertcells-4'
            }
        ]
    }
);

Trex.Tool.Insertcells = Trex.Class.create({
    $const: {
        __Identity: 'insertcells'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;

        var _defaultProperty = _canvas.getStyleConfig().insert;
        var _optionz = (config.options || []);
        var _map = {};
        _optionz.each(function(option) {
            _map[option.data] = option.title;
        });

        /*
         * "addRowUpper", "addRowBelow", "addColLeft", "addColRight"
         */
        var _toolHandler = function(command) {
            _canvas.execute(function(processor) {
                if (processor.table) {
                    switch (command) {
                        case "addRowUpper":
                            processor.table.insertRowAbove();
                            break;
                        case "addRowBelow":
                            processor.table.insertRowBelow();
                            break;
                        case "addColLeft":
                            processor.table.insertColLeft();
                            break;
                        case "addColRight":
                            processor.table.insertColRight();
                            break;
                    }
                }
            });
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
                selectedValue: _defaultProperty
            })),
            /* menu */
            new Trex.Menu.Select(this.menuCfg),
            /* handler */
            _toolHandler);
    }
});

/**
 * @fileoverview
 * '행,열 삽입' Icon Source,
 * Class Trex.Tool.deletecells configuration을 포함
 *
 */
TrexConfig.addTool(
    "deletecells", {
        sync: _FALSE,
        status: _TRUE,
        options: [{
                label: Trex._I18N.g('deletecells-deleteRow', '행 삭제'),
                title: Trex._I18N.g('deletecells-deleteRow', '행 삭제'),
                data: 'deleteRow',
                klass: 'tx-deletecells-1'
            },
            {
                label: Trex._I18N.g('deletecells-deleteCol', '열 삭제'),
                title: Trex._I18N.g('deletecells-deleteCol', '열 삭제'),
                data: 'deleteCol',
                klass: 'tx-deletecells-2'
            }
        ]
    }
);

Trex.Tool.deletecells = Trex.Class.create({
    $const: {
        __Identity: 'deletecells'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;

        var _defaultProperty = _canvas.getStyleConfig().insert;
        /*
         * "deleteRow", "deleteCol"
         */
        var _toolHandler = function(command) {
            _canvas.execute(function(processor) {
                if (processor.table) {
                    switch (command) {
                        case "deleteRow":
                            processor.table.deleteRow();
                            break;
                        case "deleteCol":
                            processor.table.deleteCol();
                            break;
                    }
                }
            });
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
                selectedValue: _defaultProperty
            })),
            /* menu */
            new Trex.Menu.Select(this.menuCfg),
            /* handler */
            _toolHandler);
    }
});

/**
 * @fileoverview
 * '행,열 삽입' Icon Source,
 * Class Trex.Tool.Mergecells configuration을 포함
 *
 */
TrexConfig.addTool(
    "mergecells", {
        sync: _FALSE,
        status: _TRUE,
        options: [{
                label: Trex._I18N.g('mergecells-merge', '병합'),
                title: Trex._I18N.g('mergecells-merge', '병합'),
                data: 'merge',
                klass: 'tx-mergecells-1'
            },
            {
                label: Trex._I18N.g('mergecells-cancelmerge', '분할'),
                title: Trex._I18N.g('mergecells-cancelmerge', '분할'),
                data: 'cancelmerge',
                klass: 'tx-mergecells-2'
            }
        ]
    }


);

Trex.Tool.Mergecells = Trex.Class.create({
    $const: {
        __Identity: 'mergecells'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _canvas = this.canvas;
        var _defaultProperty = _canvas.getStyleConfig().insert;

        var _toolHandler = function(command) {
            _canvas.execute(function(processor) {
                if (processor.table) {
                    switch (command) {
                        case "merge":
                            processor.table.merge();
                            break;
                        case "cancelmerge":
                            processor.table.resetMerge();
                            break;
                    }
                }
            });
        };
        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
                selectedValue: _defaultProperty
            })),
            /* menu */
            new Trex.Menu.Select(this.menuCfg),
            /* handler */
            _toolHandler);
    }
});


TrexMessage.addMsg({
    '@cellslineheight.subtitle1': '1pt',
    '@cellslineheight.subtitle2': '2pt',
    '@cellslineheight.subtitle3': '3pt',
    '@cellslineheight.subtitle4': '4pt',
    '@cellslineheight.subtitle5': '5pt'
});

TrexConfig.addTool(
    "cellslineheight", {
        sync: _FALSE,
        status: _TRUE,
        options: [
            { label: TXMSG('@cellslineheight.subtitle1'), title: '1pt', data: 1, klass: 'tx-cellslineheight-1' },
            { label: TXMSG('@cellslineheight.subtitle2'), title: '2pt', data: 2, klass: 'tx-cellslineheight-2' },
            { label: TXMSG('@cellslineheight.subtitle3'), title: '3pt', data: 3, klass: 'tx-cellslineheight-3' },
            { label: TXMSG('@cellslineheight.subtitle4'), title: '4pt', data: 4, klass: 'tx-cellslineheight-4' },
            { label: TXMSG('@cellslineheight.subtitle5'), title: '5pt', data: 5, klass: 'tx-cellslineheight-5' }
        ]
    }
);

Trex.Tool.Cellslineheight = Trex.Class.create({
    $const: {
        __Identity: 'cellslineheight'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;

        self.createListStyleMap(config);
        self.weave(
            new Trex.Button.CellslineheightList(self.buttonCfg),
            new Trex.Menu.Select(self.menuCfg),
            self.handler
        );

    },
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
        config.options.each(function(option) {
            listStyleMap[option.data] = {
                type: option.type,
                klass: option.klass
            };
        });
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
        // 실제 로직은 여기부분 입니다.
        self.canvas.query(function(processor) {
            if (processor.table) {
                processor.table.setBorderHeight(data);
            }
        });
    },
    getButtonClassByValue: function(value) {
        var listStyleMap = this.listStyleMap;
        if (listStyleMap[value]) {
            return listStyleMap[value].klass;
        } else {
            return listStyleMap[this.getDefaultProperty()].klass;
        }
    }
});

Trex.Button.CellslineheightList = Trex.Class.create({
    $extend: Trex.Button.Select
});

/**
 * @fileoverview
 * 글자색을 변경하기 위해 쓰이는 '글자색' Icon을 위해 필요한 source,
 * Class Trex.Tool.Cellslinecolor 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "cellslinecolor", {
        defaultcolor: "#7c84ef",
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        useFavorite: _TRUE,
        thumbs: Trex.__CONFIG_COMMON.thumbs,
        needRevert: _TRUE
    }
);

Trex.Tool.Cellslinecolor = Trex.Class.create({
    $const: {
        __Identity: 'cellslinecolor'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var canvas = this.canvas;
        var self = this;

        this.button = new Trex.Button(this.buttonCfg);

        var _toolHandler = function(color) {
            syncButton(color);
            canvas.query(function(processor) {
                if (processor.table) {
                    processor.table.setBorderColor(color);
                }
            });
        };

        var syncButton = function(color) {
            if (color) {
                try {
                    $tx.setStyle(self.button.elButton, {
                        'backgroundColor': color
                    });
                } catch (e) {
                    // console.log(e);
                }
            }
        };
        syncButton(this.config.defaultcolor);

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            self.button,
            /* menu */
            new Trex.Menu.ColorPallete(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }
});



TrexMessage.addMsg({
    '@cellslinestyle.subtitle1': Trex._I18N.g('cellslinestyle.subtitle1', '테두리 없음'),
    '@cellslinestyle.subtitle2': Trex._I18N.g('cellslinestyle.subtitle2', '실선'),
    '@cellslinestyle.subtitle3': Trex._I18N.g('cellslinestyle.subtitle3', '점선'),
    '@cellslinestyle.subtitle4': Trex._I18N.g('cellslinestyle.subtitle4', '작은 점선')
});

TrexConfig.addTool(
    "cellslinestyle", {
        sync: _FALSE,
        status: _TRUE,
        options: [{
                label: TXMSG('@cellslinestyle.subtitle1'),
                title: Trex._I18N.g('cellslinestyle.subtitle1', '테두리 없음'),
                data: 'none',
                klass: 'tx-cellslinestyle-1'
            },
            {
                label: TXMSG('@cellslinestyle.subtitle2'),
                title: Trex._I18N.g('cellslinestyle.subtitle2', '실선'),
                data: 'solid',
                klass: 'tx-cellslinestyle-2'
            },
            {
                label: TXMSG('@cellslinestyle.subtitle3'),
                title: Trex._I18N.g('cellslinestyle.subtitle3', '점선'),
                data: 'dotted',
                klass: 'tx-cellslinestyle-3'
            },
            {
                label: TXMSG('@cellslinestyle.subtitle4'),
                title: Trex._I18N.g('cellslinestyle.subtitle4', '작은 점선'),
                data: 'dashed',
                klass: 'tx-cellslinestyle-4'
            }
        ]
    }
);

Trex.Tool.Cellslinestyle = Trex.Class.create({
    $const: {
        __Identity: 'cellslinestyle'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
        self.createListStyleMap(config);
        self.weave(
            new Trex.Button.CellsLineStyledList(self.buttonCfg),
            new Trex.Menu.Select(self.menuCfg),
            self.handler
        );

    },
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
        config.options.each(function(option) {
            listStyleMap[option.data] = {
                type: option.type,
                klass: option.klass
            };
        });
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
        // 실제 로직은 여기부분 입니다.
        self.canvas.query(function(processor) {
            if (processor.table) {
                processor.table.setBorderType(data);
            }
        });
    },
    getDefaultProperty: function() {
        return 1;
    }
});

Trex.Button.CellsLineStyledList = Trex.Class.create({
    $extend: Trex.Button.Select
});
/**
 * @fileoverview
 * '행,열 삽입' Icon Source,
 * Class Trex.Tool.celloutline configuration을 포함
 *
 */


TrexConfig.addTool(
    "cellsoutline", {
        sync: _FALSE,
        status: _TRUE,
        options: [{
                label: Trex._I18N.g('cellsoutline-all', '모든 테두리'),
                title: Trex._I18N.g('cellsoutline-all', '모든 테두리'),
                data: 'all',
                klass: 'tx-cellsoutline-1'
            },
            {
                label: Trex._I18N.g('cellsoutline-out', '바깥 테두리'),
                title: Trex._I18N.g('cellsoutline-out', '바깥 테두리'),
                data: 'out',
                klass: 'tx-cellsoutline-2'
            },
            {
                label: Trex._I18N.g('cellsoutline-in', '안쪽 테두리'),
                title: Trex._I18N.g('cellsoutline-in', '안쪽 테두리'),
                data: 'in',
                klass: 'tx-cellsoutline-3'
            },
            {
                label: Trex._I18N.g('cellsoutline-top', '위쪽 테두리'),
                title: Trex._I18N.g('cellsoutline-top', '위쪽 테두리'),
                data: 'top',
                klass: 'tx-cellsoutline-4'
            },
            {
                label: Trex._I18N.g('cellsoutline-bottom', '아래쪽 테두리'),
                title: Trex._I18N.g('cellsoutline-bottom', '아래쪽 테두리'),
                data: 'bottom',
                klass: 'tx-cellsoutline-5'
            },
            {
                label: Trex._I18N.g('cellsoutline-left', '왼쪽 테두리'),
                title: Trex._I18N.g('cellsoutline-left', '왼쪽 테두리'),
                data: 'left',
                klass: 'tx-cellsoutline-6'
            },
            {
                label: Trex._I18N.g('cellsoutline-right', '오른쪽 테두리'),
                title: Trex._I18N.g('cellsoutline-right', '오른쪽 테두리'),
                data: 'right',
                klass: 'tx-cellsoutline-7'
            },
            {
                label: Trex._I18N.g('cellsoutline-none', '테두리 없음'),
                title: Trex._I18N.g('cellsoutline-none', '테두리 없음'),
                data: 'none',
                klass: 'tx-cellsoutline-8'
            }
        ]
    }
);

Trex.Tool.Cellsoutline = Trex.Class.create({
    $const: {
        __Identity: 'cellsoutline'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;

        this.twinkleCount = 0;
        this.twinkleTimer = _NULL;

        self.createListStyleMap(config);
        self.weave(
            new Trex.Button.CellsoutlineList(self.buttonCfg),
            new Trex.Menu.Select(self.menuCfg),
            self.handler
        );

        this.toolbar.observeJob(Trex.Ev.__TOOL_CELL_LINE_CHANGE, function(data) {
            if (data.fromInit != _TRUE) {
                self.twinkleButton();
            }
        });
    },
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
        config.options.each(function(option) {
            listStyleMap[option.data] = {
                type: option.type,
                klass: option.klass
            };
        });
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
        // 실제 로직은 여기부분 입니다.
        self.canvas.query(function(processor) {
            if (processor.table) {
                processor.table.setBorderRange(data);
            }
        });
        self.canvas.execute(function(processor) {
            if (processor.table) {
                if (data == 'none') {
                    processor.table.setNoBorder();
                } else {
                    processor.table.applyBorder();
                }
            }
        });
    },
    twinkleButton: function() {
        var self;
        self = this;

        if (this.twinkleTimer) {
            clearInterval(this.twinkleTimer);
            this.twinkleTimer = _NULL;
        }
        this.twinkleCount = 4;
        this.twinkleTimer = setInterval(function() {
            if (0 < self.twinkleCount) {
                self.twinkleCount -= 1;
                if (self.button.currentState() == "hovered") {
                    self.button.normalState();
                } else {
                    self.button.hoveredState()
                }
            } else {
                self.button.normalState();
                clearInterval(self.twinkleTimer);
                self.twinkleTimer = _NULL;
            }
        }, 500);
    }
});

Trex.Button.CellsoutlineList = Trex.Class.create({
    $extend: Trex.Button.Select
});


Trex.MarkupTemplate.add(
    'cellsline.preview', [
        '<table width="#{width}" cellPadding="0" style="line-height:0"><tbody><tr>',
        '<td valign="center" height="#{height}">',
        '<div style="border-bottom:#{value};width:#{width}px;height:2px;overflow:hidden;"></div>',
        '</td>',
        '</tr></tbody></table>'
    ].join('')
);

TrexConfig.addTool(
    "cellslinepreview", {
        sync: _FALSE,
        status: _TRUE,
        options: [{
            label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
                value: '1pt solid #ccc',
                width: 70,
                height: 14
            }),
            title: '1pt solid #ccc',
            data: '#ccc 1 solid'
        }, {
            label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
                value: '2pt solid #c54',
                width: 70,
                height: 14
            }),
            title: '2pt solid #c54',
            data: '#c54 2 solid'
        }, {
            label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
                value: '2pt solid #67f',
                width: 70,
                height: 14
            }),
            title: '2pt solid #67f',
            data: '#67f 2 solid'
        }, {
            label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
                value: '3pt solid #000',
                width: 70,
                height: 14
            }),
            title: '3pt solid #000',
            data: '#000 3 solid'
        }, {
            label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
                value: '1pt dashed #d4c',
                width: 70,
                height: 14
            }),
            title: '1pt dashed #d4c',
            data: '#d4c 1 dashed'
        }]
    }
);

Trex.Tool.Cellslinepreview = Trex.Class.create({
    $const: {
        __Identity: 'cellslinepreview'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;

        this.data = {
            color: '',
            height: 0,
            type: ''
        };

        this.weave(
            new Trex.Button.CellslinepreviewList(this.buttonCfg),
            new Trex.Menu.Select(this.menuCfg),
            this.handler);

        this.toolbar.observeJob(Trex.Ev.__TOOL_CELL_LINE_CHANGE, function(data) {
            self.setData(data);
            self.refreshPreview();
        });
    },
    setData: function(data) {
        if ("color" in data) {
            this.data.color = data.color;
        }
        if ("height" in data) {
            this.data.height = data.height;
        }
        if ("type" in data) {
            this.data.type = data.type;
        }
    },
    refreshPreview: function() {
        var data;
        data = this.data;
        text = data.height + "pt " + data.type + " " + data.color;
        this.setPreview(text);
    },
    setPreview: function(value) {
        this.button.elText.innerHTML = Trex.MarkupTemplate.get('cellsline.preview').evaluate({
            value: value,
            width: 43,
            height: 14
        });
    },
    addBorderHistory: function(data) {
        this.setData(data);
        this.refreshPreview();
    },
    handler: function(data, title) {
        var self = this,
            canvas = self.canvas;
        canvas.execute(function(processor) {
            var datas;
            if (processor.table) {
                datas = data.split(" ");
                processor.table.setBorderButtons(datas[0], datas[1], datas[2]);
            }
        });
    }
});

Trex.Button.CellslinepreviewList = Trex.Class.create({
    $extend: Trex.Button.Select,
    setText: function(text) {
        this.tool.setPreview(text);
    }
});

/**
 * @fileoverview
 * 테이블 셀의 색을 변경하기 위해 쓰임
 *
 */
TrexConfig.addTool(
    "tablebackcolor", {
        defaultcolor: "#9aa5ea",
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        useFavorite: _TRUE,
        thumbs: Trex.__CONFIG_COMMON.thumbs,
        needRevert: _TRUE
    }
);

Trex.Tool.Tablebackcolor = Trex.Class.create({
    $const: {
        __Identity: 'tablebackcolor'
    },
    $extend: Trex.Tool,

    oninitialized: function() {
        var _canvas = this.canvas;
        var self = this;

        self.button = new Trex.Button(this.buttonCfg);

        var _toolHandler = function(color) {
            _canvas.query(function(processor) {
                if (processor.table) {
                    processor.table.tableBackground(color);
                }
            });
            syncButton(color);
        };

        var syncButton = function(color) {
            try {
                if (color) {
                    $tx.setStyle(self.button.elButton, { 'backgroundColor': color });
                }
            } catch (e) {
                // console.log(e);
            }
        }

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            self.button,
            /* menu */
            new Trex.Menu.ColorPallete(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }
});


/**
 * @fileoverview
 *  toolbar의 접힌 부분을 열고닫는 '더보기' Icon을 위해 필요한 configuration과 Class Trex.Tool.Advanced 를 포함
 *
 */
TrexConfig.addTool(
    "tableedittool", {
        sync: _FALSE,
        status: _TRUE,
        opened: _FALSE
    }
);

/**
 * Trex.Tool.Advanced
 *
 * @class
 * @extends  Trex.Tool
 */
Trex.Tool.TableEditTool = Trex.Class.create({
    $const: {
        __Identity: 'tableedittool'
    },
    $extend: Trex.Tool,
    /**
     * instance가 생성될 때 실행되며 필요한 UI Component 및 Event handler를 생성한다.
     *
     * @memberOf Trex.Tool.Advanced.prototype
     * @param {Object} config
     */
    oninitialized: function(config) {
        var _toolbar = this.toolbar;

        var _elBasic = _toolbar.el;
        var _elAdvanced = $tom.collect(_elBasic.parentNode, 'div.tx-toolbar-advanced');
        if (!_elAdvanced) {
            return;
        }

        _toolbar.observeJob("toolbar.advanced.fold", function() {

            $tx.hide(_elAdvanced);
            $tx.removeClassName(_elBasic, 'tx-toolbar-basic-open');
        });

        _toolbar.observeJob("toolbar.advanced.spread", function() {

            $tx.show(_elAdvanced);
            $tx.addClassName(_elBasic, 'tx-toolbar-basic-open');
        });

        var _isOpened = _FALSE;
        var _toolHandler = function() {
            if (_isOpened) {
                _toolbar.fireJobs("toolbar.advanced.fold");
            } else {
                _toolbar.fireJobs("toolbar.advanced.spread");
            }
            _isOpened = !_isOpened;
        };
        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            _NULL,
            /* handler */
            _toolHandler
        );

        if (config.opened == _TRUE) {
            _elAdvanced.show();
            $tx.addClassName(_elBasic, 'tx-toolbar-basic-open');
            _isOpened = _TRUE;
        }
    }
});
/**
 * @fileoverview
 * Tool '서식' Source,
 *
 */
TrexConfig.addTool(
    "tabletemplate", {
        sync: _FALSE,
        status: _TRUE,
        rows: 5,
        cols: 9,
        options: [
            { label: 'image', data: 1, klass: 'tx-tabletemplate-1' },
            { label: 'image', data: 2, klass: 'tx-tabletemplate-2' },
            { label: 'image', data: 3, klass: 'tx-tabletemplate-3' },
            { label: 'image', data: 4, klass: 'tx-tabletemplate-4' },
            { label: 'image', data: 5, klass: 'tx-tabletemplate-5' },
            { label: 'image', data: 6, klass: 'tx-tabletemplate-6' },
            { label: 'image', data: 7, klass: 'tx-tabletemplate-7' },
            { label: 'image', data: 8, klass: 'tx-tabletemplate-8' },
            { label: 'image', data: 9, klass: 'tx-tabletemplate-9' },

            { label: 'image', data: 10, klass: 'tx-tabletemplate-10' },
            { label: 'image', data: 11, klass: 'tx-tabletemplate-11' },
            { label: 'image', data: 12, klass: 'tx-tabletemplate-12' },
            { label: 'image', data: 13, klass: 'tx-tabletemplate-13' },
            { label: 'image', data: 14, klass: 'tx-tabletemplate-14' },
            { label: 'image', data: 15, klass: 'tx-tabletemplate-15' },
            { label: 'image', data: 16, klass: 'tx-tabletemplate-16' },
            { label: 'image', data: 17, klass: 'tx-tabletemplate-17' },
            { label: 'image', data: 18, klass: 'tx-tabletemplate-18' },

            { label: 'image', data: 19, klass: 'tx-tabletemplate-19' },
            { label: 'image', data: 20, klass: 'tx-tabletemplate-20' },
            { label: 'image', data: 21, klass: 'tx-tabletemplate-21' },
            { label: 'image', data: 22, klass: 'tx-tabletemplate-22' },
            { label: 'image', data: 23, klass: 'tx-tabletemplate-23' },
            { label: 'image', data: 24, klass: 'tx-tabletemplate-24' },
            { label: 'image', data: 25, klass: 'tx-tabletemplate-25' },
            { label: 'image', data: 26, klass: 'tx-tabletemplate-26' },
            { label: 'image', data: 27, klass: 'tx-tabletemplate-27' },

            { label: 'image', data: 28, klass: 'tx-tabletemplate-28' },
            { label: 'image', data: 29, klass: 'tx-tabletemplate-29' },
            { label: 'image', data: 30, klass: 'tx-tabletemplate-30' },
            { label: 'image', data: 31, klass: 'tx-tabletemplate-31' },
            { label: 'image', data: 32, klass: 'tx-tabletemplate-32' },
            { label: 'image', data: 33, klass: 'tx-tabletemplate-33' },
            { label: 'image', data: 34, klass: 'tx-tabletemplate-34' },
            { label: 'image', data: 35, klass: 'tx-tabletemplate-35' },
            { label: 'image', data: 36, klass: 'tx-tabletemplate-36' },

            { label: 'image', data: 37, klass: 'tx-tabletemplate-37' },
            { label: 'image', data: 38, klass: 'tx-tabletemplate-38' },
            { label: 'image', data: 39, klass: 'tx-tabletemplate-39' },
            { label: 'image', data: 40, klass: 'tx-tabletemplate-40' },
            { label: 'image', data: 41, klass: 'tx-tabletemplate-41' },
            { label: 'image', data: 42, klass: 'tx-tabletemplate-42' },
            { label: 'image', data: 43, klass: 'tx-tabletemplate-43' },
            { label: 'image', data: 44, klass: 'tx-tabletemplate-44' },
            { label: 'image', data: 45, klass: 'tx-tabletemplate-45' }

        ]
    }

);

Trex.Tool.Tabletemplate = Trex.Class.create({
    $const: {
        __Identity: 'tabletemplate'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _tool = this;
        var _canvas = this.canvas;
        var _map = {};
        config.options.each(function(option) {
            _map[option.data] = {
                type: option.type
            };
        });

        var _toolHandler = function(data) {
            if (!_map[data]) {
                return;
            }

            var _table = _NULL;
            _canvas.execute(function(processor) {
                if (processor.table) {
                    _table = processor.findNode('table');
                    processor.table.setTemplateStyle(_table, data);
                }
            });


        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            new Trex.Menu.List(this.menuCfg),
            /* handler */
            _toolHandler
        );

    }

});

/**
 * @fileoverview
 * '줄간격' Icon Source,
 * Class Trex.Tool.LineHeight configuration을 포함
 *
 */
TrexConfig.addTool(
    "lineheight", {
        sync: _FALSE,
        status: _TRUE,
        options: [
            // { label: '50%', title: '50%', data: '0.5' },
            // { label: '80%', title: '80%', data: '0.8' },
            // { label: '100%', title: '100%', data: '1.0' },
            // { label: '120%', title: '120%', data: '1.2' },
            // { label: '150%', title: '150%', data: '1.5' },
            // { label: '180%', title: '180%', data: '1.8' },
            // { label: '200%', title: '200%', data: '2.0' }
            // Outlook에서 %만 인식함. 50%는 글자 짤림.
            { label: '80%', title: '80%', data: '80%' },
            { label: '90%', title: '90%', data: '90%' },
            { label: '100%', title: '100%', data: '100%' },
            { label: '110%', title: '110%', data: '110%' },
            { label: '120%', title: '120%', data: '120%' },
            { label: '130%', title: '130%', data: '130%' },
            { label: '140%', title: '140%', data: '140%' },
            { label: '150%', title: '150%', data: '150%' },
            { label: '180%', title: '180%', data: '180%' },
            { label: '200%', title: '200%', data: '200%' }
        ]
    }
);

Trex.Tool.LineHeight = Trex.Class.create({
    $const: {
        __Identity: 'lineheight'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;

        var _defaultProperty = _canvas.getStyleConfig().lineHeight;
        var _optionz = (config.options || []);
        var _map = {};
        _optionz.each(function(option) {
            _map[option.data] = option.title;
        });

        var _toolHandler = function(command) {
            _canvas.execute(function(processor) {
                var _nodes = processor.blocks(function() {
                    return '%paragraph';
                });
                processor.apply(_nodes, {
                    'style': {
                        'lineHeight': command
                    }
                });
            });
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
                selectedValue: _defaultProperty
            })),
            /* menu */
            new Trex.Menu.Select(this.menuCfg),
            /* handler */
            _toolHandler);
    }
});

/**
 * @fileoverview
 *  여러 Style의 리스트를 삽입 할 수 있는 Tool 'styledlist' Source,
 * Class Trex.Tool.StyledList 와 configuration을 포함
 *
 */

TrexMessage.addMsg({
    '@styledlist.subtitle1': Trex._I18N.g('styledlist.subtitle1', '취소'),
    '@styledlist.subtitle2': Trex._I18N.g('styledlist.subtitle2', '동그라미'),
    '@styledlist.subtitle3': Trex._I18N.g('styledlist.subtitle3', '네모'),
    '@styledlist.subtitle4': Trex._I18N.g('styledlist.subtitle4', '숫자'),
    '@styledlist.subtitle5': Trex._I18N.g('styledlist.subtitle5', '로마숫자'),
    '@styledlist.subtitle6': Trex._I18N.g('styledlist.subtitle6', '알파벳')
});

TrexConfig.addTool(
    "styledlist", {
        status: _TRUE,
        options: [
            { label: TXMSG('@styledlist.subtitle1'), title: 'cancel', type: 'cancel', data: 'cancel', klass: 'tx-styledlist-0' },
            { label: TXMSG('@styledlist.subtitle2'), title: 'disc', type: 'ul', data: 'disc', klass: 'tx-styledlist-1' },
            { label: TXMSG('@styledlist.subtitle3'), title: 'square', type: 'ul', data: 'square', klass: 'tx-styledlist-2' },
            { label: TXMSG('@styledlist.subtitle4'), title: 'decimal', type: 'ol', data: 'decimal', klass: 'tx-styledlist-3' },
            { label: TXMSG('@styledlist.subtitle5'), title: 'upper-roman', type: 'ol', data: 'upper-roman', klass: 'tx-styledlist-4' },
            { label: TXMSG('@styledlist.subtitle6'), title: 'upper-alpha', type: 'ol', data: 'upper-alpha', klass: 'tx-styledlist-5' }
        ],
        hotKey: {
            ul: { // ctrl + alt + u
                ctrlKey: _TRUE,
                altKey: _TRUE,
                keyCode: 85
            },
            ol: { // ctrl + alt + o
                ctrlKey: _TRUE,
                altKey: _TRUE,
                keyCode: 79
            }
        }
    }
);

Trex.Tool.StyledList = Trex.Class.create({
    $const: {
        __Identity: 'styledlist'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
        self.createListStyleMap(config);
        self.weave(
            new Trex.Button.StyledList(self.buttonCfg),
            new Trex.Menu.Select(self.menuCfg),
            self.handler,
            self.menuInitHandler.bind(self)
        );
        self.indentHelper = Trex.Tool.Indent.Helper;
        /* HotKey Disable 
        self.bindKeyboard(config.hotKey.ul, self.handler.bind(self, "disc"));
        self.bindKeyboard(config.hotKey.ol, self.handler.bind(self, "decimal"));
        */
        self.startSyncButtonWithStyle();
    },
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
        config.options.each(function(option) {
            listStyleMap[option.data] = {
                type: option.type,
                klass: option.klass
            };
        });
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
        var listTag = self.listStyleMap[data].type;
        var listHeadStyle = { listStyleType: data };

        self.canvas.execute(function(processor) {
            if (listTag == 'cancel') {
                self.outdentListItem(processor);
            } else {
                self.createListFromSelection(processor, listTag, listHeadStyle);
            }
        });
    },
    outdentListItem: function(processor) {
        processor.executeUsingCaret(function(range, savedCaret) {
            var blockNodes = Trex.Tool.Indent.Helper.findBlocksToIndentFromRange(range, processor, savedCaret);
            blockNodes.each(function(node) {
                Trex.Tool.Indent.Operation.OutdentListItem(node, processor);

            });
        });
    },
    createListFromSelection: function(processor, listTag, listHeadStyle) {
        var self = this;
        processor.executeUsingCaret(function(range, savedCaret) {
            var blockNodes = self.indentHelper.findBlocksToIndentFromRange(range, processor, savedCaret);
            var listGroups = self.groupEachList(blockNodes);
            listGroups.each(function(nodes) {
                var builder = new Trex.Tool.StyledList.ListBuilder(processor, listTag, listHeadStyle);
                builder.createListForNodes(nodes);
            });
        });
        this._removeBrInListItemForIE(processor);
    },
    _removeBrInListItemForIE: function(processor) {
        // FTDUEDTR-1391
        if ($tx.msie_docmode >= 11) {
            var range = processor.createGoogRange();
            var startNode = range.getStartNode();
            if (range.isCollapsed() &&
                $tom.isElement(startNode) &&
                $tom.isElement(startNode.firstChild) &&
                $tom.isTagName(startNode.firstChild, 'br')) {
                $tom.remove(startNode.firstChild);
                startNode.appendChild(processor.newText(''));
            }
        }
    },
    groupEachList: function(blockNodes) {
        var indentHelper = this.indentHelper;
        var groupsForList = [];
        var currentGroup = [];
        var previousCell = _NULL;
        blockNodes.each(function(node) {
            var currentCell = indentHelper.findCurrentCell(node);
            // new list group detected
            if (currentCell != previousCell) {
                if (currentGroup.length > 0) {
                    groupsForList.push(currentGroup);
                    currentGroup = [];
                }
                previousCell = currentCell;
            }

            currentGroup.push(node);
        });
        // remained group
        if (currentGroup.length > 0) {
            groupsForList.push(currentGroup);
        }
        return groupsForList;
    },
    menuInitHandler: function() {
        var insideList = this.canvas.query(function(processor) {
            return !!processor.findNode('%listhead');
        });
        var elCancel = $tom.collect(this.menu.elMenu, 'li');
        if (insideList) {
            $tx.show(elCancel);
        } else {
            $tx.hide(elCancel);
        }
    },
    startSyncButtonWithStyle: function() {
        var self = this;
        var canvas = self.canvas;
        var cachedProperty = self.getDefaultProperty();

        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
            var listHeadStyle = canvas.query(function(processor) {
                var node = processor.findNode('%listhead');
                return processor.queryStyle(node, 'listStyleType');
            });
            listHeadStyle = listHeadStyle || self.getDefaultProperty();
            if (cachedProperty == listHeadStyle) {
                return;
            }

            var text = self.getButtonClassByValue(listHeadStyle);
            self.button.setText(text);
            cachedProperty = listHeadStyle;
        });
    },
    getDefaultProperty: function() {
        return "decimal";
    },
    getButtonClassByValue: function(value) {
        var listStyleMap = this.listStyleMap;
        if (listStyleMap[value]) {
            return listStyleMap[value].klass;
        } else {
            return listStyleMap[this.getDefaultProperty()].klass;
        }
    }
});

Trex.Button.StyledList = Trex.Class.create({
    $extend: Trex.Button.Select,
    setText: function(text) {
        this.elIcon.className = "tx-icon " + text;
    }
});

Trex.Tool.StyledList.ListBuilder = Trex.Class.create({
    currentDepth: _NULL,
    prepared: _FALSE,
    listElement: _NULL,
    uselessListCandidate: [],
    processor: _NULL,
    initialize: function(processor, listTag, listHeadStyle) {
        this.processor = processor;
        this.listTag = listTag;
        this.listStyle = listHeadStyle;
    },
    createListForNodes: function(nodes) {
        var self = this;
        var depthList = self.getNodeDepthList(nodes);
        depthList.each(function(object) {
            var node = object.node;
            var depth = object.depth;
            if (!self.prepared) {
                self.prepareRootList(node, depth);
            }
            self.adjustDepth(node, depth);
            self.appendAsListItem(node);
        });
        self.cleanupEmptyList();
    },
    getNodeDepthList: function(list) {
        var self = this;
        return list.map(function(node) {
            return { node: node, depth: self.countDepthOfList(node) };
        });
    },
    countDepthOfList: function(node) {
        var count = 0;
        var parent = $tom.parent(node);
        while (parent && !$tom.isBody(parent)) {
            if ($tom.kindOf(parent, "ol,ul")) {
                count++;
            } else if ($tom.kindOf(parent, "th,td")) {
                break;
            }
            parent = $tom.parent(parent);
        }
        return (count || 1);
    },
    prepareRootList: function(node, depth) {
        var self = this;
        self.listElement = self.createNewList();
        var insertionPoint;
        if (node.tagName == "LI") {
            self.uselessListCandidate.push(node.parentNode);
            insertionPoint = $tom.divideNode(node.parentNode, $tom.indexOf(node));
        } else {
            insertionPoint = node;
        }
        $tom.insertAt(self.listElement, insertionPoint);
        self.currentDepth = depth;
        self.listDepth = depth;
        self.prepared = _TRUE;
    },
    adjustDepth: function(node, depth) {
        var self = this;
        while (depth != self.currentDepth) {
            if (depth > self.currentDepth) {
                self.increaseDepth();
            } else {
                self.decreaseDepth();
            }
        }
    },
    increaseDepth: function() {
        var self = this;
        var listElement = self.listElement;

        self.currentDepth++;
        var subList = self.createNewList();
        listElement.appendChild(subList);
        self.listElement = subList;
    },
    decreaseDepth: function() {
        var self = this;
        var listElement = self.listElement;

        self.currentDepth--;
        if (self.listDepth > self.currentDepth) { // 새로 만든 listgroup의 depth가 부족하기 때문에 최상위에 listgroup을 추가해서 트리를 키운다.
            self.uselessListCandidate.push(listElement.parentNode);
            var insertPosition = $tom.divideNode(listElement.parentNode, $tom.indexOf(listElement));
            var newList = self.createNewList();
            $tom.insertAt(newList, insertPosition);
            newList.appendChild(listElement);
        }
        self.listElement = listElement.parentNode;
    },
    createNewList: function() {
        var self = this;
        var newList = self.processor.newNode(self.listTag);
        $tx.setStyle(newList, self.listStyle);
        return newList;
    },
    cleanupEmptyList: function() {
        this.uselessListCandidate.each(function(node) {
            $tom.removeListIfEmpty(node);
        });
    },
    wrapWithListItem: function(node) {
        if (node.tagName == "LI") {
            return node;
        } else if (node.tagName == "P" || ($tx.webkit && node.tagName == "DIV")) {
            // p에 스타일이 있으면 marginLeft는 지우고 li로 감싸기
            var newListItem = this.createListItem();
            $tom.applyStyles(node, { marginLeft: _NULL });
            if ($tom.getStyleText(node)) {
                $tom.wrap(newListItem, node);
                return newListItem;
            } else {
                return $tom.replace(node, newListItem);
            }
        } else {
            var li = this.createListItem();
            li.appendChild(node);
            return li;
        }
    },
    createListItem: function() {
        return this.processor.newNode("li");
    },
    appendAsListItem: function(node) {
        var listItem = this.wrapWithListItem(node);
        if ($tom.kindOf(node.parentNode, "%listhead")) {
            this.uselessListCandidate.push(node.parentNode);
        }
        this.listElement.appendChild(listItem);
    }
});

/**
 * @fileoverview
 * '링크삽입' Icon Source,
 * Class Trex.Tool.Link과 configuration을 포함
 *
 */
TrexConfig.addTool(
    "link", {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE
    }
);

TrexMessage.addMsg({
    '@insertlink.cancel.image': Trex._I18N.g('btn_cancel', "#iconpath/btn_cancel.gif?open&v=2"),
    '@insertlink.confirm.image': Trex._I18N.g('btn_confirm', "#iconpath/btn_confirm.gif?open&v=2"),
    '@insertlink.invalid.url': Trex._I18N.g('insertlink.invalid.url', "URL을 입력해주세요."),
    '@insertlink.link.alt': Trex._I18N.g('insertlink.link.alt', "[#{title}]로 이동합니다."),
    '@insertlink.remove.image': Trex._I18N.g('btn_remove', "#iconpath/btn_remove.gif?open&v=2"),
    '@insertlink.title': Trex._I18N.g('insertlink.title', "선택된 부분에 걸릴 URL주소를 넣어주세요."),
    '@insertlink.onclick.target': Trex._I18N.g('insertlink.onclick.target', "클릭 시"),
    '@insertlink.target.blank': Trex._I18N.g('insertlink.target.blank', "새 창"),
    '@insertlink.target.self': Trex._I18N.g('insertlink.target.self', "현재창"),
    '@insertlink.target.message': Trex._I18N.g('url_message', "클릭시 새창으로 열립니다."),
    '@insertlink.class.name': "tx-link"
});

Trex.Tool.Link = Trex.Class.create({
    $const: {
        __Identity: 'link'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _tool = this;
        var _canvas = this.canvas;

        var _toolHandler = function(data) {
            if (_canvas.isWYSIWYG()) {
                if (data) {
                    _canvas.execute(function(processor) {
                        var _attributes = {
                            'href': data.link,
                            'target': data.target ? data.target : '_blank',
                            'className': data.className
                        };
                        var _aNode, _nodes;
                        if (processor.findNode('a')) {
                            _aNode = processor.findNode('a');
                            $tom.applyAttributes(_aNode, _attributes);
                        } else if (processor.hasControl()) {
                            _nodes = processor.controls(function() {
                                return 'img';
                            });
                            $tom.wrap(processor.create('a', _attributes), _nodes);
                        } else if (processor.isCollapsed()) {
                            _aNode = processor.create('a', _attributes);
                            var text = processor.doc.createTextNode(data.link);
                            _aNode.appendChild(text);
                            processor.pasteNode(_aNode, _FALSE);
                        } else {
                            _nodes = processor.inlines(function() {
                                return '%text,img,a,%inline';
                            });
                            _nodes.each(function(node) {
                                if ($tom.hasUsefulChildren(node, _TRUE)) {
                                    if ($tom.kindOf(node, 'a')) {
                                        $tom.applyAttributes(node, _attributes);
                                    } else if ($tom.kindOf(node, 'img')) {
                                        $tom.wrap(processor.create('a', _attributes), [node]);
                                    } else {
                                        var _styleValue = $tom.getStyleText(node);
                                        var _oldNodes = $tom.collectAll(node, 'a');
                                        _oldNodes.each(function(oldNode) {
                                            $tom.moveChildToParent(oldNode);
                                            $tom.remove(oldNode);
                                        });
                                        var _aNode = processor.create('a', _attributes);
                                        $tom.setStyleText(_aNode, _styleValue);
                                        $tom.replace(node, _aNode);
                                    }
                                } else {
                                    $tom.remove(node);
                                }
                            });
                        }
                    });
                } else {
                    _canvas.execute(function(processor) {
                        var _node = processor.findNode('a');
                        if (_node) {
                            processor.unwrap(_node);
                        }
                    });
                }
            } else {
                _canvas.execute(function(processor) {
                    processor.insertTag('<a href="' + data.link + '" target="' + data.target + '" >', '</a>');
                });
            }
        };

        var __DefaultValue = "";
        var _initHandler = function() {
            if (_canvas.isWYSIWYG()) {
                return _canvas.query(function(processor) {
                    var node, value, target, text;
                    node = processor.findNode('a');
                    if (node) {
                        value = $tom.getAttribute(node, "href");
                        if (value) {
                            target = $tom.getAttribute(node, "target");
                            return {
                                exist: _TRUE,
                                value: value,
                                target: target
                            };
                        }
                    } else {
                        text = processor.getText();
                        if (/^\w+\:\/\/\S+/.test(text)) { // only for url with protocol.
                            return {
                                exist: _FALSE,
                                value: text
                            }
                        }
                    }
                    return {
                        exist: _FALSE,
                        value: __DefaultValue
                    };
                });
            } else {
                return {
                    exist: _FALSE,
                    value: __DefaultValue
                };
            }
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            new Trex.Menu.Link(this.menuCfg),
            /* handler */
            _toolHandler,
            /* handler for menu initial value */
            _initHandler
        );

        var _popdownHandler = function(ev) {
            _tool.button.onMouseDown(ev);
        };
        /* HotKey Disable 
        this.bindKeyboard({ // ctrl + k - 링크
            ctrlKey: _TRUE,
            keyCode: 75
        }, _popdownHandler);
        */
    }

});

/* Trex.Menu.Link ************************************************************************************/
Trex.MarkupTemplate.add(
    'menu.insertlink', [
        '<div class="tx-menu-inner">',
        '    <dl>',
        '        <dt>',
        '            @insertlink.title',
        '        </dt>',
        '        <dd>',
        '            <input type="text" class="tx-text-input"/>',
        '        </dd>',
        '        <dd>', //  class="tx-rp"
        // '            <span class="tx-text tx-first">@insertlink.onclick.target</span>',
        // '            <span><input type="radio" name="tx-insertlink-win" value="_blank"/><span class="tx-text">@insertlink.target.blank</span></span>',
        // '            <span><input type="radio" name="tx-insertlink-win" value="_self"/><span class="tx-text">@insertlink.target.self</span></span>',
        '			<span class="tx-text link-target-msg">@insertlink.target.message</span>',
        '        </dd>',
        '        <dd class="tx-hr">',
        '            <hr/>',
        '        </dd>',
        '        <dd>',
        '            <img width="32" height="21" src="@insertlink.confirm.image"/>',
        '            <img width="32" height="21" src="@insertlink.cancel.image"/>',
        '            <img width="51" height="21" src="@insertlink.remove.image" style="display: none;"/>',
        '        </dd>',
        '    </dl>',
        '</div>'
    ].join("")
);
Trex.Menu.Link = Trex.Class.create({
    $extend: Trex.Menu,
    ongenerated: function() {
        var _elMenu = this.elMenu;
        Trex.MarkupTemplate.get('menu.insertlink').evaluateToDom({}, _elMenu);

        // var _elTargets = $tom.collectAll(_elMenu, ".tx-rp input");
        // var _newInput = this.newInput = _elTargets[0];
        // $tx.observe(_newInput, "click", function(){
        // 		_newInput.checked = "checked";
        // 		_currInput.checked = "";
        // });
        // var _currInput = this.currInput = _elTargets[1];
        // $tx.observe(_currInput, "click", function(){
        // 		_currInput.checked = "checked";
        // 		_newInput.checked = "";
        // });
        this._targetMsg = $tom.collect(_elMenu, ".link-target-msg");
        var _checkValidation = this.urlValidator;
        var _elInput = this.elInput = $tom.collect(_elMenu, 'input.tx-text-input');
        var _self = this;
        $tx.observe(_elInput, "keydown", function(ev) {
            if (ev.keyCode == 13) { //Enter
                var _val = _checkValidation(_elInput.value);
                if (!_val) {
                    alert(TXMSG("@insertlink.invalid.url"));
                    $tx.stop(ev);
                    return;
                }
                var _target = _self._dataTarget||'_blank'; //_newInput.checked ? _newInput.value : _currInput.value;
                this.onSelect(ev, {
                    link: _val,
                    target: _target,
                    className: TXMSG("@insertlink.class.name")
                });
                $tx.stop(ev);
            }
        }.bindAsEventListener(this));

        var _elImgs = $tom.collectAll(_elMenu, 'img');
        $tx.observe(_elImgs[0], "click", function(ev) {
            var _val = _checkValidation(_elInput.value);
            if (!_val) {
                alert(TXMSG("@insertlink.invalid.url"));
                $tx.stop(ev);
                return;
            }
            var _target = _self._dataTarget||'_blank'; //_newInput.checked ? _newInput.value : _currInput.value;
            this.onSelect(ev, {
                link: _val,
                target: _target,
                className: TXMSG("@insertlink.class.name")
            });
            $tx.stop(ev);
        }.bind(this));

        $tx.observe(_elImgs[1], "click", function() {
            this.onCancel();
        }.bindAsEventListener(this));

        var _elRemoveBtn = $tx(_elImgs[2]);
        $tx.observe(_elRemoveBtn, "click", function(ev) {
            this.onSelect(ev, _NULL);
        }.bindAsEventListener(this));
        this.toggleRemoveBtn = function(exist) {
            _elRemoveBtn.style.display = ((exist) ? '' : 'none');
        };
    },
    onregenerated: function() {
        var _elInput = this.elInput;
        var _initData = this.initHandler();
        _elInput.value = _initData.value;
        this._dataTarget = _initData.target||'_blank';
        
        if(this._targetMsg){
            this._targetMsg.style.display = (this._dataTarget && this._dataTarget != '_blank')?'none':'';
        }
        
        // if(_initData.target == "_self" || _initData.target == "_top"){
        // 	this.currInput.checked = "checked";
        // 	this.newInput.checked = "";
        // }else{
        // 	this.newInput.checked = "checked";
        // 	this.currInput.checked = "";
        // }

        this.toggleRemoveBtn(_initData.exist);
        _elInput.focus();

        // Set focus to end of input box. ( For IE );
        if ($tx.msie_nonstd) {
            setTimeout(function() {
                try {
                    _elInput.focus();
                    var _sel = _DOC.selection.createRange();
                    _sel.move("character", _elInput.value.length);
                    _sel.select();
                } catch (ignore) {}
            }, 100);
        }
    },
    urlValidator: function(value) {
        if (!value) {
            return _FALSE;
        }
        value = value.trim();
        if (value.length == 0) {
            return _FALSE;
        }
        var pattern = /^[a-z0-9+.-]+:|^\/\/|^#/i; // FTDUEDTR-1330 && MAILCS-24754
        if (pattern.test(value)) {
            return value;
        } else {
            return "http://" + value;
        }
    }
});

/**
 * @fileoverview
 * 직접 편집이 가능한 기능을 포함한 Tool '글상자' Source,
 * Class Trex.Tool.RichTextBox 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "richtextbox", {
        sync: _FALSE,
        status: _TRUE,
        rows: 4,
        cols: 6,
        borderwidth: 1,
        bordercolor: '#cbcbcb',
        bgcolor: '#ffffff',
        padding: "10px",
        styles: [
            { klass: "", image: "#iconpath/textbox/thum_line01.gif?open&v=2", data: "solid" },
            { klass: "", image: "#iconpath/textbox/thum_line02.gif?open&v=2", data: "double" },
            { klass: "", image: "#iconpath/textbox/thum_line03.gif?open&v=2", data: "dashed" },
            { klass: "", image: "#iconpath/textbox/thum_line04.gif?open&v=2", data: "none" }
        ],
        options: Trex.__CONFIG_COMMON.textbox.options,
        thumbs: Trex.__CONFIG_COMMON.thumbs
    }
);

TrexMessage.addMsg({
    '@richtextbox.add': Trex._I18N.g('richtextbox.add', "더하기"),
    '@richtextbox.sub': Trex._I18N.g('richtextbox.sub', "빼기"),
    '@richtextbox.alert': Trex._I18N.g('richtextbox.alert', "1 이상 20 이하의 숫자만 입력 가능합니다."),
    '@richtextbox.bg.color': Trex._I18N.g('richtextbox.bg.color', "배경색"),
    '@richtextbox.border.color': Trex._I18N.g('richtextbox.border.color', "선 색"),
    '@richtextbox.border.style': Trex._I18N.g('richtextbox.border.style', "선 스타일"),
    '@richtextbox.border.width': Trex._I18N.g('richtextbox.border.width', "선 굵기")
});

Trex.Tool.RichTextBox = Trex.Class.create({
    $const: {
        __Identity: 'richtextbox'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _canvas = this.canvas;
        var _toolbar = this.toolbar;
        var _tool = this;

        var _toolHandler = this.handler = function() {
            var _this = _tool.menu;
            var _style = {
                "borderStyle": _this.elPreview.style.borderStyle,
                "borderWidth": _this.elPreview.style.borderWidth,
                "borderColor": _this.elPreview.style.borderColor,
                "backgroundColor": _this.elPreview.style.backgroundColor,
                "padding": _this.padding
            };
            var _tag = "div";
            var _attributes = { "className": 'txc-textbox', style: _style };
            _canvas.execute(function(processor) {
                var _bNode = $('<div><p>&nbsp;</p></div>').css(_attributes.style).addClass(_attributes.className)[0];
                processor.pasteNode(_bNode, true);

                // var _nodes = processor.blocks(function() {
                //     return '%wrapper,%paragraph';
                // });				
                // var _bNode;
                // _nodes = _nodes.findAll(function(node) {
                //     if($tom.kindOf(node, "%innergroup")) {
                //         _bNode = processor.wrap($tom.children(node), _tag, _attributes);
                //         _toolbar.fireJobs('cmd.textbox.added', _bNode);
                //         return _FALSE;
                //     } else {
                //         return _TRUE;
                //     }
                // });
                // if(_nodes.length == 1 && _nodes[0].tagName 
                // 	&& (_nodes[0].tagName.toLowerCase() == "p")
                // 	&& (_nodes[0].innerHTML == "" 
                // 		|| _nodes[0].innerHTML == "&nbsp;"
                // 		// || _nodes[0].innerHTML == "<br>"
                // 		// || (_nodes[0].innerHTML.length == 5
                // 		// 	&& encodeURIComponent(_nodes[0].innerHTML) == "%EF%BB%BF%3Cbr%3E")						
                // 		|| (_nodes[0].innerHTML.length == 1 
                // 			&& encodeURIComponent(_nodes[0].innerHTML) == "%EF%BB%BF")
                // 		|| (_nodes[0].innerHTML.length == 7 
                // 			&& encodeURIComponent(_nodes[0].innerHTML) == "%26nbsp%3B%EF%BB%BF")
                // 	)
                // ){
                // 	_nodes[0] = $('<p>&nbsp;</p>')[0];
                // 	_bNode = processor.wrap(_nodes, _tag, _attributes);
                // 	processor.pasteNode(_bNode);
                // 	processor.bookmark.startContainer = _bNode.firstChild;
                // 	processor.bookmark.endContainer = _bNode.firstChild;
                // }else{
                // 	_bNode = processor.wrap(_nodes, _tag, _attributes);
                // }
                _toolbar.fireJobs('cmd.textbox.added', _bNode);
            });
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            new Trex.Menu.RichTextbox(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }
});
Trex.MarkupTemplate.add(
    'richtextbox.colorpallete', ['<dd class="#{wrapClass}">',
        '	<div class="tx-color-box">',
        '		<a href="javascript:;" class="tx-color-bg-thumb" style="background-color:#{color}"></a>', //==> _elThumb
        '	</div>',
        '	<a href="javascript:;" class="tx-color-arrow-down"></a>',
        '	<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '</dd>'
    ].join("")
);
Trex.Menu.RichTextbox = Trex.Class.create({
    $extend: Trex.Menu,
    ongenerated: function(config) {
        var _this = this;
        var _styleHashMap = {};
        config.options.each(function(option) {
            _styleHashMap[option.data] = option.style;
        });

        this.borderWidth = config.borderWidth || 1;
        this.borderColor = config.borderColor || '#cbcbcb';
        this.bgColor = config.bgColor || '#ffffff';
        this.padding = config.padding;

        var _generateBorderStyle = this.generateBorderStyle.bind(this);
        var _generateBorderWidth = this.generateBorderWidth.bind(this);
        var _generateBorderColor = this.generateBorderColor.bind(this);
        var _generateBgColor = this.generateBgColor.bind(this);

        var _elMenu = this.elMenu;
        var _elHeader = $tom.collect(_elMenu, 'div.tx-menu-header');
        var _elPreviewArea = $tom.collect(_elHeader, 'div.tx-menu-preview-area');
        this.elPreview = $tom.collect(_elPreviewArea, 'div.tx-menu-preview');
        var _elSwitch = this.elSwitch = $tom.collect(_elHeader, 'div.tx-menu-switch');
        var _elSimple = $tom.collect(_elSwitch, 'div.tx-menu-simple');
        var _elAdvanced = $tom.collect(_elSwitch, 'div.tx-menu-advanced');
        var _elInner = $tom.collect(_elMenu, 'div.tx-menu-inner');
        var _elFooter = $tom.collect(_elMenu, 'div.tx-menu-footer');
        var _elConfirm = $tom.collect(_elFooter, 'img.tx-menu-confirm');
        var _elCancel = $tom.collect(_elFooter, 'img.tx-menu-cancel');

        (function create_thumbs_for_simplemode() {
            var _el = _this.simplePalette = tx.div({ className: 'tx-menu-list' });
            _elInner.appendChild(_el);
            var _rows = config.rows;
            var _cols = config.cols;
            _el.innerHTML = Trex.HtmlCreator.createTableMarkup(_rows, _cols, config.options);

            $tx.observe(_el, 'click', function(ev) {
                var _el = $tx.element(ev);
                TrexEvent.fire(_el, {
                    'span': function() {
                        var _class;
                        if (_el.firstChild && _el.firstChild.nodeType == 1 && _el.firstChild.tagName.toLowerCase() == 'img') {
                            _class = _el.firstChild.title;
                        } else {
                            _class = _el.innerText;
                        }
                        var _style = _styleHashMap[_class];
                        applyPreviewStyle(_style);
                    }
                });
                $tx.stop(ev);
            });
        })();

        (function createElementsInInnerContainerForAdvancedMode() {
            var _el = _this.advancedPalette = tx.div({ className: "tx-advanced-list" });
            _elInner.appendChild(_el);
            _el.appendChild(
                tx.dl({
                        style: {
                            "height": "24px"
                        }
                    },
                    tx.dt(TXMSG("@richtextbox.border.style")), _generateBorderStyle()));
            _el.appendChild(tx.dl(tx.dt(TXMSG("@richtextbox.border.width")), _generateBorderWidth()));
            _el.appendChild(tx.dl(tx.dt(TXMSG("@richtextbox.border.color")), _generateBorderColor()));
            _el.appendChild(tx.dl(tx.dt(TXMSG("@richtextbox.bg.color")), _generateBgColor()));
        })();

        var copyStyles = function() {
            _this.borderWidthInput.value = parseInt(_this.elPreview.style.borderWidth);
            _this.borderColorInput.style.backgroundColor = _this.elPreview.style.borderTopColor;
            _this.bgColorInput.style.backgroundColor = _this.elPreview.style.backgroundColor;
        };

        var applyPreviewStyle = function(style) {
            _this.elPreview.style.border = style['border'];
            _this.elPreview.style.backgroundColor = style['backgroundColor']
        };

        var selectMode = function(mode) {
            if (mode == "simple") {
                $tx.addClassName(_elSimple, "tx-selected");
                $tx.show(_this.simplePalette);
                $tx.removeClassName(_elAdvanced, "tx-selected");
                $tx.hide(_this.advancedPalette);
            } else if (mode == "advanced") {
                $tx.removeClassName(_elSimple, "tx-selected");
                $tx.hide(_this.simplePalette);
                $tx.addClassName(_elAdvanced, "tx-selected");
                $tx.show(_this.advancedPalette);
                copyStyles();
            }
            _this.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, {
                detail: {
                    menu: _this
                }
            });
        };

        (function bindingEvents() {
            $tx.observe(_elSimple, 'click', selectMode.bind(_this, "simple"));
            $tx.observe(_elAdvanced, 'click', selectMode.bind(_this, "advanced"));
            $tx.observe(_elConfirm, 'click', _this.onSelect.bind(_this));
            $tx.observe(_elCancel, 'click', function() {
                _this.onCancel();
            });
        })();

        selectMode("simple");
        applyPreviewStyle(_styleHashMap['txc-textbox13']);
    },
    generateBorderStyle: function() {
        var _this = this;
        var _elWrap = tx.dd({ className: 'tx-border-area' });
        $tx.observe(_elWrap, 'click', function(ev) {
            var _el = $tx.element(ev);
            TrexEvent.fire(_el, {
                'img': function(element) {
                    var _data = element.getAttribute("data");
                    _this.elPreview.style.borderStyle = _data;
                    if (_data == 'double' && _this.borderWidthInput.value.toNumber() < 3) {
                        _this.elPreview.style.borderWidth = "3px";
                        _this.borderWidthInput.value = "3";
                    }
                }
            });
            $tx.stop(ev);
        });
        _elWrap.innerHTML = Trex.HtmlCreator.createTableMarkup(1, 4, this.config.styles);
        return _elWrap;
    },
    generateBorderWidth: function() {
        var _this = this;
        var _elWrap = tx.dd({ className: 'tx-border-area' });
        var _elInput = this.borderWidthInput = tx.input({ type: 'text', value: this.borderWidth });
        _elWrap.appendChild(_elInput);

        var _drawDeco = function(width) {
            if (width > 20) {
                alert(TXMSG("@richtextbox.alert"));
                _elInput.value = 20;
            } else if (width < 1) {
                alert(TXMSG("@richtextbox.alert"));
                _elInput.value = 1;
            } else {
                _this.elPreview.style.borderWidth = width + "px";
                _elInput.value = width;
            }
        };

        $tx.observe(_elInput, 'blur', function(ev) {
            _drawDeco(_elInput.value.toNumber(), ev);
        });
        $tx.observe(_elInput, "keydown", function(ev) {
            if (ev.keyCode == $tx.KEY_RETURN)
                $tx.stop(ev);
        });
        var _elAddBtn = tx.a({ href: 'javascript:;', className: 'btn_add' }, TXMSG("@richtextbox.add"));
        _elWrap.appendChild(_elAddBtn);
        $tx.observe(_elAddBtn, 'click', function(ev) {
            _drawDeco(_elInput.value.toNumber() + 1);
            $tx.stop(ev);
        });

        var _elSubBtn = tx.a({ href: 'javascript:;', className: 'btn_sub' }, TXMSG("@richtextbox.sub"));
        _elWrap.appendChild(_elSubBtn);
        $tx.observe(_elSubBtn, 'click', function(ev) {
            _drawDeco(_elInput.value.toNumber() - 1);
            $tx.stop(ev);
        });

        return _elWrap;
    },
    generateBorderColor: function() {
        var _this = this;
        var _elWrap = Trex.MarkupTemplate.get("richtextbox.colorpallete").evaluateAsDom({ "color": this.borderColor, "wrapClass": "tx-color-wrap" });
        var _elPallete = $tom.collect(_elWrap, "div.tx-colorpallete");

        var _changeBorderColor = function(color) {
            _this.elPreview.style.borderColor = _elThumb.style.backgroundColor = _this.borderColor = color;
        };

        var _colorPallete = _NULL;
        var _toggleColorPallete = function() {
            if (_colorPallete == _NULL) {
                _colorPallete = _this.createColorPallete(_elPallete, _changeBorderColor);
                _colorPallete.show();
            } else {
                if (!$tx.visible(_elPallete)) _colorPallete.show();
                else _colorPallete.hide();
            }
        };

        this.externalBorderColorToggler = function() {
            if ($tx.visible(_elPallete)) {
                _colorPallete.hide();
            }
        };

        var _elThumb = this.borderColorInput = $tom.collect(_elWrap, ".tx-color-box a");
        $tx.observe(_elThumb, 'click', function(ev) {
            _this.externalBgColorToggler();
            _toggleColorPallete();
            $tx.stop(ev);
        });

        var _elArrow = $tom.collect(_elWrap, "a.tx-color-arrow-down");
        $tx.observe(_elArrow, 'click', function(ev) {
            _this.externalBgColorToggler();
            _toggleColorPallete();
            $tx.stop(ev);
        });

        return _elWrap;
    },
    createColorPallete: function(element, cmd) {
        var self = this;
        var pallete = new Trex.Menu.ColorPallete({ el: element, thumbs: this.config.thumbs });
        pallete.setCommand(cmd);
        pallete.observeJob(Trex.Ev.__MENU_LAYER_SHOW, function(ev) {
            self.fireJobs(Trex.Ev.__MENU_LAYER_SHOW, ev);
        });
        pallete.observeJob(Trex.Ev.__MENU_LAYER_HIDE, function(ev) {
            self.fireJobs(Trex.Ev.__MENU_LAYER_HIDE, ev);
        });
        pallete.observeJob(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, function(ev) {
            self.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, ev);
        });
        return pallete;
    },
    generateBgColor: function() {
        var _this = this;
        var _elWrap = Trex.MarkupTemplate.get("richtextbox.colorpallete").evaluateAsDom({ "color": this.bgColor });
        var _elPallete = $tom.collect(_elWrap, "div.tx-colorpallete");

        var _changeBgColor = function(color) {
            _this.elPreview.style.backgroundColor = _elThumb.style.backgroundColor = _this.bgColor = color;
        };

        var _colorPallete = _NULL;
        var _toggleColorPallete = function() {
            if (_colorPallete == _NULL) {
                _colorPallete = _this.createColorPallete(_elPallete, _changeBgColor);
                _colorPallete.show();
            } else {
                if (!$tx.visible(_elPallete)) _colorPallete.show();
                else _colorPallete.hide();
            }
        };

        this.externalBgColorToggler = function() {
            if ($tx.visible(_elPallete)) {
                _colorPallete.hide();
            }
        };

        var _elThumb = this.bgColorInput = $tom.collect(_elWrap, ".tx-color-box a");
        $tx.observe(_elThumb, 'click', function(ev) {
            _this.externalBorderColorToggler();
            _toggleColorPallete();
            $tx.stop(ev);
        });

        var _elArrow = $tom.collect(_elWrap, "a.tx-color-arrow-down");
        $tx.observe(_elArrow, 'click', function(ev) {
            _this.externalBorderColorToggler();
            _toggleColorPallete();
            $tx.stop(ev);
        });

        return _elWrap;
    }
});

/**
 * @fileoverview
 * Tool '인용구' Source,
 * Class Trex.Tool.Quote 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "quote", {
        sync: _FALSE,
        status: _TRUE,
        rows: 2,
        cols: 3,
        options: [
            { type: 'image', data: 'tx-quote1', image: Trex._I18N.g('citation_img', '01', '#iconpath/quote/citation01.gif?open&v=2') },
            { type: 'image', data: 'tx-quote2', image: Trex._I18N.g('citation_img', '02', '#iconpath/quote/citation02.gif?open&v=2') },
            { type: 'image', data: 'tx-quote3', image: Trex._I18N.g('citation_img', '03', '#iconpath/quote/citation03.gif?open&v=2') },
            { type: 'image', data: 'tx-quote4', image: Trex._I18N.g('citation_img', '04', '#iconpath/quote/citation04.gif?open&v=2') },
            { type: 'image', data: 'tx-quote5', image: Trex._I18N.g('citation_img', '05', '#iconpath/quote/citation05.gif?open&v=2') },
            { type: 'cancel', data: 'tx-quote6', image: Trex._I18N.g('citation_img', '06', '#iconpath/quote/citation06.gif?open&v=2') }
        ]
    },
    function(root) {
        var _config = TrexConfig.getTool("quote", root);
        _config.options.each(function(option) {
            option.image = TrexConfig.getIconPath(option.image, 'quote');
        });
    }
);

Trex.Tool.Quote = Trex.Class.create({
    $const: {
        __Identity: 'quote'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _tool = this;
        var _canvas = this.canvas;

        var _map = {};
        config.options.each(function(option) {
            _map[option.data] = {
                type: option.type
            };
        });

        var _toolHandler = function(data) {
            if (!_map[data]) {
                return;
            }
            var _type = _map[data].type;
            var _tag = "blockquote";
            var _attributes = { "className": data };

            if (_canvas.isWYSIWYG()) {
                _canvas.execute(function(processor) {
                    var _bNode = processor.findNode(_tag);
                    if (_bNode) {
                        if (_type == "cancel") {
                            processor.unwrap(_bNode);
                        } else {
                            processor.apply(_bNode, _attributes);
                        }
                    } else {
                        if (_type != "cancel") {
                            var _nodes = processor.blocks(function() {
                                return '%wrapper,%paragraph';
                            });
                            _nodes = _nodes.findAll(function(node) {
                                if ($tom.kindOf(node, "%innergroup")) {
                                    processor.wrap($tom.children(node), _tag, _attributes);
                                    return _FALSE;
                                } else {
                                    return _TRUE;
                                }
                            });
                            processor.wrap(_nodes, _tag, _attributes);
                        }
                    }
                });
            } else {
                _canvas.execute(function(processor) {
                    processor.insertTag('<blockquote>', '</blockquote>');
                });
            }
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            new Trex.Menu.List(this.menuCfg),
            /* handler */
            _toolHandler
        );

        var _popdownHandler = function(ev) {
            _tool.button.onMouseDown(ev);
        };
        /* HotKey Disable 
        this.bindKeyboard({ // ctrl + q
            ctrlKey: _TRUE,
            keyCode: 81
        }, _popdownHandler);
        */
    }

});

/**
 * @fileoverview
 *  Table을 삽입하는 기능을 가진 Tool 'table' Source,
 *  Class Trex.Tool.Table,Trex.Menu.Table,Trex.Menu.Table.TableEdit와 configuration 을 포함 하고있다.
 */

TrexConfig.addTool(
    "table", {
        borderStyle: "1px solid #ccc",
        sync: _FALSE,
        status: _TRUE
    },
    function(root) {
        var bgc = TrexConfig.get("canvas", root).styles.backgroundColor;
        if (bgc != "transparent") {
            TrexConfig.getTool("table", root).bgcolor = bgc;
        }
    }
);

TrexMessage.addMsg({
    '@table.alert': Trex._I18N.g('table.alert', "1 이상 30 이하의 숫자만 입력 가능합니다.")
});

Trex.Tool.Table = Trex.Class.create({
    $const: {
        __Identity: 'table',
        __DEFAULT_TABLE_PROPERTY: {
            "cellSpacing": 0,
            "cellPadding": 1,
            "border": 0,
            "style": {
                border: "none",
                borderCollapse: "collapse"
            }
        },
        __DEFAULT_TABLE_PROPERTY_STR: "cellspacing=\"0\" cellpadding=\"0\" border=\"0\"",
        __DEFAULT_TABLE_STYLE: "border:none;border-collapse:collapse;word-break:break-all",
        // KEDITOR `word-break:break-all` : 편집화면과 동일하게 보이도록 하기 위함.
        __DEFAULT_TABLE_CLASS: "txc-table",
        __DEFAULT_TABLE_CELL_HEIGHT: 24,
        __DEFAULT_TABLE_CELL_PADDING: '0px 3px 0px 3px'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _self = this;
        this.tableSize = { row: 0, col: 0 };
        this.tableTemplateLoader = new Trex.Table.TemplateLoader();

        var _canvas = this.canvas;

        var _toolHandler = this.handler = function(data) {
            _canvas.execute(function(processor) {
                // get table width
                var tableWidth = '100%';
                processor.executeUsingCaret(function(range, savedCaret) {
                    var endCaret = savedCaret.getCaret(_FALSE);
                    if (!$tom.ancestor(endCaret, 'table')) {
                        tableWidth = _self.getDefaultTableWidth();
                    }
                });

                // insert empty table
                var table = _self.makeEmptyTable(data, tableWidth);
                var _tNode = processor.pasteContent(table, _TRUE);
                processor.bookmarkInto(_tNode);

                //테이블 스타일 적용
                if (data.type && data.type == 'style') {
                    _self.tableTemplateLoader.getTemplate(data.tableStyle, function(template) {
                        template.apply(_tNode);
                        //self._applyTemplateOutline(_tNode, template.templateData);
                    });
                }

                // open advanced toolbar
                if (!config.isHideAdvanceMenu && _self.toolbar.tools.advanced) {
                    _self.toolbar.tools.advanced.forceOpen();
                }
            });
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            new Trex.Menu.Table(this.menuCfg, _canvas),
            /* handler */
            _toolHandler
        );
    },
    makeEmptyTable: function(data, tableWidth) {
        var tableStringArr = [];
        var row = data.row;
        var col = data.col;

        tableStringArr.push("<table class=\"" + Trex.Tool.Table.__DEFAULT_TABLE_CLASS + "\"");
        tableWidth && tableStringArr.push(' width="' + tableWidth + '"');
        tableStringArr.push(Trex.Tool.Table.__DEFAULT_TABLE_PROPERTY_STR);
        tableStringArr.push(" style=\"");
        tableStringArr.push(Trex.Tool.Table.__DEFAULT_TABLE_STYLE);
        tableStringArr.push(";font-family:");
        tableStringArr.push(this.editor.canvas.getStyle("fontFamily").replace(/"/g, "&quot;"));
        tableStringArr.push(";font-size:");
        tableStringArr.push(this.editor.canvas.getStyle("fontSize"));
        tableStringArr.push("\"><tbody>");

        var borderStyleText = this.config.borderStyle;
        if (data.type && data.type == 'custom') {
            borderStyleText = data.lineWidth + 'px ' + data.lineStyle + ' ' + data.lineColor;
        }
        var tdWidth = this.getDefaultCellWidth(col, tableWidth),
            tdHeight = this.getDefaultCellHeight(row);
        var basicBorder = ["border-bottom:", borderStyleText, ";border-right:", borderStyleText, ";"].join("");

        for (var i = 0; i < row; i++) {
            tableStringArr.push("<tr>");
            for (var j = 0; j < col; j++) {
                var border = [basicBorder];
                tableStringArr.push("<td style=\"width:");
                tableStringArr.push(tdWidth);
                tableStringArr.push(";");
                tableStringArr.push("height:", tdHeight, ";");
                tableStringArr.push(basicBorder);
                if (i == 0) {
                    tableStringArr.push("border-top:", borderStyleText, ";");
                }
                if (j == 0) {
                    tableStringArr.push("border-left:", borderStyleText, ";");
                }
                if (data.type && data.type == 'custom') {
                    if (this.config.bgcolor.toLowerCase() != data.cellColor.toLowerCase())
                        tableStringArr.push("background-color:", data.cellColor, ";");
                }
                if (Trex.Tool.Table.__DEFAULT_TABLE_CELL_PADDING){
                    tableStringArr.push("padding:", Trex.Tool.Table.__DEFAULT_TABLE_CELL_PADDING, ";");
                }
                tableStringArr.push(";\"><p>" + $tom.EMPTY_BOGUS + "</p></td>");
            }
            tableStringArr.push("</tr>")
        }
        tableStringArr.push("</tbody></table>");
        return tableStringArr.join("");
    },
    getDefaultCellWidth: function(columnCount, tableWidth) {
        var width;
        tableWidth = tableWidth || '100%';
        if (tableWidth.toString().indexOf('%') !== -1) {
            width = (100 / columnCount) + '%';
        } else {
            width = parseInt(parseInt(tableWidth, 10) / columnCount, 10);
            if (isNaN(width)) {
                width = 0;
            }
            width = width.toPx();
        }
        return width;
    },
    getDefaultCellHeight: function(rowCount) {
        return Trex.Tool.Table.__DEFAULT_TABLE_CELL_HEIGHT.toPx();
    },
    getDefaultTableWidth: function() { //NOTE: #FTDUEDTR-905
        var tableWidth = this.config.tableWidth;
        if (!tableWidth) {
            tableWidth = this.getCanvasInnerWidth();
        }
        return tableWidth;
    },
    getCanvasInnerWidth: function() {
        var padding = this.canvas.getSizeConfig().contentPadding || 8;
        var width = 600;
        try {
            width = (this.canvas.wysiwygEl.offsetWidth || this.canvas.getSizeConfig().contentWidth || 600) - padding * 2 - 20;
        } catch (e) {}
        return width;
    }
});


Trex.Tool.Table.TemplateWizard = Trex.Class.create({
    initialize: function() {
        this.templateList = (typeof getTableTemplateList == "function") ? getTableTemplateList() : [{
            klass: "ex1",
            common: {
                backgroundColor: "transparent",
                borderTop: "none",
                borderLeft: "none",
                borderRight: "1px solid #d9d9d9",
                borderBottom: "1px solid #d9d9d9"
            },
            firstRow: {
                borderTop: "1px solid #000"
            },
            firstCol: {
                borderLeft: "1px solid #000"
            },
            lastCol: {
                borderRight: "1px solid #000"
            },
            lastRow: {
                borderBottom: "1px solid #000"
            },
            evenRow: {},
            oddRow: {}
        }];
        this.currentTemplate = _NULL;
    },
    applyStyle: function(table, templateIndex) {
        if (isNaN(templateIndex)) {
            return;
        }

        var tableMatrixer = new Trex.Tool.Table.TableCellMatrixer(table);
        var tdMatrix = tableMatrixer.getTdMatrix();

        this.currentTemplate = this.templateList[templateIndex];
        for (var i = 0; i < tdMatrix.length; i++) {
            for (var j = 0; j < tdMatrix[i].length; j++) {
                this.setCellStyle(tdMatrix[i][j], {
                    isEvenRow: (i % 2) == 1,
                    isFirstRow: i == 0,
                    isLastRow: i == tdMatrix.length - 1,
                    isFirstCol: j == 0,
                    isLastCol: (j == tdMatrix[i].length - 1)
                });
            }
        }
    },
    setCellStyle: function(elTd, truthMap) {
        var t = this.currentTemplate;
        var style = Object.extend({}, t['common']);
        Object.extend(style, (truthMap.isEvenRow) ? t['evenRow'] : t['oddRow']);
        Object.extend(style, (truthMap.isFirstRow) ? t['firstRow'] : (truthMap.isLastRow) ? t['lastRow'] : {});
        Object.extend(style, (truthMap.isLastCol) ? t['lastCol'] : {});
        Object.extend(style, (truthMap.isFirstCol) ? t['firstCol'] : {});
        txlib.setStyle(elTd, style);
    },
    getTemplateList: function() {
        return this.templateList;
    }
});
Trex.Tool.Table.TableCellMatrixer = Trex.Class.create({
    initialize: function(table) {
        this.rowSize = this.initRowSize(table);
        this.colSize = this.initColSize(table);
        var context = $tom.first(table, "tbody") || table;
        this.tdMatrix = this.createTdMatrix(context);
        //this.table = table;

        for (var i = 0; i < this.tdMatrix.length; i++) {
            for (var j = 0; j < this.tdMatrix[i].length; j++) {
                var td = this.tdMatrix[i][j];
                if (td.cols > 1) {
                    td.cols--;
                    this.tdMatrix[i].splice(j + 1, 0, td);
                }
            }
        }
        for (var i = 0; i < this.tdMatrix.length; i++) {
            for (var j = 0; j < this.tdMatrix[i].length; j++) {
                var td = this.tdMatrix[i][j];
                if (td.rows > 1) {
                    td.rows--;
                    this.tdMatrix[i + 1].splice(j, 0, td);
                }
            }
        }
    },

    createTdMatrix: function(tbody) {
        var tdMatrix = [];

        var trArr = $tom.children(tbody, "tr");
        for (var i = 0, len = trArr.length; i < len; i++) {
            tdMatrix.push(this.createTdArray(trArr[i]));
        }

        return tdMatrix;
    },
    createTdArray: function(tr) {
        var tdArr = [];

        var tds = $tom.children(tr, "td");
        for (var i = 0, len = tds.length; i < len; i++) {
            tdArr.push(this.decorateSingleTd(tds[i]));
        }
        return tdArr;
    },
    decorateSingleTd: function(td) {
        var cols = parseInt(td.getAttribute("colSpan") || 1);
        var rows = parseInt(td.getAttribute("rowSpan") || 1);
        td.cols = cols;
        td.rows = (rows - 1) * cols + 1;

        return td;
    },
    initRowSize: function(table) {
        return table.rows.length;
    },
    initColSize: function(table) {
        var colSize = 0;
        var tdArr = $tom.children($tom.collect(table, "tr"), "td");
        tdArr.each(function(td) {
            colSize += parseInt(td.getAttribute("colSpan") || 1);
        });

        return colSize;
    },
    getRowSize: function() {
        return this.rowSize;
    },
    getColSize: function() {
        return this.colSize;
    },
    getTdMatrix: function() {
        return this.tdMatrix;
    }
});

TrexMessage.addMsg({
    '@table.title.insert': Trex._I18N.g('table.title.insert', '표삽입 &nbsp;'),
    '@table.title.setDirectly': Trex._I18N.g('table.title.setDirectly', '표 직접설정'),
    '@table.title.row': Trex._I18N.g('table.title.row', '행 개수'),
    '@table.title.col': Trex._I18N.g('table.title.col', '열 개수'),
    '@table.detail.menual': Trex._I18N.g('table.detail.menual', '직접입력'),
    '@table.detail.style': Trex._I18N.g('table.detail.style', '스타일선택'),
    '@table.detail.cell_bg': Trex._I18N.g('table.detail.cell_bg', '셀 배경색'),
    '@table.detail.border_style': Trex._I18N.g('table.detail.border_style', '테두리 스타일'),
    '@table.detail.border_line': Trex._I18N.g('table.detail.border_line', '테두리 두께'),
    '@table.detail.border_color': Trex._I18N.g('table.detail.border_color', '테두리 색'),
    '@table.detail.ok': Trex._I18N.g('table.detail.ok', '확인'),
    '@table.detail.cancel': Trex._I18N.g('table.detail.cancel', '취소')
});
Trex.MarkupTemplate.add(
    'menu.table.direct', [
        '<div>@table.title.setDirectly</div>',
        '<div class="tx-table-input-area">',
        '<div class="tx-field tx-col-field">@table.title.row<input type="text" value="1"><a class="tx-btn tx-btn-add" href="javascript:;">@table.title.row+</a><a class="tx-btn tx-btn-sub" href="javascript:;">@table.title.row-</a></div>',
        '<div class="tx-field tx-row-field">@table.title.col<input type="text" value="1"><a class="tx-btn tx-btn-add" href="javascript:;">@table.title.col+</a><a class="tx-btn tx-btn-sub" href="javascript:;">@table.title.col-</a></div>',
        '</div>'
    ].join("")
);
Trex.MarkupTemplate.add(
    'menu.table.detail', [
        '	<div class="cell_prop">',
        '		<div class="g_divide line-bottom">',
        '			<dl>',
        '				<dt>@table.title.row</dt>',
        '				<dd><span class="g_select"><input type="text" name="detail_row" class="txt txt_sel" /><button name="btn_detail_row_up" class="bg btn btn_up_arrow">+</button><button name="btn_detail_row_down" class="bg btn btn_down_arrow">-</button></span></dd>',
        '			</dl>',
        '			<dl>',
        '				<dt>@table.title.col</dt>',
        '				<dd><span class="g_select"><input type="text" name="detail_col" class="txt txt_sel" /><button name="btn_detail_col_up" class="bg btn btn_up_arrow">+</button><button name="btn_detail_col_down" class="bg btn btn_down_arrow">-</button></span></dd>',
        '			</dl>',
        '			<table name="table_detail_preview"></table>',
        '		</div>',
        '		<dl>',
        '			<dt class="tit"><label><input type="radio" name="rdo_table_style" class="rdo" value="custom" checked /> <strong style="cursor:pointer;">@table.detail.menual</strong></label></dt>',
        '			<dd class="clear depth2">',
        '				<dl>',
        '					<dt>@table.detail.border_style</dt>',
        '					<dd class="g_line_dd">',
        '						<span class="g_line"><span class="line_style line1"></span><button name="btn_border_style" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') + '</button></span>',
        '						<ul class="line_style_option" style="display:none;">',
        '							#{for:line}<li class="#{class}" data-style="#{style}"><a href="javascript:;"></a></li>#{/for:line}',
        '						</ul>',
        '					</dd>',
        '				</dl>',
        '				<dl>',
        '					<dt>@table.detail.border_line</dt>',
        '					<dd><span class="g_select"><input type="text" name="txt_border_line" class="txt txt_sel" /><button name="btn_line_up" class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제') + '</button></span></dd>',
        '				</dl>',
        '				<dl>',
        '					<dt>@table.detail.border_color</dt>',
        '					<dd><input type="text" name="txt_border_color" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '						<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '					</dd>',
        '				</dl>',
        '				<dl>',
        '					<dt>@table.detail.cell_bg</dt>',
        '					<dd><input type="text" name="txt_cell_bg" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '						<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '					</dd>',
        '				</dl>',
        '			</dd>',
        '		</dl>',
        '		<dl class="table_style">',
        '			<dt class="tit"><label><input type="radio" name="rdo_table_style" class="rdo" value="style" /> <strong class="s_disabled" style="cursor:pointer;">@table.detail.style</strong></label></dt>',
        '			<dd>',
        '				<span class="g_style"><span class="td_style"></span><button name="btn_table_style" class="bg btn btn_down_arrow2">' + Trex._I18N.g('btn_down_arrow2', '펼치기') + '</button></span>',
        '				<ul class="td_style_option" style="display:none;">',
        '					#{for:items}<li><span class="td_style #{text}" data-style="#{style}">#{text}</span></li>#{/for:items}',
        '				</ul>',
        '			</dd>',
        '		</dl>',
        '		<div class="custom_block"></div>',
        '		<div class="style_block"></div>',
        '	</div>',
        '	<div class="layer_bottom">',
        '		<button name="btn_detail_ok" class="btn btn_ok">@table.detail.ok</button>',
        '		<button name="btn_detail_cancel" class="btn btn_cancel">@table.detail.cancel</button>',
        '	<div>'
    ].join("")
);
/* Trex.Menu.Table ************************************************************************************/
//표 클릭시 생성해준다
Trex.Menu.Table = Trex.Class.create({
    $const: {
        MAX_ROW: 30,
        MAX_COL: 30,
        MAX_LINE_WIDTH: 5,
        DEFAULT_ROW: 4,
        DEFAULT_COL: 4,
        BORDER_LINE: 1,
        TABLE_STYLE: 7,
        MAX_PADDING: 20
    },
    $extend: Trex.Menu,
    ongenerated: function() {
        this.rowSize = Trex.Menu.Table.DEFAULT_ROW;
        this.colSize = Trex.Menu.Table.DEFAULT_COL;
        this.lineWidth = Trex.Menu.Table.BORDER_LINE;
        this.lineStyle = _NULL;
        this.lineColor = _NULL;
        this.cellColor = _NULL;
        this.tableStyle = Trex.Menu.Table.TABLE_STYLE;


        this.canvas = this.tool.canvas;
        this.cellPallete = _NULL;
        this.linePallete = _NULL;

        this.elInnerPreview = $tom.collect(this.elMenu, 'div.tx-menu-inner .tx-menu-preview');
        this.dynamicSizer = this.generateDynamicSizer(this.elInnerPreview);

        //this.elInnerRowCol = $tom.collect(this.elMenu, 'div.tx-menu-inner .tx-menu-rowcol');
        //this.generateTextSizer(this.elInnerRowCol);

        //this.elButtonArea = $tom.collect(this.elMenu, 'div.tx-menu-inner .tx-menu-enter');
        //this.generateButtonArea(this.elButtonArea);

        //표 직접설정 기능 변경
        this.elTableDetail = $tom.collect(this.elPopupMenu, '.table_detail');
        this.generateDetailSizer();
    },
    onregenerated: function() {
        this.showDynamicSizer();
    },
    showPopup: function(top, left) {
        //BlockUI 처리
        $tx.show(this.canvas.elEditorBlockUI);

        var $container = $(this.canvas.elContainer),
            $popup = $(this.elTableDetail);

        if (isNaN(top) || isNaN(left)) {
            //팝업창 Canvas영역 중앙에 표시
            var canvas_w = $container.outerWidth(),
                canvas_h = $container.outerHeight(),
                popup_w = $popup.outerWidth(),
                popup_h = $popup.outerHeight();

            top = (Math.ceil(canvas_h / 2) - Math.ceil(popup_h / 2)) + $container.position().top;
            left = (Math.ceil(canvas_w / 2) - Math.ceil(popup_w / 2)) + $container.position().left;

        }

        $popup.css({ 'top': top, 'left': left });


        //팝업 오픈 처리
        $tx.show($popup.get(0));
    },
    hidePopup: function() {
        this.onCancel();
        $tx.hide(this.canvas.elEditorBlockUI);
        $tx.hide(this.elTableDetail);
    },
    showDynamicSizer: function() {
        this.dynamicSizer.clear();
        $tx.show(this.elInnerPreview);
        //$tx.hide( this.elInnerRowCol );
        //$tx.hide( this.elButtonArea );
        //$tx.show(this.elInnerMenu);
    },
    showTextSizer: function() {
        //$tx.hide(this.elInnerPreview);
        //$tx.show(this.elInnerRowCol);
        //$tx.show(this.elButtonArea);
        var top = $(this.elMenu).closest('li').position().top + $(this.elMenu).position().top;
        var left = $(this.elMenu).closest('li').position().left;
        var $popup = $(this.elTableDetail);
        var $container = $(this.canvas.elContainer);
        if (left + $popup.outerWidth() > $container.position().left + $container.outerWidth()) {
            left += ($container.position().left + $container.outerWidth()) - (left + $popup.outerWidth() + 10);
        }
        this.showPopup(top, left);
    },
    generateDynamicSizer: function(elPreivewContext) {
        var _self = this;
        var elRowCol = tx.span();
        var elDisplay = tx.div({ className: "tx-dynamic-sizer-display" }, TXMSG('@table.title.insert'), elRowCol);
        elPreivewContext.appendChild(elDisplay);

        var dynamicSizer = new Trex.DynamicSizer({
            el: elPreivewContext,
            clickHandler: this.onSelect.bind(this),
            moveHandler: function(row, col) {
                elRowCol.innerHTML = row + 'x' + col;
            }
        });

        var _elA = tx.a({ href: "javascript:;" }, TXMSG('@table.title.setDirectly'));
        $tx.observe(_elA, "click", function(ev) {
            _self.showTextSizer();
            $tx.stop(ev);
            _self.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, {
                detail: {
                    menu: _self
                }
            });
        });

        var _elButton = tx.div({ className: Trex._I18N.g('tx-more-button', "tx-more-button") });
        _elButton.appendChild(_elA);
        elPreivewContext.appendChild(_elButton);

        return dynamicSizer;
    },
    //표 상세설정 기능 추가(체크)
    generateDetailSizer: function() {
        var tableStyle = { items: [], line: [] };
        for (var i = 1; i <= 45; i++) {
            tableStyle.items.push({ "text": 'style' + i, "style": i });
        }
        var lineStyle = [
            { "class": 'line1', "style": 'solid' },
            { "class": 'line2', "style": 'dotted' },
            { "class": 'line3', "style": 'double' }
            //{class:'line4', style:'inset'}.
            //{class:'line5', style:'outset'}
        ];
        tableStyle.line = lineStyle;
        Trex.MarkupTemplate.get('menu.table.detail').evaluateToDom(tableStyle, this.elTableDetail);

        this.initDetailSetting();
    },
    initDetailSetting: function() {
        var _self = this;
        var $elContext = $(this.elTableDetail);
        //element Setting
        var txt_row = $elContext.find('input[name=detail_row]'),
            txt_col = $elContext.find('input[name=detail_col]'),
            txt_cell_bg = $elContext.find('input[name=txt_cell_bg]'),
            txt_border_line = $elContext.find('input[name=txt_border_line]'),
            txt_border_color = $elContext.find('input[name=txt_border_color]'),
            btn_row_up = $elContext.find('button[name=btn_detail_row_up]'),
            btn_row_dn = $elContext.find('button[name=btn_detail_row_down]'),
            btn_col_up = $elContext.find('button[name=btn_detail_col_up]'),
            btn_col_dn = $elContext.find('button[name=btn_detail_col_down]'),
            btn_line_up = $elContext.find('button[name=btn_line_up]'),
            btn_line_dn = $elContext.find('button[name=btn_line_down]'),
            btn_ok = $elContext.find('button[name=btn_detail_ok]'),
            btn_cancel = $elContext.find('button[name=btn_detail_cancel]'),
            btn_cell_bg = $(txt_cell_bg).next(),
            btn_line_color = $(txt_border_color).next(),
            rdo_table_style = $elContext.find('input[type=radio]'),
            span_cell_bg = $(btn_cell_bg).find('span'),
            span_line_color = $(btn_line_color).find('span'),
            cell_bg_pal = $(btn_cell_bg).next(),
            line_color_pal = $(btn_line_color).next(),
            table_preview = $elContext.find('table:eq(0)'),
            btn_border_style = $elContext.find('button[name=btn_border_style]'),
            border_list = $(btn_border_style).closest('dd').find('ul:eq(0)'),
            btn_table_style = $elContext.find('button[name=btn_table_style]'),
            style_list = $(btn_table_style).closest('dd').find('ul:eq(0)');


        //기본값 설정
        var defaultSetting = function() {
            txt_row.val(Trex.Menu.Table.DEFAULT_ROW);
            txt_col.val(Trex.Menu.Table.DEFAULT_COL);

            for (var tr = 1; tr <= Trex.Menu.Table.DEFAULT_ROW; tr++) {
                var insertTr = $('<tr></tr>');
                for (var td = 1; td <= Trex.Menu.Table.DEFAULT_COL; td++) {
                    insertTr.append('<td></td>');
                }
                table_preview.append(insertTr);
            }

            //셀 배경색 및 기타설정
            var cell_bg = _self.config.bgcolor,
                border_line = parseInt(_self.config.borderStyle.split(' ')[0]),
                border_color = _self.config.borderStyle.split(' ')[2];

            _self.cellColor = cell_bg;
            _self.lineWidth = border_line;
            _self.lineColor = border_color;
            _self.lineStyle = 'solid';

            txt_cell_bg.val(cell_bg);
            txt_cell_bg.closest('dd').find('span').css('background', cell_bg);
            txt_border_line.val(border_line);
            txt_border_color.val(border_color);
            txt_border_color.closest('dd').find('span').css('background', border_color);

            //테이블 스타일
            btn_table_style.closest('span').find('.td_style').addClass('style' + Trex.Menu.Table.TABLE_STYLE);
        };

        //Validation Check
        var validCheck = {
            calculate: function(type, operand) {
                var value = (type == 'row' ? _self.rowSize : type == 'col' ? _self.colSize : _self.lineWidth);
                var max = (type == 'row' ? Trex.Menu.Table.MAX_ROW : type == 'col' ? Trex.Menu.Table.MAX_COL : Trex.Menu.Table.MAX_LINE_WIDTH);
                value = parseInt(value);
                if (value + operand > max || value + operand < 1) {
                    if (type != 'line') alert(TXMSG("@table.alert"));
                    return value;
                }

                //미리보기 테이블 처리
                if (type != 'line') {
                    if (operand > 0) {
                        if (type == 'row') {
                            table_preview.append(table_preview.find('tr:eq(0)').clone());
                        } else {
                            table_preview.find('tr').append('<td></td>');
                        }
                    } else {
                        if (type == 'row') {
                            table_preview.find('tr:eq(0)').remove();
                        } else {
                            table_preview.find('tr').find('td:eq(0)').remove();
                        }
                    }
                }

                return value + operand;
            },
            getValidValue: function(type, value, previousValue, obj) {
                var max = (type == 'row' ? Trex.Menu.Table.MAX_ROW : type == 'col' ? Trex.Menu.Table.MAX_COL : Trex.Menu.Table.MAX_LINE_WIDTH);
                if (isNaN(value)) return previousValue;
                if (value <= 0 || value > max) {
                    value = value <= 0 ? previousValue : max;
                    if (obj) obj.value = value;
                    alert(Trex._I18N.g('number.alert', '1', max.toString(), '1 이상 ' + max + ' 이하의 숫자만 입력 가능합니다.'));
                }

                if (type != 'line') {
                    table_preview.empty();
                    var row_size = (type == 'row' ? value : _self.rowSize);
                    var col_size = (type == 'row' ? _self.colSize : value);
                    for (var tr = 1; tr <= row_size; tr++) {
                        var insertTr = $('<tr></tr>');
                        for (var td = 1; td <= col_size; td++) {
                            insertTr.append('<td></td>');
                        }
                        table_preview.append(insertTr);
                    }
                }
                return value;
            },
            validColor: function(type, color, previousValue) {
                var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
                if (m === _NULL || color.length > 8) {
                    return previousValue;
                }
                if (m[1].length == 3) {
                    //return "#" + m[1] + m[1];
                    return "#" + m[1].toLowerCase();
                } else {
                    return "#" + m[1].toLowerCase();
                }
            }
        };

        var hideSubPopup = function() {
            border_list.hide();
            style_list.hide();
            if (_self.cellPallete) _self.cellPallete.hide();
            if (_self.linePallete) _self.linePallete.hide();
        }

        var bindEvents = function() {
            txt_row.on('blur', function(ev) {
                this.value = _self.rowSize = validCheck.getValidValue('row', this.value, _self.rowSize, this);
            });
            txt_row.on('keyup', function(ev) {
                if (this.value != '') this.value = _self.rowSize = validCheck.getValidValue('row', this.value, _self.rowSize, this);
            })
            txt_col.on('blur', function() {
                this.value = _self.colSize = validCheck.getValidValue('col', this.value, _self.colSize, this);
            });
            txt_col.on('keyup', function() {
                if (this.value != '') this.value = _self.colSize = validCheck.getValidValue('col', this.value, _self.colSize, this);
            })
            txt_border_line.on('blur', function() {
                this.value = _self.lineWidth = validCheck.getValidValue('line', this.value, _self.lineWidth, this);
            });
            txt_border_line.on('keyup', function() {
                if (this.value != '') this.value = _self.lineWidth = validCheck.getValidValue('line', this.value, _self.lineWidth, this);
            });
            txt_cell_bg.on('blur', function() {
                this.value = _self.cellColor = validCheck.validColor('cell', this.value, _self.cellColor);
                span_cell_bg.css('background', this.value);
            });
            txt_border_color.on('blur', function() {
                this.value = _self.lineColor = validCheck.validColor('line', this.value, _self.lineColor);
                span_line_color.css('background', this.value);
            });
            btn_row_up.on('click', function() {
                txt_row.get(0).value = _self.rowSize = validCheck.calculate('row', 1);
            });
            btn_row_dn.on('click', function() {
                txt_row.get(0).value = _self.rowSize = validCheck.calculate('row', -1);
            });
            btn_col_up.on('click', function() {
                txt_col.get(0).value = _self.colSize = validCheck.calculate('col', 1);
            });
            btn_col_dn.on('click', function() {
                txt_col.get(0).value = _self.colSize = validCheck.calculate('col', -1);
            });
            btn_line_up.on('click', function() {
                txt_border_line.get(0).value = _self.lineWidth = validCheck.calculate('line', 1);
            });
            btn_line_dn.on('click', function() {
                txt_border_line.get(0).value = _self.lineWidth = validCheck.calculate('line', -1);
            });
            btn_ok.on('click', function(e) {
                //var data = ['rowSize', 'colSize', 'cellColor', 'lineStyle', 'lineWidth', 'lineColor', 'tableStyle'];
                //$.each(data, function(idx, val){console.log(val, _self[val]);});
                _self.onSelect(e, {
                    type: $elContext.find('input[type=radio]:checked').val(),
                    row: _self.rowSize,
                    col: _self.colSize,
                    cellColor: _self.cellColor,
                    lineStyle: _self.lineStyle,
                    lineWidth: _self.lineWidth,
                    lineColor: _self.lineColor,
                    tableStyle: _self.tableStyle
                });
                hideSubPopup();
                _self.hidePopup();
            });
            btn_cancel.on('click', function() {
                hideSubPopup();
                _self.hidePopup();
            });

            rdo_table_style.on('click', function() {
                if (this.value == 'custom') {
                    $(this).next().removeClass('s_disabled');
                    rdo_table_style.eq(1).next().addClass('s_disabled');
                    $elContext.find('.custom_block').hide();
                    $elContext.find('.style_block').show();
                } else {
                    $(this).next().removeClass('s_disabled');
                    rdo_table_style.eq(0).next().addClass('s_disabled');
                    $elContext.find('.custom_block').show();
                    $elContext.find('.style_block').hide();
                }
                hideSubPopup();
            });

            //테두리 스타일
            btn_border_style.on('click', function() {
                if (_self.cellPallete) _self.cellPallete.hide();
                if (_self.linePallete) _self.linePallete.hide();
                if ($(this).hasClass('btn_down_arrow1')) {
                    $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                    if ($tx.ltie8 && $(border_list).data('ltie8') != 'true') {
                        $(border_list).data('dd', $(this).closest('dd'));
                        $('.cell_prop', $elContext).append(border_list);
                        border_list.css('top', '128px');
                        border_list.css('right', '10px');
                        $(border_list).data('ltie8', 'true');
                    }
                    $tx.show(border_list.get(0));
                } else {
                    $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                    $tx.hide(border_list.get(0));
                }
                return false;
            });
            btn_border_style.closest('span').on('click', function() {
                btn_border_style.click();
            });
            border_list.find('li').on('click', function(el) {
                var span = null;
                if ($tx.ltie8) {
                    span = $(this).closest('ul').data('dd').find('.g_line:eq(0)');
                } else {
                    span = $(this).closest('dd').find('.g_line:eq(0)');
                }
                var cls = $(this).attr('class');
                var style = $(this).data('style');

                if (!span.find('.line_style').hasClass(cls)) {
                    span.find('.line_style').remove();
                    span.prepend('<span class="line_style ' + cls + '"></span>');
                }
                _self.lineStyle = style;
                btn_border_style.click();
                el.preventDefault();
            });

            //셀 배경색
            btn_cell_bg.on('click', function() {
                if (_self.cellPallete == _NULL) {
                    if ($tx.ltie8) {
                        $('.cell_prop', $elContext).append(cell_bg_pal);
                        $(cell_bg_pal).css('top', '200px');
                        $(cell_bg_pal).css('right', '10px');
                    }
                    _self.cellPallete = _self.createColorPallete(cell_bg_pal.get(0), function(color) {
                        color = color.toLowerCase();
                        _self.cellColor = color;
                        txt_cell_bg.val(color);
                        span_cell_bg.css('background', color);
                    }, false);
                }
                $tx.hide(border_list.get(0));
                if (_self.linePallete) _self.linePallete.hide();
                _self.cellPallete.toggle();
                _self.cellPallete.remainColor(txt_cell_bg.val());
                return false;
            });

            //테두리 색
            btn_line_color.on('click', function() {
                if (_self.linePallete == _NULL) {
                    if ($tx.ltie8) {
                        $('.cell_prop', $elContext).append(line_color_pal);
                        $(line_color_pal).css('top', '175px');
                        $(line_color_pal).css('right', '10px');
                    }
                    _self.linePallete = _self.createColorPallete(line_color_pal.get(0), function(color) {
                        color = color.toLowerCase();
                        _self.lineColor = color;
                        txt_border_color.val(color);
                        span_line_color.css('background', color);
                    }, false);
                }
                $tx.hide(border_list.get(0));
                if (_self.cellPallete) _self.cellPallete.hide();
                _self.linePallete.toggle();
                _self.linePallete.remainColor(txt_border_color.val());
                return false;
            });

            //테이블 스타일
            btn_table_style.on('click', function() {
                if ($(this).hasClass('btn_down_arrow2')) {
                    $(this).removeClass('btn_down_arrow2').addClass('btn_up_arrow2');
                    if ($tx.ltie8 && $(style_list).data('ltie8') != 'true') {
                        $(style_list).data('dd', $(this).closest('dd'));
                        $('.cell_prop', $elContext).append(style_list);
                        style_list.css('bottom', '50px');
                        //style_list.css('right', '10px');
                        $(style_list).data('ltie8', 'true');
                    }
                    style_list.show();
                } else {
                    $(this).removeClass('btn_up_arrow2').addClass('btn_down_arrow2');
                    style_list.hide();
                }
                return false;
            });
            btn_table_style.closest('span').on('click', function() {
                btn_table_style.click();
            });
            style_list.find('span').on('click', function() {
                var span = null;
                if ($tx.ltie8) {
                    span = $(this).closest('ul').data('dd').find('.g_style:eq(0)');
                } else {
                    span = $(this).closest('dd').find('.g_style:eq(0)');
                }
                var cls = $(this).text();
                var style = $(this).data('style');
                if (!span.find('.td_style').hasClass(cls)) {
                    span.find('.td_style').remove();
                    span.prepend('<span class="td_style ' + cls + '"></span>');
                }
                _self.tableStyle = style;
                btn_table_style.click();
            });

        };

        defaultSetting();

        bindEvents();
    },
    createColorPallete: function(element, fn, inputHidden, elInput, elPreview) {
        var self = this;
        var pallete = new Trex.Menu.ColorPallete({
            el: element,
            thumbs: Trex.__CONFIG_COMMON.thumbs,
            colorInputHidden: inputHidden
        });
        pallete.setCommand(fn);
        return pallete;
    },
    generateTextSizer: function(elContext) {
        var _self = this;

        Trex.MarkupTemplate.get('menu.table.direct').evaluateToDom({}, elContext);

        var calculator = {
            calculate: function(value, max, operand) {
                value = parseInt(value);
                if (value + operand > max || value + operand < 1) {
                    alert(TXMSG("@table.alert"));
                    return value;
                } else {
                    return value + operand;
                }
            },
            getValidValue: function(value, previousValue, max) {
                if (value <= 0 || value > max) {
                    alert(TXMSG("@table.alert"));
                    return previousValue;
                } else {
                    return value;
                }

            }
        };

        var colInput = $tom.collect(elContext, "div.tx-col-field input");
        $tx.observe(colInput, "blur", function() {
            colInput.value = _self.colSize = calculator.getValidValue(colInput.value, _self.colSize, Trex.Menu.Table.MAX_COL);
        });
        $tx.observe($tom.collect(elContext, "div.tx-col-field a.tx-btn-add"), "click", function(e) {
            colInput.value = _self.colSize = calculator.calculate(_self.colSize, Trex.Menu.Table.MAX_COL, 1);
            $tx.stop(e);
            return _FALSE;
        });
        $tx.observe($tom.collect(elContext, "div.tx-col-field a.tx-btn-sub"), "click", function(e) {
            colInput.value = _self.colSize = calculator.calculate(_self.colSize, Trex.Menu.Table.MAX_COL, -1);
            $tx.stop(e);
            return _FALSE;
        });

        var rowInput = $tom.collect(elContext, "div.tx-row-field input");
        $tx.observe(rowInput, "blur", function() {
            rowInput.value = _self.rowSize = calculator.getValidValue(rowInput.value, _self.rowSize, Trex.Menu.Table.MAX_ROW);
        });
        $tx.observe($tom.collect(elContext, "div.tx-row-field a.tx-btn-add"), "click", function(e) {
            rowInput.value = _self.rowSize = calculator.calculate(_self.rowSize, Trex.Menu.Table.MAX_ROW, 1);
            $tx.stop(e);
            return _FALSE;
        });
        $tx.observe($tom.collect(elContext, "div.tx-row-field a.tx-btn-sub"), "click", function(e) {
            rowInput.value = _self.rowSize = calculator.calculate(_self.rowSize, Trex.Menu.Table.MAX_ROW, -1);
            $tx.stop(e);
            return _FALSE;
        });
    },
    generateButtonArea: function(elContext) {
        var _self = this;
        var elDiv = tx.div();
        var elAConfirm = tx.a({ href: "javascript:;", className: Trex._I18N.g('tx-btn-confirm', "tx-btn-confirm") }, Trex._I18N.g('tx-btn-confirm_txt', "확인"));
        var elACancel = tx.a({ href: "javascript:;", className: Trex._I18N.g('tx-btn-cancel', "tx-btn-cancel") }, Trex._I18N.g('tx-btn-cancel_txt', "취소"));

        $tx.observe(elAConfirm, "click", function(ev) {
            _self.onSelect(ev, {
                row: _self.rowSize,
                col: _self.colSize
            });
        });

        $tx.observe(elACancel, "click", function(e) {
            $tx.stop(e);
            this.onCancel();
            return _FALSE;
        }.bindAsEventListener(this));

        elDiv.appendChild(elAConfirm);
        elDiv.appendChild(elACancel);
        elContext.appendChild(elDiv);
    }
});

(function() {
    TrexMessage.addMsg({
        '@emoticon.subtitle.person': Trex._I18N.g('emoticon.subtitle.person', '사람'),
        '@emoticon.subtitle.animal': Trex._I18N.g('emoticon.subtitle.animal', '동식물'),
        '@emoticon.subtitle.thing': Trex._I18N.g('emoticon.subtitle.thing', '사물'),
        '@emoticon.subtitle.etc': Trex._I18N.g('emoticon.subtitle.etc', '기타')
    });

    var createEmoticonURLs = function(category, maxNum) {
        var urls = [];
        for (var i = 1; i <= maxNum; i++) {
            urls.push('#decopath/emoticon/' + category + '_' + addZeroPadding(i) + '.gif?open&v=2');
        }
        return urls;
    };

    var addZeroPadding = function(number) {
        return (number < 10) ? '0' + number : String(number);
    };

    TrexConfig.addTool("emoticon", {
            sync: _FALSE,
            status: _TRUE,
            rows: 5,
            cols: 7,
            matrices: [{
                    title: TXMSG("@emoticon.subtitle.person"),
                    klass: "tx-menu-matrix-per",
                    options: createEmoticonURLs("per", 29)
                },
                {
                    title: TXMSG("@emoticon.subtitle.animal"),
                    klass: "tx-menu-matrix-ani",
                    options: createEmoticonURLs("ani", 28)
                },
                {
                    title: TXMSG("@emoticon.subtitle.thing"),
                    klass: "tx-menu-matrix-things",
                    options: createEmoticonURLs("things", 35),
                    defaultshow: _TRUE
                },
                {
                    title: TXMSG("@emoticon.subtitle.etc"),
                    klass: "tx-menu-matrix-etc",
                    options: createEmoticonURLs("etc", 29)
                }
            ],
            asyncUrl: "trex/tool/async/emoticon" + (Trex._JS_MIN ? '.min' : '') + ".js"
        },
        function(root) {
            var emoticonConfig = TrexConfig.getTool("emoticon", root);
            emoticonConfig.matrices.each(function(matrix) {
                for (var i = 0, len = matrix.options.length; i < len; i++) {
                    matrix.options[i] = TrexConfig.getDecoPath(matrix.options[i]);
                }
            });
        }
    );

    Trex.Tool.Emoticon = Trex.Class.create({
        $const: {
            __Identity: 'emoticon'
        },
        $extend: Trex.AsyncTool,
        oninitialized: function() {
            this.weave.bind(this)(
                new Trex.Button(this.buttonCfg),
                _NULL,
                this.onLoadModule // define in Trex.AsyncTool
            );
        }
    });

})();

/**
 * @fileoverview
 * Tool 'Redo' Source,
 * Class Trex.Tool.ReDo 와 configuration을 포함
 *
 */
TrexConfig.addTool(
    "redo", {
        sync: _FALSE,
        status: _FALSE
    }
);

Trex.Tool.ReDo = Trex.Class.create({
    $const: {
        __Identity: 'redo'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _canvas = this.canvas;

        var _toolHandler = function() {
            _canvas.getProcessor().blur();
            // _canvas.focus();  // Caret이 최 상단으로 올라가는 문제 있음.

            setTimeout(function() {
                _canvas.fireJobs('canvas.panel.redo');
            }, 0);
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            _NULL,
            /* handler */
            _toolHandler
        );

        this.bindKeyboard({ // ctrl + y - 다시실행
            ctrlKey: _TRUE,
            keyCode: 89
        }, function() {
            _canvas.fireJobs('canvas.panel.redo');
            _canvas.triggerQueryStatus();
        });
    }

});

/**
 * @fileoverview
 *  Tool 'UnDo' Source,
 *  Class Trex.Tool.UnDo 와  configuration 을 포함 하고있다.
 *
 */
TrexConfig.addTool(
    "undo", {
        sync: _FALSE,
        status: _FALSE
    }
);

Trex.Tool.UnDo = Trex.Class.create({
    $const: {
        __Identity: 'undo'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _canvas = this.canvas;

        var _toolHandler = function() {
            _canvas.getProcessor().blur();
            //_canvas.focus(); // Caret이 최 상단으로 올라가는 문제 있음.

            setTimeout(function() {
                _canvas.fireJobs('canvas.panel.undo');
            }, 20);
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            _NULL,
            /* handler */
            _toolHandler
        );

        this.bindKeyboard({ // ctrl + z - 실행취소
            ctrlKey: _TRUE,
            keyCode: 90
        }, function() {
            _canvas.fireJobs('canvas.panel.undo');
            _canvas.triggerQueryStatus();
        });
    }

});
/**
 * @fileoverview
 *
 */
TrexConfig.addTool(
    "removeformat", {
        wysiwygonly: _TRUE,
        sync: _TRUE,
        status: _FALSE,
        hotKey: { // ctrl + shift + x
            ctrlKey: _TRUE,
            shiftKey: _TRUE,
            keyCode: 88
        }
    }
);

Trex.I.FontToolForRemoveformat = Trex.Mixin.create({
    oninitialized: function(config) {
        this.bindKeyboard(config.hotKey, this.handler.bind(this));
    },
    computeNewStyle: function() {
        return _NULL;
    },
    rangeExecutor: function(processor) {
        processor.execCommand(this.getQueryCommandName());
    }
});

Trex.Tool.Removeformat = Trex.Class.create({
    $const: {
        __Identity: 'removeformat'
    },
    $extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.FontToolForRemoveformat],
    getQueryCommandName: function() {
        return "removeformat";
    },
    isStyleApplied: function(node) {
        return false;
    }
});

Trex.module('initialize removeformat without toolbar button', function(editor, toolbar, sidebar, canvas /*, config*/ ) {
    if (!$tx('tx_removeformat')) {
        var cfg = TrexConfig.getTool('removeformat');
        var el = _DOC.createElement('div');
        el.id = 'tx_removeformat';
        _DOC.body.appendChild(el);
        new Trex.Tool.Removeformat(editor, toolbar, cfg);
    }
});

/**
 * @fileoverview
 * 여러 스타일의 구분선을 삽입할 때 쓰이는 menu를 포함하는 Tool인 '구분선' Icon Source,
 * Class Trex.Tool.HorizontalRule과 configuration을 포함
 *
 */
TrexConfig.addTool(
    "horizontalrule", {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        top: _NULL,
        left: _NULL,
        options: [{
                data: 'tx-hr-border-1',
                image: '#iconpath/horizontalrule/line01.gif?open&v=2',
                html: '<hr style="display:block; border: black 0 none; border-top: black 1px solid; height: 1px"/>'
            },
            {
                data: 'tx-hr-border-2',
                image: '#iconpath/horizontalrule/line02.gif?open&v=2',
                html: '<hr style="display:block; border: black 0 none; border-top: black 1px solid; border-bottom: black 3px solid; height: 7px"/>'
            },
            {
                data: 'tx-hr-border-3',
                image: '#iconpath/horizontalrule/line04.gif?open&v=2',
                html: '<hr style="display:block; border: black 0 none; border-top: black 1px dotted; height: 1px"/>'
            }
            /*,
            		{	data: 'tx-hr-image-1',
            			image: '#iconpath/horizontalrule/line03.gif?open&v=2',
            			html: '<div style="background: url(#decopath/horizontalrule/line03.gif?open&v=2) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
            		},
            		{	data: 'tx-hr-image-2',
            			image: '#iconpath/horizontalrule/line05.gif?open&v=2',
            			html: '<div style="background: url(#decopath/horizontalrule/line05.gif?open&v=2) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
            		},
            		{	data: 'tx-hr-image-3',
            			image: '#iconpath/horizontalrule/line06.gif?open&v=2',
            			html: '<div style="background: url(#decopath/horizontalrule/line06.gif?open&v=2) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
            		},
            		{	data: 'tx-hr-image-4',
            			image: '#iconpath/horizontalrule/line07.gif?open&v=2',
            			html: '<div style="background: url(#decopath/horizontalrule/line08.gif?open&v=2) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
            		}*/
        ]
    },
    function(root) {
        var _config = TrexConfig.getTool("horizontalrule", root);
        _config.options.each(function(option) {
            option.image = TrexConfig.getIconPath(option.image);
            if (option.html) {
                option.html = TrexConfig.getDecoPath(option.html);
            }
        });
    }
);

Trex.Tool.HorizontalRule = Trex.Class.create({
    $const: {
        __Identity: 'horizontalrule'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;

        var map = {};
        config.options.each(function(option) {
            map[option.data] = {
                html: option.html
            };
        });

        var _toolHandler = function(data) {
            if (!map[data]) {
                return;
            }
            var _item = map[data];
            if (_canvas.isWYSIWYG()) {
                _canvas.execute(function(processor) {
                    // hr 태그는 p 태그 하위에 포함 될 수 없으므로 newline으로 내용을 추가 한 뒤에 래핑된 p태그를 제거한다.
                    var pastedNode = processor.pasteContent(_item.html, _TRUE);
                    if ($tom.isTagName(pastedNode.parentNode, 'p')) {
                        $tom.unwrap(pastedNode.parentNode);
                    }
                });
            } else {
                _canvas.execute(function(processor) {
                    processor.insertTag('', _item.html);
                });
            }
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            new Trex.Menu.List(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }

});

/**
 * @fileoverview
 *  Tool '특수문자' Source,
 * Class Trex.Tool.SpecialChar 와 configuration을 포함
 *
 */
(function() {
    TrexMessage.addMsg({
        '@specialchar.subtitle1': Trex._I18N.g('specialchar.subtitle1', '일반기호'),
        '@specialchar.subtitle2': Trex._I18N.g('specialchar.subtitle2', '수학부호, 통화단위'),
        '@specialchar.subtitle3': Trex._I18N.g('specialchar.subtitle3', '원 기호, 괄호'),
        '@specialchar.subtitle4': Trex._I18N.g('specialchar.subtitle4', '일본어'),
        '@specialchar.subtitle5': Trex._I18N.g('specialchar.subtitle5', '로마자, 그리스')
    });

    TrexConfig.addTool(
        "specialchar", {
            sync: _FALSE,
            status: _TRUE,
            rows: 9,
            cols: 20,
            top: _NULL,
            // left: _NULL,
            left: -312,
            matrices: [{
                title: TXMSG('@specialchar.subtitle1'),
                options: ['\uff03', '\uff06', '\uff0a', '\uff20', '\xa7', '\u203b', '\u2606', '\u2605', '\u25cb', '\u25cf', '\u25ce', '\u25c7', '\u25c6', '\u25a1', '\u25a0', '\u25b3', '\u25b2', '\u25bd', '\u25bc', '\u2192', '\u2190', '\u2191', '\u2193', '\u2194', '\u3013', '\u25c1', '\u25c0', '\u25b7', '\u25b6', '\u2664', '\u2660', '\u2661', '\u2665', '\u2667', '\u2663', '\u2299', '\u25c8', '\u25a3', '\u25d0', '\u25d1', '\u2592', '\u25a4', '\u25a5', '\u25a8', '\u25a7', '\u25a6', '\u25a9', '\u2668', '\u260f', '\u260e', '\u261c', '\u261e', '\xb6', '\u2020', '\u2021', '\u2195', '\u2197', '\u2199', '\u2196', '\u2198', '\u266d', '\u2669', '\u266a', '\u266c', '\u327f', '\u321c', '\u2116', '\u33c7', '\u2122', '\u33c2', '\u33d8', '\u2121', '\xae', '\xaa', '\xba', '\uff02', '\uff08', '\uff09', '\uff3b', '\uff3d', '\uff5b', '\uff5d', '\u2018', '\u2019', '\u201c', '\u201d', '\u3014', '\u3015', '\u3008', '\u3009', '\u300a', '\u300b', '\u300c', '\u300d', '\u300e', '\u300f', '\u3010', '\u3011', '\uff01', '\uff07', '\uff0c', '\uff0e', '\uff0f', '\uff1a', '\uff1b', '\uff1f', '\uff3e', '\uff3f', '\uff40', '\uff5c', '\uffe3', '\u3001', '\u3002', '\xb7', '\u2025', '\u2026', '\xa8', '\u3003', '\u2015', '\u2225', '\uff3c', '\u223c', '\xb4', '\uff5e', '\u02c7', '\u02d8', '\u02dd', '\u02da', '\u02d9', '\xb8', '\u02db', '\xa1', '\xbf', '\u02d0']
            }, {
                title: TXMSG('@specialchar.subtitle2'),
                options: ['\uff0b', '\uff0d', '\uff1c', '\uff1d', '\uff1e', '\xb1', '\xd7', '\xf7', '\u2260', '\u2264', '\u2265', '\u221e', '\u2234', '\u2642', '\u2640', '\u2220', '\u22a5', '\u2312', '\u2202', '\u2207', '\u2261', '\u2252', '\u226a', '\u226b', '\u221a', '\u223d', '\u221d', '\u2235', '\u222b', '\u222c', '\u2208', '\u220b', '\u2286', '\u2287', '\u2282', '\u2283', '\u222a', '\u2229', '\u2227', '\u2228', '\uffe2', '\u21d2', '\u21d4', '\u2200', '\u2203', '\u222e', '\u2211', '\u220f', '\uff04', '\uff05', '\uffe6', '\uff26', '\u2032', '\u2033', '\u2103', '\u212b', '\uffe0', '\uffe1', '\uffe5', '\xa4', '\u2109', '\u2030', '?', '\u3395', '\u3396', '\u3397', '\u2113', '\u3398', '\u33c4', '\u33a3', '\u33a4', '\u33a5', '\u33a5', '\u33a6', '\u3399', '\u339a', '\u339b', '\u339c', '\u339d', '\u339e', '\u339f', '\u33a0', '\u33a1', '\u33a2', '\u33ca', '\u338d', '\u338e', '\u338f', '\u33cf', '\u3388', '\u3389', '\u33c8', '\u33a7', '\u33a8', '\u33b0', '\u33b1', '\u33b2', '\u33b3', '\u33b4', '\u33b5', '\u33b6', '\u33b7', '\u33b8', '\u33b9', '\u3380', '\u3381', '\u3382', '\u3383', '\u3384', '\u33ba', '\u33bb', '\u33bc', '\u33bd', '\u33be', '\u33bf', '\u3390', '\u3391', '\u3392', '\u3393', '\u3394', '\u2126', '\u33c0', '\u33c1', '\u338a', '\u338b', '\u338c', '\u33d6', '\u33c5', '\u33ad', '\u33ae', '\u33af', '\u33db', '\u33a9', '\u33aa', '\u33ab', '\u33ac', '\u33dd', '\u33d0', '\u33d3', '\u33c3', '\u33c9', '\u33dc', '\u33c6']
            }, {
                title: TXMSG('@specialchar.subtitle3'),
                options: [
                    '\u3260', '\u3261', '\u3262', '\u3263', '\u3264', '\u3265', '\u3266', '\u3267', '\u3268', '\u3269',
                    '\u326a', '\u326b', '\u326c', '\u326d', '\u326e', '\u326f', '\u3270', '\u3271', '\u3272', '\u3273',
                    '\u3274', '\u3275', '\u3276', '\u3277', '\u3278', '\u3279', '\u327a', '\u327b', '\u3200', '\u3201',
                    '\u3202', '\u3203', '\u3204', '\u3205', '\u3206', '\u3207', '\u3208', '\u3209', '\u320a', '\u320b',
                    '\u320c', '\u320d', '\u320e', '\u320f', '\u3210', '\u3211', '\u3212', '\u3213', '\u3214', '\u3215',
                    '\u3216', '\u3217', '\u3218', '\u3219', '\u321a', '\u321b', '\u24d0', '\u24d1', '\u24d2', '\u24d3',
                    '\u24d4', '\u24d5', '\u24d6', '\u24d7', '\u24d8', '\u24d9', '\u24da', '\u24db', '\u24dc', '\u24dd',
                    '\u24de', '\u24df', '\u24e0', '\u24e1', '\u24e2', '\u24e3', '\u24e4', '\u24e5', '\u24e6', '\u24e7', '\u24e8', '\u24e9', '\u2460', '\u2461', '\u2462', '\u2463', '\u2464', '\u2465', '\u2466', '\u2467', '\u2468', '\u2469', '\u246a', '\u246b', '\u246c', '\u246d', '\u246e', '\u249c', '\u249d', '\u249e', '\u249f', '\u24a0', '\u24a1', '\u24a2', '\u24a3', '\u24a4', '\u24a5', '\u24a6', '\u24a7', '\u24a8', '\u24a9', '\u24aa', '\u24ab', '\u24ac', '\u24ad', '\u24ae', '\u24af', '\u24b0', '\u24b1', '\u24b2', '\u24b3', '\u24b4', '\u24b5', '\u2474', '\u2475', '\u2476', '\u2477', '\u2478', '\u2479', '\u247a', '\u247b', '\u247c', '\u247d', '\u247e', '\u247f', '\u2480', '\u2481', '\u2482'
                ]
            // }, {
            //     title: TXMSG('@specialchar.subtitle4'),
            //     options: ['\u3041', '\u3042', '\u3043', '\u3044', '\u3045', '\u3046', '\u3047', '\u3048', '\u3049', '\u304a', '\u304b', '\u304c', '\u304d', '\u304e', '\u304f', '\u3050', '\u3051', '\u3049', '\u3053', '\u3054', '\u3055', '\u3056', '\u3057', '\u3058', '\u3059', '\u305a', '\u305b', '\u305c', '\u305d', '\u305e', '\u305f', '\u3060', '\u3061', '\u3062', '\u3063', '\u3064', '\u3065', '\u3066', '\u3067', '\u3068', '\u3069', '\u306a', '\u306b', '\u306c', '\u306d', '\u306e', '\u306f', '\u3070', '\u3071', '\u3072', '\u3073', '\u3074', '\u3075', '\u3076', '\u3077', '\u3078', '\u3079', '\u307a', '\u307b', '\u307c', '\u307d', '\u307e', '\u307f', '\u3080', '\u3081', '\u3082', '\u3083', '\u3084', '\u3085', '\u3086', '\u3087', '\u3088', '\u3089', '\u308a', '\u308b', '\u308c', '\u308d', '\u308e', '\u308f', '\u3090', '\u3091', '\u3092', '\u3093', '\u30a1', '\u30a2', '\u30a3', '\u30a4', '\u30a5', '\u30a6', '\u30a7', '\u30a8', '\u30a9', '\u30aa', '\u30ab', '\u30ac', '\u30ad', '\u30ae', '\u30af', '\u30b0', '\u30b1', '\u30b2', '\u30b3', '\u30b4', '\u30b5', '\u30b6', '\u30b7', '\u30b8', '\u30b9', '\u30ba', '\u30bb', '\u30bc', '\u30bd', '\u30be', '\u30bf', '\u30c0', '\u30c1', '\u30c2', '\u30c3', '\u30c4', '\u30c5', '\u30c6', '\u30c7', '\u30c8', '\u30c9', '\u30ca', '\u30cb', '\u30cc', '\u30cd', '\u30ce', '\u30cf', '\u30d0', '\u30d1', '\u30d2', '\u30d3', '\u30d4', '\u30d5', '\u30d6', '\u30d7', '\u30d8', '\u30d9', '\u30da', '\u30db', '\u30dc', '\u30dd', '\u30de', '\u30df', '\u30e0', '\u30e1', '\u30e2', '\u30e3', '\u30e4', '\u30e5', '\u30e6', '\u30e7', '\u30e8', '\u30e9', '\u30ea', '\u30eb', '\u30ec', '\u30ed', '\u30ee', '\u30ef', '\u30f0', '\u30f1', '\u30f2', '\u30f3', '\u30f4', '\u30f5', '\u30f6']
            }, {
                title: TXMSG('@specialchar.subtitle5'),
                options: ['\uff10', '\uff11', '\uff12', '\uff13', '\uff14', '\uff15', '\uff16', '\uff17', '\uff18', '\uff19', '\u2170', '\u2171', '\u2172', '\u2173', '\u2174', '\u2175', '\u2176', '\u2177', '\u2178', '\u2179', '\u2160', '\u2161', '\u2162', '\u2163', '\u2164', '\u2165', '\u2166', '\u2167', '\u2168', '\u2169', '\u0391', '\u0392', '\u0393', '\u0394', '\u0395', '\u0396', '\u0397', '\u0398', '\u0399', '\u039a', '\u039b', '\u039c', '\u039d', '\u039e', '\u039f', '\u03a0', '\u03a1', '\u03a3', '\u03a4', '\u03a5', '\u03a6', '\u03a7', '\u03a8', '\u03a9', '\u03b1', '\u03b2', '\u03b3', '\u03b4', '\u03b5', '\u03b6', '\u03b7', '\u03b8', '\u03b9\u03ba', '\u03bb', '\u03bc', '\u03bd', '\u03be', '\u03bf', '\u03c0', '\u03c1', '\u03c3', '\u03c4', '\u03c5', '\u03c6', '\u03c7', '\u03c8', '\u03c9']
            }],
            asyncUrl: "trex/tool/async/specialchar" + (Trex._JS_MIN ? '.min' : '') + ".js"
        }
    );

    Trex.Tool.SpecialChar = Trex.Class.create({
        $const: {
            __Identity: 'specialchar'
        },
        $extend: Trex.AsyncTool,
        oninitialized: function(config) {
            this.config = config;
            this.weave.bind(this)(
                new Trex.Button(this.buttonCfg),
                _NULL,
                this.onLoadModule // define in Trex.AsyncTool
            );
        }
    });
})();

/**
 * @fileoverview
 * 영어 사전 팝업을 띄워 주는 '사전' Icon을 위해 필요한 source, configuration과 Class Trex.Tool.Dictionary을/를 포함
 *
 */
TrexConfig.addTool(
    "dictionary", {
        url: 'http://engdic.daum.net/dicen/small_view_top.do',
        sync: _FALSE,
        status: _FALSE
    }
);

Trex.Tool.Dictionary = Trex.Class.create({
    $const: {
        __Identity: 'dictionary'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;

        var _toolHandler = function() {
            var _word = _canvas.query(function(processor) {
                return encodeURI(processor.getText());
            });
            var _popupUrl = (_word.length > 0) ? "http://engdic.daum.net/dicen/small_search.do" : config.url;
            var _dicWin = _WIN.open(_popupUrl + '?q=' + _word, 'dicWin', 'width=410,height=550,scrollbars=yes');
            _dicWin.focus();
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            _NULL,
            /* handler */
            _toolHandler
        );
    }
});

(function() {
    TrexConfig.addTool(
        "background", {
            wysiwygonly: _TRUE,
            sync: _FALSE,
            status: _TRUE,
            needRevert: true,
            thumbs: Trex.__CONFIG_COMMON.thumbs
        }
    );

    var articleBackgroundColor;

    Trex.Tool.Background = Trex.Class.create({
        $const: {
            __Identity: 'background'
        },
        $extend: Trex.Tool,
        oninitialized: function() {
            /* button & menu weave */
            this.weave(
                new Trex.Button(this.buttonCfg),
                new Trex.Menu.ColorPallete(this.menuCfg),
                this.handler
            );
        },
        handler: function(color) {
            var self = this;
            var canvas = self.canvas;

            canvas.fireJobs("canvas.apply.backgroundcolor", color);
            canvas.history.saveHistory({
                    backgroundColor: articleBackgroundColor,
                    backgroundImage: canvas.getStyle('backgroundImage')
                }, {
                    backgroundColor: color,
                    backgroundImage: canvas.getStyle('backgroundImage')
                },
                function(data) {
                    self._restoreColor(data);
                }
            );
            if (color === null) {
                canvas.addStyle({
                    backgroundColor: canvas.getConfig().styles ? canvas.getConfig().styles.backgroundColor || "" : "",
                    backgroundImage: canvas.getConfig().styles ? canvas.getConfig().styles.backgroundImage || "" : ""
                });
                articleBackgroundColor = "";
                canvas.getConfig().hasUserBgcolor = _FALSE;
            } else {
                canvas.addStyle({
                    backgroundColor: color,
                    backgroundImage: ""
                });
                articleBackgroundColor = color;
                canvas.getConfig().hasUserBgcolor = _TRUE;
            }
        },
        _restoreColor: function(data) {
            var canvas = this.canvas;
            canvas.addStyle({ backgroundColor: data.backgroundColor });
            if (data.backgroundImage) {
                canvas.addStyle({ backgroundImage: data.backgroundImage });
            }
            articleBackgroundColor = data.backgroundColor;
        }
    });

    Trex.install('canvas.getBgColor & canvas.setBgColor & editor.getContentWithBg',
        function(editor, toolbar, sidebar, canvas, config) {
            articleBackgroundColor = config.canvas.styles.backgroundColor;

            // 저장, 로드할때 content 수정
            canvas.getBgColor = function() {
                var color = articleBackgroundColor || canvas.getPanel("html").getStyle("backgroundColor");
                if (color) {
                    return Trex.Color.getHexColor(color);
                } else {
                    return "";
                }
            };

            canvas.setBgColor = function(color) {
                canvas.getPanel("html").addStyle({
                    "backgroundColor": color || 'transparent'
                });
            };

            editor.getContentWithBg = function() {
                var _selColor = canvas.getBgColor().toLowerCase();
                if (_selColor == 'transparent') {
                    return editor.getContent();
                } else {
                    return [
                        '<table class="txc-wrapper" border="0" cellspacing="0" cellpadding="0"><tr>',
                        '<td bgcolor="', _selColor, '">',
                        editor.getContent(),
                        '</td>',
                        '</tr></table>'
                    ].join("");
                }
            };

            var _originInitContent = canvas.initContent.bind(canvas);
            canvas.initContent = function(content) {
                if (content.search(/<table[^>]*txc-wrapper[^>]*>/i) > -1) {
                    var _selColor;
                    content = content.replace(/<table[^>]*txc-wrapper[^>]*><tr><td([^>]*)>([\s\S]*?)<\/td><\/tr><\/table>/i, function(full, color, html) {
                        _selColor = color.replace(/\sbgcolor="([#\w]*)"/, "$1");
                        return html;
                    });
                    canvas.setBgColor(_selColor);
                }
                _originInitContent(content);
            };

            canvas.history.initHistory({
                'backgroundColor': config.canvas.styles.backgroundColor,
                'backgroundImage': config.canvas.styles.backgroundImage || "none"
            });

            canvas.reserveJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
                var color = canvas.config.articleBackgroundColor;
                if (color && color != "transparent") {
                    canvas.addStyle({
                        backgroundColor: color,
                        backgroundImage: ""
                    });
                }
            });

            canvas.observeJob('canvas.apply.letterpaper', function(data) {
                if (data.id) {
                    canvas.getPanel("html").addStyle({
                        "backgroundColor": 'transparent'
                    });
                }
            });
        }
    );
})();

/**
 * @fileoverview
 *  toolbar의 접힌 부분을 열고닫는 '더보기' Icon을 위해 필요한 configuration과 Class Trex.Tool.Advanced 를 포함
 *
 */
TrexConfig.addTool(
    "advanced", {
        sync: _FALSE,
        status: _TRUE,
        opened: _FALSE
    }
);

/**
 * Trex.Tool.Advanced
 *
 * @class
 * @extends  Trex.Tool
 */
Trex.Tool.Advanced = Trex.Class.create({
    $const: {
        __Identity: 'advanced'
    },
    $extend: Trex.Tool,
    /**
     * instance가 생성될 때 실행되며 필요한 UI Component 및 Event handler를 생성한다.
     *
     * @memberOf Trex.Tool.Advanced.prototype
     * @param {Object} config
     */
    oninitialized: function(config) {
        var self = this;
        var _toolbar = this.toolbar;
        var _elBasic = _toolbar.el;
        self.opened = _FALSE;
        var _elAdvanced = $tom.collect(_elBasic.parentNode, 'div.tx-toolbar-advanced');
        if (!_elAdvanced) {
            return;
        }

        _toolbar.observeJob(Trex.Ev.__CMD_ADVANCED_FOLD, function() {

            $tx.hide(_elAdvanced);
            $tx.removeClassName(_elBasic, 'tx-toolbar-basic-open');
        });

        _toolbar.observeJob(Trex.Ev.__CMD_ADVANCED_SPREAD, function() {

            $tx.show(_elAdvanced);
            $tx.addClassName(_elBasic, 'tx-toolbar-basic-open');
        });

        var _toolHandler = function() {
            if (self.opened) {
                _toolbar.fireJobs(Trex.Ev.__CMD_ADVANCED_FOLD);
            } else {
                _toolbar.fireJobs(Trex.Ev.__CMD_ADVANCED_SPREAD);
            }
            self.opened = !self.opened;
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button(this.buttonCfg),
            /* menu */
            _NULL,
            /* handler */
            _toolHandler
        );

        if (config.opened == _TRUE) {
            this.forceOpen();
        }
    },
    forceOpen: function() {
        this.button.pushedState();
        this.toolbar.fireJobs(Trex.Ev.__CMD_ADVANCED_SPREAD);
        this.opened = _TRUE;
    }
});

Trex.module("add drop-down menu button if extra buttons exist.",
    function(editor, toolbar, sidebar, canvas) {
        canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
            var _elButtonList = $tom.collectAll(editor.getWrapper(), 'li.tx-list-extra div.tx-extra');
            if (_elButtonList.length == 0) {
                return;
            }
            _elButtonList.each(function(elButton) {
                var elMenu = $tom.next(elButton, '.tx-extra-menu');
                if (!elMenu) {
                    return;
                }

                toolbar.makeWidget(
                    new Trex.Button({
                        el: elButton,
                        sync: _FALSE,
                        status: _TRUE
                    }),
                    new Trex.Menu({
                        el: elMenu
                    }),
                    function() { /*dummy handler*/ }
                );
            });
        });
    }
);

(function() {
    TrexConfig.addTool(
        "fullscreen", {
            wysiwygonly: _FALSE,
            status: _FALSE,
            switched: _FALSE,
            minHeight: 200,
            minWidth: 766,
            asyncUrl: "trex/tool/async/fullscreen" + (Trex._JS_MIN ? '.min' : '') + ".js"
        }
    );

    Trex.Tool.FullScreen = Trex.Class.create({
        $const: {
            __Identity: 'fullscreen'
        },
        $extend: Trex.AsyncTool,
        oninitialized: function(config) {
            this.weave.bind(this)(
                new Trex.Button(this.buttonCfg),
                _NULL,
                this.onLoadModule // define in Trex.AsyncTool
            );

            var self = this;
            // #FTDUEDTR-150
            /* HotKey Disable 
            this.bindKeyboard({ // ctrl + m - 넓게쓰기
                ctrlKey: _TRUE,
                keyCode: 77
            }, function() {
                if (!self.loaded) {
                    self.onLoadModule();
                }
            });
            */
        }
    });
})();

/**
 * @imageoverview
 * Image 업로드 관련 Source
 * Trex.Tool.Image - UI,
 * Trex.Attacher.Image,
 * Trex.Attachment.Image,
 * default configuration를 포함하고 있다.
 */
TrexConfig.addTool(
    "image", {
        disabledonmobile: _TRUE,
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE
    }
);

TrexMessage.addMsg({
    '@image.title': Trex._I18N.g('image.title', "사진"),
    '@image.layer.title':Trex._I18N.g('image_popup_title', '이미지 첨부'),
    '@image.cancel.image': Trex._I18N.g('btn_cancel', "#iconpath/btn_cancel.gif?open&v=2"),
    '@image.confirm.image': Trex._I18N.g('btn_confirm', "#iconpath/btn_confirm.gif?open&v=2")
});

Trex.Tool.Image = Trex.Class.create({
    $const: {
        __Identity: 'image'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        var _toolHandler = function(data) {
            _editor.getSidebar().getAttacher("image").execAttach(data);
        };
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            new Trex.Menu.Image(this.menuCfg),
            _toolHandler,
            null
        );
    }
});

Trex.MarkupTemplate.add(
    'menu.insertimage', [
        '<div class="tx-menu-inner">',
        '    <div style="position:absolute;top:-2000px;left:-2000px;width:10px;height:10px;overflow:hidden;"><canvas class="tmp_canvas" width="1" height="1"></canvas></div>',
        '    <dl>',
        '        <dt>',
        '            @image.layer.title',
        '        </dt>',
        '        <dd>',
        // '            <iframe id="imageUpload" src="" frameborder="0" style="width:100%;height:30px"></iframe>',
        '           <label>' + Trex._I18N.g('image.image', "이미지") + '</label><iframe id="imageUpload" src="" frameborder="0" style="width:270px;height:24px;vertical-align:middle;"></iframe></li>',
        '        </dd>',
        '		<dd style="padding-left:40px;">',
        '			<span class="desc">' +  Trex._I18N.g('image.select.desc', '- 한번에 여러 이미지를 선택 가능합니다.') + '</span>',
        '		</dd>',
        '        <dd class="prev_image singlefile" style="text-align:left;border:1px solid #e0e0e0;margin-top:10px;padding:5px;overflow:hidden;"><img class="prev_img" src="" style="max-width:90%;max-height:100px;"><div style="position:absolute;top:-2000px;left:-2000px;width:10px;height:10px;overflow:hidden;"><img src="" class="tmp_img"></div></dd>',
        '		 <dd class="imageInfo singlefile imageAlign"><label>' +  Trex._I18N.g('image.width', "너비") + '</label><span class="g_select"><input type="text" name="txt_img_width" class="txt txt_sel txt_img_width" /><button name="btn_line_up" class="bg btn btn_up_arrow btn_width_up">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow btn_width_down">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span>',
        '		 <label class="inner">' +  Trex._I18N.g('image.height', "높이") + '</label><span class="g_select"><input type="text" name="txt_img_height" class="txt txt_sel txt_img_height" /><button name="btn_line_up" class="bg btn btn_up_arrow btn_height_up">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow btn_height_down">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span>',
        /** 정렬 숨김 처리 */
        // '         <label class="inner">' +  Trex._I18N.g('image.align', "정렬") + '</label>'
        // + '<span class="g_align"><span class="align_text"></span><button name="btn_text_align" class="bg btn btn_down_arrow1 btn_align">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        // '           </button></span>',
        // '			<ul class="align_option" style="display:none;">',
        // '				<li data-style="">' + /* Trex._I18N.g('cellattr.align.default','안함') +*/ '</li>',
        // '				<li data-style="left">' + Trex._I18N.g('cellattr.align.left', '왼쪽') + '</li>',
        // '				<li data-style="center">' + Trex._I18N.g('cellattr.align.center', '가운데') + '</li>',
        // '				<li data-style="right">' + Trex._I18N.g('cellattr.align.right', '오른쪽') + '</li>',
        // '			</ul>',
        '		    <label class="etc" style="margin-right:5px!important;float:right;line-height:25px;"><input type="checkbox" name="ratio" class="chk_img_ratio" style="vertical-align:middle;">' +  Trex._I18N.g('image.ratio', "비율유지") + '</label>',
        '       </dd>',
        '		 <dd class="imageInfo singlefile" style="text-align:right;">',        
        '           <button name="btn_reset" class="btn btn_ok custom btn_reset" style="margin-right:5px;min-width:63px;">' +  Trex._I18N.g('image.origin_size', "원본크기") + '</button>',
        '        </dd>',
        '		<dd class="imageInfo singlefile line t_l">',
        '           <label>' +  Trex._I18N.g('table.detail.border_style', '테두리 스타일') + '</label>'
        + '<span class="g_line"><span class="line_style line1"></span><button name="btn_border_style" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        '</button></span>',
        '			<ul class="line_style_option" style="display:none;">',
        '			#{for:line}<li class="#{class}" data-style="#{style}"><a href="javascript:;"></a></li>#{/for:line}',
        '			</ul>',
        '           <label class="inner">' +  Trex._I18N.g('table.detail.border_line', '테두리 두께') + '</label>'
        + '<span class="g_select"><input type="text" name="txt_border_line" class="txt txt_sel" /><button name="btn_line_up" class="bg btn btn_up_arrow btn_border_up">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow btn_border_down">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span>',
        '		</dd>',
        '		<dd class="imageInfo singlefile line">',
        '           <label>' +  Trex._I18N.g('table.detail.border_color', '테두리 색') + '</label>'
        + '<input type="text" name="txt_border_color" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '			<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '		</dd>',
        '		<dd class="imageInfo singlefile quality t_l">',
        '           <label><input type="checkbox" name="quality" class="img_jpeg_quality"><span>' +  Trex._I18N.g('image.jpeg_quality', 'JPEG 품질') + '</span></label>',
        '           <span class="ijqp_wrap" style="display:none;">: <input type="text" name="quality_p" class="img_jpeg_quality_percent" size=3 value="70"><span>%</span></span>',
        '			<span class="image_size_wrap">' +  Trex._I18N.g('image.size', 'Size') + ':<span class="image_size">-</span></span>',
        '		</dd>',
        '		<dd class="imageInfo multifile" style="display:none;">',
        '			<span class="desc">' +  Trex._I18N.g('image.multifile.desc', '2개 이상의 이미지 선택 시 옵션 선택이 불가능 합니다.<br>본문 삽입 후 "이미지 선택 > 우 클릭"에서 개별 적용하여 주세요') + '</span>',
        '		</dd>',
        '        <dd class="tx-hr">',
        '            <hr/>',
        '        </dd>',
        '        <dd class="tx-btn">',
        '            <img width="32" height="21" src="@image.confirm.image"/>',
        '            <img width="32" height="21" src="@image.cancel.image"/>',
        '        </dd>',
        '    </dl>',
        '</div>'
    ].join("")
);
Trex.ACTIONS = {};
Trex.Menu.Image = Trex.Class.create({
    $extend: Trex.Menu,
    ongenerated: function() {
        var _elMenu = this.elMenu;
        Trex.MarkupTemplate.get('menu.insertimage').evaluateToDom({line:[
            { "class": 'line1', "style": 'solid' },
            { "class": 'line2', "style": 'dotted' },
            { "class": 'line3', "style": 'double' }
        ]}, _elMenu);
        this.elIframe = $tom.collect(_elMenu, 'iframe');
        var _elImgs = $tom.collectAll(_elMenu, '.tx-btn img');
        this.elImgWidth = $tom.collect(_elMenu, '.txt_img_width');
        this.elImgHeight = $tom.collect(_elMenu, '.txt_img_height');
        this.elImgRatio = $tom.collect(_elMenu, '.chk_img_ratio');
        this.elReset = $tom.collect(_elMenu, '.btn_reset');
        this.canvas = $tom.collect(_elMenu, '.tmp_canvas');
        this.img_size = $tom.collect(_elMenu, '.image_size');
        this.elJpegQ = $tom.collect(_elMenu, '.img_jpeg_quality');
        this.elJpegQP = $tom.collect(_elMenu, '.img_jpeg_quality_percent');
        this.elJpegQWrap = $tom.collect(_elMenu, '.ijqp_wrap');
        this._elSingleFile =  $tom.collectAll(_elMenu, '.singlefile');
        this._elMultiFile =  $tom.collectAll(_elMenu, '.multifile');
        this.JPEG_Q_MIN = 50;
        this.JPEG_Q_MAX = 100;
        try{
            this.canvas.toDataURL('image/jpeg', 0);
            this.ctx = this.canvas.getContext("2d");
            this.ctx.save();
        }catch(E){
            // jepg quality not support
            this.canvas = null;
            this.ctx = null;
        }
        if(this.canvas == null || !(window.atob || window.Blob)){
            this.canvas = null;
            this.ctx = null;
            $tom.collect(_elMenu, '.quality').style.display = 'none';
        }
        var _self = this;        
        this._origin = null;
        this._prevInfo = null;
        // this._align = null;
        // this._img_tmp = new Image();
        this._img_tmp = $tom.collect(_elMenu, '.tmp_img');
        this._img = $tom.collect(_elMenu, '.prev_img');
        this._img_dd = $tom.collect(_elMenu, '.prev_image');
        function _imgLoad(){
            // img load
            _self._prevInfo = {width:this.width, height:this.height};            
            changeBorderStyle();
        }
        function _imgError(){
            // img error
            // _self._prevInfo = null;
        }
        this._img.onload = _imgLoad;
        this._img.onerror = _imgError;
        function _calCanvasImageSize(){            
            if(!_self.canvas || !_self._prevInfo) return;
            if(!_self.elJpegQ.checked){
                _displayImageSize(_self._origin.size);
                return;
            }
            _self.img_size.innerHTML = '-';
            var img = _self._img_tmp;
            var _w = img.width, _h = img.height;
            var ctx = _self.ctx;
            var _canvas = _self.canvas;
            _canvas.width = _w;
            _canvas.height = _h;            
            ctx.clearRect(0, 0, _w, _h);
            ctx.drawImage(img, 0, 0, _w, _h);
            var q = (_self.elJpegQP.value||70) / 100;
            var data = _canvas.toDataURL('image/jpeg', q);            
            ctx.clearRect(0, 0, _w, _h);
            _canvas.width = 1;
            _canvas.height = 1;
            ctx.restore();
            /**
             * base64ToBlob 계산이 너무 오래 걸리고 메모리를 많이 먹는다. 그냥 3/4로 계산
             */
            // var blob = Trex.KEditor.base64ToBlob(data.split(',')[1], 'image/jpg');
            // _displayImageSize(blob.size);
            _displayImageSize(data.split(',')[1].length * (3/4));
            // delete blob;
            // blob = null;
            data = '';
            data = null;
        }
        this.insertCanvasImg = function(){
            var data = {};
            // if(_self._align == 'left'){
                data.imagealign = "L";
            // }else if(_self._align == 'center'){
            //     data.imagealign = "C";
            // }else if(_self._align == 'right'){
            //     data.imagealign = "FL";
            // }
            var img = _self._img_tmp; 
            var _w = img.width, _h = img.height;
            var ctx = _self.ctx;
            var _canvas = _self.canvas;            
            _canvas.width = _w;
            _canvas.height = _h;            
            ctx.clearRect(0, 0, _w, _h);
            ctx.drawImage(img, 0, 0, _w, _h);
            var q = (_self.elJpegQP.value||70) / 100;
            data.width = _self.elImgWidth.value;
            data.height = _self.elImgHeight.value;
            if(!data.style) data.style = {};
            data.style.border = _self._getBorderStyle();
            var q = (_self.elJpegQP.value||70) / 100;
            data.imageurl = _self.canvas.toDataURL('image/jpeg', q);
            data.filesize = _self.applyImageSize.toString();
            data.filename = 'image_' + (new Date()).getTime().toString(16) + '.jpg';
            ctx.clearRect(0, 0, _w, _h);
            _canvas.width = 1;
            _canvas.height = 1;
            ctx.restore();
            if(_self._range){
                try{_self._range.deleteContents();}catch(e){}
            }
            _self.onSelect(null, data);
            _self.clearLayer();
        };
        function _displayImageSize(_size){
            var limit = _self._keditor.config.imageLimitSize||0;
            _self.applyImageSize = _size;
            _self.img_size.innerHTML = Trex._getDisplayFileSize(_size);
            $(_self.img_size)[limit == 0 || limit > _size?'removeClass':'addClass']('limit');
        }
        Trex.ACTIONS['image.action.' + this.config.initializedId] = function(data){
            // if(_self._align == 'left'){
                data.imagealign = "L";
            // }else if(_self._align == 'center'){
            //     data.imagealign = "C";
            // }else if(_self._align == 'right'){
            //     data.imagealign = "FL";
            // }
            data.width = _self.elImgWidth.value;
            data.height = _self.elImgHeight.value;
            if(!data.style) data.style = {};
            data.style.border = _self._getBorderStyle();
            if(_self._range){
                try{_self._range.deleteContents();}catch(e){}
            }
            _self.onSelect(null, data);
            _self.clearLayer();
        };
        Trex.ACTIONS['image.action.' + this.config.initializedId + '.setImage'] = function(src){
            _self._img.src = src;
            _self._img_tmp.src = src;
            _self.imgFiles = null;
            _self._showMultiFile(false);
        };
        Trex.ACTIONS['image.action.' + this.config.initializedId + '.setImages'] = function(imgs){
            _self._showMultiFile(true);
            _self.imgFiles = imgs;
        };
        Trex.ACTIONS['image.action.' + this.config.initializedId + '.imageinfo'] = function(data){
            _self._origin = data;
            var info = _self._origin||{};
            _self.elImgWidth.value = info.width||'';
            _self.elImgHeight.value = info.height||'';
            _self.elImgRatio.checked = true;
            _self.elJpegQ.checked = false;
            _displayImageSize(data.size);
        };

        $tx.observe(this.elJpegQ, 'click', function(){
            if(!_self._prevInfo) return;
            if(this.checked){
                _self.elJpegQWrap.style.display = "";
                _calCanvasImageSize();
            }else{
                _self.elJpegQWrap.style.display = "none";
                _displayImageSize(_self._origin.size);
            }
        });
        $tx.observe(this.elJpegQP, 'keyup', function(){
            if(this.value == '') return;
            var val = parseInt(this.value, 10);
            if(isNaN(val)) this.value = '';
            else if(val > _self.JPEG_Q_MAX) this.value = _self.JPEG_Q_MAX;
            else this.value = val;
            if(!this.value == '' && this.value >= _self.JPEG_Q_MIN && this.value <= _self.JPEG_Q_MAX){
                _calCanvasImageSize();
            }
        });
        $tx.observe(this.elJpegQP, 'blur', function(){
            if(this.value == '' || this.value < _self.JPEG_Q_MIN){
                this.value = _self.JPEG_Q_MIN;
                _calCanvasImageSize();
            }
        });


        function setImgSize(width, height){
            var _ratio = _self.elImgRatio.checked;
            var _width = parseInt(width, 0);
            var _height = parseInt(height, 0);
            _width = isNaN(_width)?'':_width;
            _height = isNaN(_height)?'':_height;

            if(_ratio && _self._prevInfo){
                _self._img_tmp.removeAttribute('width');
                _self._img_tmp.removeAttribute('height');
                _self._img_tmp.style.width = '';
                _self._img_tmp.style.height = '';
                if(width != null) {
                    _self._img_tmp.style.width = parseInt(width, 10) + 'px';
                    _self._img_tmp.width = width;
                }
                if(height != null) {
                    _self._img_tmp.style.height = parseInt(height, 10) + 'px';
                    _self._img_tmp.height = height;
                }
                _width = _self._img_tmp.width;
                _height = _self._img_tmp.height;
            }else{
                if(width == null) _width = null; 
                if(height == null) _height = null;
            }
            if(_width != null) _self.elImgWidth.value = _width;
            if(_height != null) _self.elImgHeight.value = _height;
            _width = _self.elImgWidth.value;
            _height = _self.elImgHeight.value;
            if(_self._img && _self._prevInfo){
                if(!_ratio) _self._img.width = _width;
                else _self._img.removeAttribute('width');
                _self._img.height = _height;
            }
            // if(_self._img && _self._prevInfo && _width != null && _self._prevInfo.width > _width) _self._img.width = _width;
            // else if(_self._img) _self._img.removeAttribute('width');
            // if(_self._img && _self._prevInfo && _height != null  && _self._prevInfo.height > _height) _self._img.height = _height;
            // else if(_self._img) _self._img.removeAttribute('height');
            _calCanvasImageSize();
        }

        var _width_up = $tom.collect(_elMenu, '.btn_width_up'),
            _width_down = $tom.collect(_elMenu, '.btn_width_down'),
            _height_up = $tom.collect(_elMenu, '.btn_height_up'),
            _height_down = $tom.collect(_elMenu, '.btn_height_down'); 
        
        $tx.observe(this.elImgWidth, 'blur', function(){
            setImgSize(this.value, null);
        });
        $tx.observe(this.elImgWidth, 'keyup', function(){
            this.value = parseInt(this.value, 10)
            setImgSize(this.value, null);
        });
        $tx.observe(this.elImgRatio, 'click', function(){
            if(this.checked && _self.elImgHeight.value) setImgSize(null, _self.elImgHeight.value);
            // _self.elImgWidth.value = _self._origin?_self._origin.width:'';
            // _self.elImgHeight.value = _self._origin?_self._origin.height:'';
        });
        $tx.observe(this.elReset, 'click', function(){
            _self.elImgWidth.value = _self._origin?_self._origin.width:'';
            _self.elImgHeight.value = _self._origin?_self._origin.height:'';
            setImgSize(null, null);
        });
        $tx.observe(_width_up, 'click', function(){
            _self.elImgWidth.value = (_self.elImgWidth.value||0) - 0 + 1;
            setImgSize(_self.elImgWidth.value, null);
        });        
        $tx.observe(_width_down, 'click', function(){
            var _val = (_self.elImgWidth.value||0) - 1;
            _val = _val < 0?0:_val;
            _self.elImgWidth.value = _val;
            setImgSize(_self.elImgWidth.value, null);
        });
        $tx.observe(this.elImgHeight, 'blur', function(){
            setImgSize(null, this.value);
        });
        $tx.observe(this.elImgHeight, 'keyup', function(){
            setImgSize(null, this.value);
        });
        $tx.observe(_height_up, 'click', function(){
            _self.elImgHeight.value = (_self.elImgHeight.value||0) - 0 + 1;
            setImgSize(null, _self.elImgHeight.value);
        });        
        $tx.observe(_height_down, 'click', function(){
            var _val = (_self.elImgHeight.value||0) - 1;
            _val = _val < 0?0:_val;
            _self.elImgHeight.value = _val;
            setImgSize(null, _self.elImgHeight.value);
        });

        // var _align = $tom.collect(_elMenu, '.imageAlign .g_align'),
        // _align_btn = $tom.collect(_elMenu, '.imageAlign button.btn_align'),
        // _align_list = $tom.collect(_elMenu, '.imageAlign .align_option');
        // this._align_text = $('.align_text', _align);

        // function __align_click(){
        //     _self._closeSubLayer(_align_btn);
        //     if($tx.hasClassName(_align_btn, 'btn_down_arrow1')){
        //         $tx.removeClassName(_align_btn, 'btn_down_arrow1');
        //         $tx.addClassName(_align_btn, 'btn_up_arrow1');
        //         $tx.show(_align_list);
        //     } else {
        //         $tx.removeClassName(_align_btn, 'btn_up_arrow1');
        //         $tx.addClassName(_align_btn, 'btn_down_arrow1');
        //         $tx.hide(_align_list);
        //     }
        // }
        // $tx.observe(_align, 'click', __align_click);
        // // $tx.observe(_align_btn, "click", function(){
        // //     __align_click();
        // // });
        // $('li', _align_list).on('click', function(){
        //     var span = $('.align_text', _align);
        //     var txt = $(this).html();
        //     var style = $(this).data('style');
        //     span.html(txt);
        //     _self._img_dd.style.textAlign = _self._align = style;
        //     __align_click();
        // });

        this.btn_border_style = $('button[name=btn_border_style]', _elMenu);
        this.border_list = $('.line_style_option', _elMenu);
        this.txt_border_line = $('input[name=txt_border_line]', _elMenu);
        this.btn_line_up = $('.btn_border_up', _elMenu);
        this.btn_line_dn = $('.btn_border_down', _elMenu);
        this.txt_border_color = $('input[name=txt_border_color]', _elMenu);
        this.btn_line_color = $('.btn_color', _elMenu);
        this.span_line_color = $('.btn_color span', _elMenu);
        this.line_color_pal = $('.tx-colorpallete', _elMenu);
        this.g_line = $('.line .g_line', _elMenu);
        this._line = {};

        this._getBorderStyle = function(){
            var _l = _self._line;
            var _border = (_l.color && _l.width && _l.style?_l.width + 'px ' + _l.style + ' ' + _l.color:'');
            return _border;
        }
        function changeBorderStyle(){            
            if(_self._img && _self._prevInfo) _self._img.style.border = _self._getBorderStyle();
        }

        this._closeSubLayer = function(_cur) {
            if (_cur != _self.btn_line_color && _self.linePallete_c) _self.linePallete_c.hide();
            if (_cur != _self.btn_border_style) {
                $(_self.btn_border_style).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                $tx.hide(_self.border_list.get(0));
            }
            // if (_cur != _align_btn) {
            //     $(_align_btn).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
            //     $tx.hide(_align_list);
            // }            
        }
        var validCheck = {
            calculate: function(type, operand) {
                var value = (type == 'line' ? (_self._line.width ? _self._line.width : 0) :
                    '');
                var max = (type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                    '');
                value = parseInt(value);
                if (isNaN(value)) value = 1;
                if (value + operand > max || value + operand < 0) {
                    if (type != 'line' && type != 'padding') alert(TXMSG("@table.alert"));
                    return value;
                }
                value = value + operand;
                if (value < 0) value = 0;
                return value.toString();
            },
            getValidValue: function(type, value, previousValue, obj) {
                var max = (type == 'row' ? Trex.Menu.Table.MAX_ROW :
                    type == 'col' ? Trex.Menu.Table.MAX_COL :
                    type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                    type == 'padding' ? Trex.Menu.Table.MAX_PADDING :
                    '');
                if (isNaN(value)) return previousValue;
                if (value < 0 || value > max) {
                    value = value > max ? max : previousValue;
                    if (obj) obj.value = value;
                    alert(Trex._I18N.g('number.alert', '1', max.toString(), '1 이상 ' + max + ' 이하의 숫자만 입력 가능합니다.'));
                }
                return value;
            },
            validColor: function(type, color, previousValue) {
                var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
                if (m === _NULL || color.length > 8) {
                    return previousValue;
                }
                if (m[1].length == 3) {
                    //return "#" + m[1] + m[1];
                    return "#" + m[1].toLowerCase();
                } else {
                    return "#" + m[1].toLowerCase();
                }
            }
        };
        
        //테두리 스타일
        this.btn_border_style.on('click', function() {
            _self._closeSubLayer(_self.btn_border_style);
            if ($(this).hasClass('btn_down_arrow1')) {
                $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                $tx.show(_self.border_list.get(0));
            } else {
                $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                $tx.hide(_self.border_list.get(0));
            }
            return false;
        });
        this.btn_border_style.closest('span').on('click', function() {
            _self.btn_border_style.click();
        });
        this.border_list.find('li').on('click', function(el) {
            var span = $(_self.g_line);
            var cls = $(this).attr('class');
            var style = $(this).data('style');

            if (!span.find('.line_style').hasClass(cls)) {
                span.find('.line_style').remove();
                span.prepend('<span class="line_style ' + cls + '"></span>');
            }
            _self._line.style = style;
            _self.btn_border_style.click();
            changeBorderStyle();
            el.preventDefault();
        });
        // 테두리 두께
        this.setLineColor = function() {
            if (_self._line.width != "" && _self._line.width != "0" && !_self._line.color) {
                _self._line.color = "#ccc";
                _self.txt_border_color.val(_self._line.color);
            } else if (_self._line.width == "" || _self._line.width == "0") {
                //_self._line.color = "";
                //_self.txt_border_color.val(_self._line.color);
            }
            if (!_self._line.color) {
                _self.span_line_color.css('background', '#dfeef9');
            } else {
                _self.span_line_color.css('background', _self._line.color);
            }
            changeBorderStyle();
        }

        this.setLineWidth = function() {
            if (_self._line.color != "" && !_self._line.width) {
                _self._line.width = "1";
                _self.txt_border_line.val(_self._line.width);
            } else if (_self._line.color == "" && _self._line.width != "0") {
                //_self._line.width = "";
                //_self.txt_border_line.val(_self._line.width);
            }
            changeBorderStyle();
        }
        // 테두리 두께
        this.txt_border_line.on('blur', function() {
            this.value = _self._line.width = validCheck.getValidValue('line', this.value, '', this);
            _self.setLineColor();
        });
        this.txt_border_line.on('keyup', function() {
            this.value = _self._line.width = validCheck.getValidValue('line', this.value, '', this);
            _self.setLineColor();
        });
        this.btn_line_up.on('click', function() {
            _self.txt_border_line.get(0).value = _self._line.width = validCheck.calculate('line', 1);
            _self.setLineColor();
        });
        this.btn_line_dn.on('click', function() {
            _self.txt_border_line.get(0).value = _self._line.width = validCheck.calculate('line', -1);
            _self.setLineColor();
        });
        // 테두리 색
        this.txt_border_color.on('blur', function() {
            this.value = _self._line.color = validCheck.validColor('line', this.value, '');
            if (this.value == '') {
                _self.span_line_color.css('background', '#dfeef9');
            } else {
                _self.span_line_color.css('background', this.value);
            }
            _self.setLineWidth();
        });
        this.btn_line_color.on('click', function() {
            _self._closeSubLayer(_self.btn_line_color);
            if (_self.linePallete_c == _NULL) {
                if ($tx.ltie8) {
                    $('.tx-image-property', _elMenu).append(_self.line_color_pal);
                    $(_self.line_color_pal).css('top', '80px');
                    $(_self.line_color_pal).css('right', '10px');
                }
                _self.linePallete_c = _self.createColorPallete(_self.line_color_pal.get(0), function(color) {
                    color = color.toLowerCase();
                    _self._line.color = color;
                    _self.txt_border_color.val(color);
                    if (color == '') {
                        _self.span_line_color.css('background', '#dfeef9');
                    } else {
                        _self.span_line_color.css('background', color);
                    }
                    _self.setLineWidth();
                }, false);
            }
            $tx.hide(_self.border_list.get(0));
            if (_self.cellPallete_c) _self.cellPallete_c.hide();
            _self.linePallete_c.toggle();
            _self.linePallete_c.remainColor(_self.txt_border_color.val());
            return false;
        });

        $tx.observe(_elImgs[0], "click", function(ev) {
            if(_self._origin == null && _self.imgFiles == null) {alert(Trex._I18N.g('image.select_image', '이미지를 선택해 주세요.')); return;}

            if(_self.imgFiles){
                var index = 0;
                function loadImageFile(file){
                    var reader = new FileReader();
                    reader.addEventListener("load", function(){
                        _self._command.apply(this, [{
                            imagealign: "L",
                            imageurl: reader.result,
                            filesize: file.size.toString(), 
                            filename: 'image_' + (new Date()).getTime().toString(16) + "_" + (index++) + '.jpg'
                        }]);
                        if(_self.imgFiles.length > 0){
                            loadImageFile(_self.imgFiles.shift());
                        }else{
                            _self.imgFiles = null;
                            _self.hide();
                            _self.clearLayer();
                        }
                    });                    
                    reader.readAsDataURL(file);
                }
                if(_self._range){
                    try{_self._range.deleteContents();}catch(e){}
                }
                loadImageFile(_self.imgFiles.shift());
            }else{
                var limit = _self._keditor.config.imageLimitSize||0;
                if(limit != 0 && limit < _self.applyImageSize){
                    if(Trex.Image._SUPPORT_JPEG_QUALITY){
                        alert(Trex._I18N.g('image.upload_limit_canvas', Trex._getDisplayFileSize(_self.applyImageSize), Trex._getDisplayFileSize(limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(limit)  + ').\n이미지 첨부의 JPEG 품질 기능을 사용하여 이미지를 첨부해 주세요.'))
                    }else{
                        alert(Trex._I18N.g('image.upload_limit', Trex._getDisplayFileSize(_self.applyImageSize), Trex._getDisplayFileSize(limit), '이미지 업로드 허용 용량을 초과했습니다(제한크기:' + Trex._getDisplayFileSize(limit)  + ').'))
                    }
                    return;
                }
                if(_self.elJpegQ.checked){
                    _self.insertCanvasImg();
                }else{
                    var form = _self.elIframe.contentWindow.document.forms[0];
                    form.action = _self.elIframe.src;
                    form.submit();
                }
            }
            $tx.stop(ev);
        }.bind(this));

        $tx.observe(_elImgs[1], "click", function() {
            this.clearLayer();
            this.onCancel();
        }.bindAsEventListener(this));
    },
    clearLayer:function(){
        this._img.src = '';
        this._img.style.border = '';
        // this._img.style.textAlign = '';
        this._img_tmp.src = '';
        this._img_tmp.removeAttribute('width');
        this._img_tmp.removeAttribute('height');
        this._img_tmp.style.width = '';
        this._img_tmp.style.height = '';
        var editor = this._keditor = KEditor.get(this.config.initializedId);
        var _iframeUrl = (typeof editor.config.imageUploadPath != 'string'?editor.config.imageUploadPath():editor.config.imageUploadPath) + "&type=KEditorLayer&aid=image.action." + this.config.initializedId;
        this.elIframe.src = _iframeUrl;
        this.elImgWidth.value = '';
        this.elImgHeight.value = '';
        this.elImgRatio.checked = false;
        this._origin = null;
        // this._align_text.html('');
        // this._align = null;
        this._prevInfo = null;
        this._img_dd.style.textAlign = 'left';
        this._line = {color:'', width:'', style:'solid'};
        this.txt_border_color.val(this._line.color);
        this.span_line_color.css('background', '#dfeef9');
        this.txt_border_line.val(this._line.width);
        this.elJpegQ.checked = false;
        this.elJpegQP.value = '70';
        this.elJpegQWrap.style.display = 'none';
        this.img_size.innerHTML = '-';
        $($('li', this.border_list)[0]).trigger('click');
        this._closeSubLayer(null);
        this._clearLayer = true;
        this.imgFiles = null;
        this._showMultiFile(false);
    },
    _showMultiFile:function(flag) {
        var _self = this;
        for(var i = 0; i < _self._elSingleFile.length; i++) _self._elSingleFile[i].style.display = flag?'none':'';
        for(var i = 0; i < _self._elMultiFile.length; i++) _self._elMultiFile[i].style.display = flag?'':'none';
    },
    onregenerated: function() {
        if(!this._clearLayer) this.clearLayer();
        this._clearLayer = false;
        this._origin = null;
        this._prevInfo = null;
        this._range = this._keditor.editor.canvas.getProcessor().getSelectionRange(this._keditor.editor.canvas);
    },
    createColorPallete: function(element, fn, inputHidden, elInput, elPreview) {
        var self = this;
        var pallete = new Trex.Menu.ColorPallete({
            el: element,
            thumbs: Trex.__CONFIG_COMMON.thumbs,
            colorInputHidden: inputHidden
        });
        pallete.setCommand(fn);        
        return pallete;
    }
});

TrexConfig.addAttacher(
    "image", {
        multiple: _TRUE,
        multipleuse: _FALSE,
        checksize: _TRUE,
        boxonly: _FALSE,
        wysiwygonly: _TRUE,
        objattr: {},
        features: { left: 350, top: 165, width: /*797*/ 474, height: 150 },
        popPageUrl: "#host#path/pages/trex/image.html?open"
    },
    function(root) {
        var _config = TrexConfig.getAttacher("image", root);
        _config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
        _config.features = TrexConfig.getPopFeatures(_config.features);
    }
);

/**
 * Trex.Attacher.Image
 * @class
 * @extends Trex.Attacher
 */
Trex.Attacher.Image = Trex.Class.create({
    $const: {
        __Identity: 'image'
    },
    $extend: Trex.Attacher,
    name: 'image',
    title: TXMSG("@image.title"),
    canModified: _FALSE,
    canResized: _TRUE,
    matchRegexStartTag: /<(\w+)/, // 첨부시에 dispHtml을 기준으로 속성 및 스타일을 적용 할 태그를 찾을 때 사용
    oninitialized: function() {

    },
    getKey: function(data) {
        return data.imageurl;
    },
    getDataForEntry: function(data) {
        data.imageurl = this.encodeSpaceInUrl(data.imageurl);
        data.originalurl = this.encodeSpaceInUrl(data.originalurl);
        data.attachurl = this.encodeSpaceInUrl(data.attachurl);
        data.thumburl = data.thumburl || data.imageurl.replace(/\/image\//gm, '/P150x100/');

        if (!data.dispElId) {
            data.dispElId = Trex.Util.getDispElId();
        }
        var _seq = ((data.tmpSeq) ? this.entryBox.syncSeq(data.tmpSeq) : this.entryBox.newSeq());
        var _data = Object.extend({
            dataSeq: _seq
        }, data); //NOTE: Cuz IE
        return _data;
    },
    createEntry: function(data, type) {
        return this.createAttachment(data, type);
    },
    encodeSpaceInUrl: function(url) {
        if (!url) {
            return;
        }

        return url.replace(/ /g, "%20");
    },
    execAttach: function(data, type) {
        var _entry = this.createEntry(this.getDataForEntry(data), type);
        _entry.execRegister();
    },
    execReload: function(data, content, type) {
        var _entry = this.createEntry(this.getDataForEntry(data, content), type);
        _entry.execReload();
    }
});

/**
 * Trex.Attachment.Image
 *
 *  @example
 *  	data = {
 *			thumburl: "string",
 *			imageurl: "string",
 *			filename: "string",
 *			filesize: number
 *		}
 * @class
 * @extends Trex.Attachment
 */
Trex.Attachment.Image = Trex.Class.create({
    $const: {
        __Identity: 'image'
    },
    $extend: Trex.Attachment,
    getFieldAttr: function(data) {
        return {
            name: 'tx_attach_image',
            value: [data.thumburl, data.imageurl, data.originalurl, data.exifurl, data.filename, data.filesize].join('|')
        };
    },
    getBoxAttr: function(data) {
        var _rectangle = data.width ? data.width + "x" + data.height + " / " : "";
        return {
            name: data.filename + " (" + _rectangle + data.filesize.toByteUnit() + ")",
            image: data.thumburl
        };
    },
    getObjectAttr: function(data) {
        var _objattr = Object.extend({}, this.actor.config.objattr);
        if (data.width) {
            if (!_objattr.width || _objattr.width > data.width) {
                _objattr.width = data.width;
            }
        } else {
            _objattr.width = _NULL;
        }
        if (data.height) {
            if (!_objattr.height || _objattr.height > data.height) {
                _objattr.height = data.height;
            }
        } else {
            _objattr.height = _NULL;
        }
        return _objattr;
    },
    /**
     * object의 style 값을 가져온다.
     * @function
     */
    getObjectStyle: function(data) {
        var _objstyle = {};
        if (this.actor.config.objstyle) {
            _objstyle = Object.extend(_objstyle, this.actor.config.objstyle);
        }
        if (data.imagealign) {
            var _objectStyle = {
                "L": Trex.Tool.AlignLeft,
                "C": Trex.Tool.AlignCenter,
                "FL": Trex.Tool.AlignRight,
                "FR": Trex.Tool.AlignFull
            }[data.imagealign];
            if (_objectStyle && _objectStyle.__ImageModeProps && _objectStyle.__ImageModeProps['image']) {
                _objstyle = Object.extend(_objstyle, _objectStyle.__ImageModeProps['image']['style']);
            }
        }
        if(data.style && data.style.border){
            _objstyle.border = data.style.border;
        }
        return _objstyle;
    },
    /**
     * object를 감싸고 있는 paragraph tag 의 style 값을 가져온다.
     * @function
     */
    getParaStyle: function(data) {
        var _parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
        if (data.imagealign) {
            var _objectStyle = {
                "L": Trex.Tool.AlignLeft,
                "C": Trex.Tool.AlignCenter,
                "FL": Trex.Tool.AlignRight,
                "FR": Trex.Tool.AlignFull
            }[data.imagealign];
            if (_objectStyle && _objectStyle.__ImageModeProps && _objectStyle.__ImageModeProps['paragraph']) {
                _parastyle = Object.extend(_parastyle, _objectStyle.__ImageModeProps['paragraph']['style']);
            }
        }
        return _parastyle;
    },
    getSaveHtml: function(data) {
        return "<img src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
    },
    getDispHtml: function(data) {
        return "<img id=\"" + data.dispElId + "\" src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
    },
    getDispText: function(data) {
        return "<img src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
    },
    getRegLoad: function(data) {
        return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
    },
    getRegHtml: function(data) {
        return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
    },
    getRegText: function(data) {
        return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
    }
});

/* 이미지 에디터 */
/**
 * @imageoverview
 * Image 업로드 관련 Source
 * Trex.Tool.ImageEdit - UI,
 * Trex.Attacher.ImageEdit,
 * Trex.Attachment.ImageEdit,
 * default configuration를 포함하고 있다.
 */
TrexConfig.addTool(
    "image_edit", {
        disabledonmobile: _TRUE,
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _FALSE
    }
);

TrexMessage.addMsg({
    '@image_editor.title': Trex._I18N.g('image_editor.title', "이미지 편집")
});

Trex.Tool.Image_edit = Trex.Class.create({
    $const: {
        __Identity: 'image_edit'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,
            function() {
                _editor.getSidebar().getAttacher("image_edit").execute('instance=' + _editor.kEditor.instanceId);
            }
        );
    }
});

TrexConfig.addAttacher(
    "image_edit", {
        multiple: _TRUE,
        multipleuse: _FALSE,
        checksize: _TRUE,
        boxonly: _FALSE,
        wysiwygonly: _TRUE,
        objattr: {},
        features: { left: 10, top: 10, width: /*797*/ 1194, height: 674 },
        popPageUrl: "#imageeditorpath"
    },
    function(root) {
        var _config = TrexConfig.getAttacher("image_edit", root);
        _config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
        _config.features = TrexConfig.getPopFeatures(_config.features);
    }
);

/**
 * Trex.Attacher.Image
 * @class
 * @extends Trex.Attacher
 */
Trex.Attacher.Image_edit = Trex.Class.create({
    $const: {
        __Identity: 'image_edit'
    },
    $extend: Trex.Attacher,
    name: 'image_edit',
    title: TXMSG("@image_editor.title"),
    canModified: _FALSE,
    canResized: _TRUE,
    matchRegexStartTag: /<(\w+)/, // 첨부시에 dispHtml을 기준으로 속성 및 스타일을 적용 할 태그를 찾을 때 사용
    oninitialized: function() {

    },
    getKey: function(data) {
        return data.imageurl;
    },
    getDataForEntry: function(data) {
        data.imageurl = this.encodeSpaceInUrl(data.imageurl);
        data.originalurl = this.encodeSpaceInUrl(data.originalurl);
        data.attachurl = this.encodeSpaceInUrl(data.attachurl);
        data.thumburl = data.thumburl || data.imageurl.replace(/\/image\//gm, '/P150x100/');

        if (!data.dispElId) {
            data.dispElId = Trex.Util.getDispElId();
        }
        var _seq = ((data.tmpSeq) ? this.entryBox.syncSeq(data.tmpSeq) : this.entryBox.newSeq());
        var _data = Object.extend({
            dataSeq: _seq
        }, data); //NOTE: Cuz IE
        return _data;
    },
    createEntry: function(data, type) {
        return this.createAttachment(data, type);
    },
    encodeSpaceInUrl: function(url) {
        if (!url) {
            return;
        }

        return url.replace(/ /g, "%20");
    },
    execAttach: function(data, type) {
        var _entry = this.createEntry(this.getDataForEntry(data), type);
        _entry.execRegister();
    },
    execReload: function(data, content, type) {
        var _entry = this.createEntry(this.getDataForEntry(data, content), type);
        _entry.execReload();
    }
});

/**
 * Trex.Attachment.Image
 *
 *  @example
 *  	data = {
 *			thumburl: "string",
 *			imageurl: "string",
 *			filename: "string",
 *			filesize: number
 *		}
 * @class
 * @extends Trex.Attachment
 */
Trex.Attachment.Image_edit = Trex.Class.create({
    $const: {
        __Identity: 'image_edit'
    },
    $extend: Trex.Attachment,
    getFieldAttr: function(data) {
        return {
            name: 'tx_attach_image',
            value: [data.thumburl, data.imageurl, data.originalurl, data.exifurl, data.filename, data.filesize].join('|')
        };
    },
    getBoxAttr: function(data) {
        var _rectangle = data.width ? data.width + "x" + data.height + " / " : "";
        return {
            name: data.filename + " (" + _rectangle + data.filesize.toByteUnit() + ")",
            image: data.thumburl
        };
    },
    getObjectAttr: function(data) {
        var _objattr = Object.extend({}, this.actor.config.objattr);
        if (data.width) {
            if (!_objattr.width || _objattr.width > data.width) {
                _objattr.width = data.width;
            }
        } else {
            _objattr.width = _NULL;
        }
        if (data.height) {
            if (!_objattr.height || _objattr.height > data.height) {
                _objattr.height = data.height;
            }
        } else {
            _objattr.height = _NULL;
        }
        return _objattr;
    },
    /**
     * object의 style 값을 가져온다.
     * @function
     */
    getObjectStyle: function(data) {
        var _objstyle = {};
        if (this.actor.config.objstyle) {
            _objstyle = Object.extend(_objstyle, this.actor.config.objstyle);
        }
        if (data.imagealign) {
            var _objectStyle = {
                "L": Trex.Tool.AlignLeft,
                "C": Trex.Tool.AlignCenter,
                "FL": Trex.Tool.AlignRight,
                "FR": Trex.Tool.AlignFull
            }[data.imagealign];
            if (_objectStyle && _objectStyle.__ImageModeProps && _objectStyle.__ImageModeProps['image']) {
                _objstyle = Object.extend(_objstyle, _objectStyle.__ImageModeProps['image']['style']);
            }
        }
        return _objstyle;
    },
    /**
     * object를 감싸고 있는 paragraph tag 의 style 값을 가져온다.
     * @function
     */
    getParaStyle: function(data) {
        var _parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
        if (data.imagealign) {
            var _objectStyle = {
                "L": Trex.Tool.AlignLeft,
                "C": Trex.Tool.AlignCenter,
                "FL": Trex.Tool.AlignRight,
                "FR": Trex.Tool.AlignFull
            }[data.imagealign];
            if (_objectStyle && _objectStyle.__ImageModeProps && _objectStyle.__ImageModeProps['paragraph']) {
                _parastyle = Object.extend(_parastyle, _objectStyle.__ImageModeProps['paragraph']['style']);
            }
        }
        return _parastyle;
    },
    getSaveHtml: function(data) {
        return "<img src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
    },
    getDispHtml: function(data) {
        return "<img id=\"" + data.dispElId + "\" src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
    },
    getDispText: function(data) {
        return "<img src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
    },
    getRegLoad: function(data) {
        return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
    },
    getRegHtml: function(data) {
        return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
    },
    getRegText: function(data) {
        return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
    }
});
/* 이미지 에디터 끝 */

/**
 * @fileoverview
 * File 업로드 관련 Source
 * Trex.Tool.File - UI,
 * Trex.Attacher.File,
 * Trex.Attachment.File,
 * default configuration를 포함하고 있다.
 */
TrexConfig.addTool(
    "file", {
        disabledonmobile: _TRUE,
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _FALSE
    }
);

TrexMessage.addMsg({
    '@file.title': Trex._I18N.g('file.title', "파일")
});

/**
 * Trex.Tool.File
 * @class
 * @extends Trex.Tool
 */
Trex.Tool.File = Trex.Class.create({
    /** ignore */
    $const: {
        __Identity: 'file'
    },
    /** ignore */
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,
            function() {
                _editor.getSidebar().getAttacher("file").execute();
            }
        );
    }
});

TrexConfig.addAttacher(
    "file", {
        multiple: _TRUE,
        multipleuse: _FALSE,
        checksize: _TRUE,
        boxonly: _FALSE,
        wysiwygonly: _FALSE,
        features: { left: 250, top: 65, width: 450, height: 404 },
        popPageUrl: "#host#path/pages/trex/file.html?open"
    },
    function(root) {
        var _config = TrexConfig.getAttacher("file", root);
        _config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
        _config.features = TrexConfig.getPopFeatures(_config.features);
    }
);

/**
 * Trex.Attacher.File
 * @class
 * @extends Trex.Attacher
 */
Trex.Attacher.File = Trex.Class.create({
    /** @ignore */
    $const: {
        __Identity: 'file'
    },
    /** @ignore */
    $extend: Trex.Attacher,
    name: 'file',
    title: TXMSG("@file.title"),
    canModified: _TRUE,
    canResized: _FALSE,
    oninitialized: function() {},
    getKey: function(data) {
        return data.key || data.attachurl;
    },
    /**
     * data를 editor에 맞게 parsing할때 불리는 methond
     * @memberOf Trex.Attacher.File.prototype
     * @param {Object} data
     */
    getDataForEntry: function(data) {
        if (!data.dispElId) {
            data.dispElId = Trex.Util.getDispElId();
        }
        var _seq = ((data.tmpSeq) ? this.entryBox.syncSeq(data.tmpSeq) : this.entryBox.newSeq());
        var _ext = data.filename.split(".").pop().toLowerCase();
        var _thumburl;
        switch (_ext) {
            case "jpg":
            case "gif":
            case "png":
            case "bmp":
                _thumburl = data.attachurl.replace("/attach/", "/thumbnail/");
                break;
            default:
                _thumburl = Trex.Util.thumburl(_ext);
        }
        var _data = Object.extend({
            dataSeq: _seq,
            thumburl: _thumburl,
            prevurl: Trex.Util.prevurl(data.filename.split(".").pop().toLowerCase())
        }, data); //NOTE: Cuz IE
        return _data;
    }
});

/**
 * Trex.Attachment.File
 *
 *  @example
 *  	data = {
 *			attachurl: "string",
 *			filename: "string",
 *			filesize: number,
 *			filemime: "string"
 *		}
 * @class
 * @extends Trex.Attachment
 */
Trex.Attachment.File = Trex.Class.create({
    /** @ignore */
    $const: {
        __Identity: 'file'
    },
    /** @ignore */
    $extend: Trex.Attachment,
    getFieldAttr: function(data) {
        return {
            name: 'tx_attach_file',
            value: [data.attachurl, data.filesize, data.filename].join('|')
        };
    },
    getBoxAttr: function(data) {
        var _nameMaxLength = 56;
        var _filename = data.filename;
        if (_filename.getRealLength() > _nameMaxLength) {
            if (/\./.test(_filename)) {
                var _nameArr = _filename.split(".");
                var _ext = _nameArr.pop().cutRealLength(_nameMaxLength - 4);
                var _name = _nameArr.join(".").cutRealLength(_nameMaxLength - 1 - _ext.length);
                _filename = _name + "." + _ext;
            } else {
                _filename = _filename.cutRealLength(_nameMaxLength);
            }
        }
        return {
            name: _filename + " (" + data.filesize.toByteUnit() + ")",
            image: data.thumburl
        };
    },
    /**
     * object의 style 값을 가져온다.
     * @function
     */
    getObjectStyle: function(data) {
        var _objstyle = {};
        if (this.actor.config.objstyle) {
            _objstyle = Object.extend(_objstyle, this.actor.config.objstyle);
        }
        if (data.imagealign) {
            var _objectStyle = {
                "L": Trex.Tool.AlignLeft,
                "C": Trex.Tool.AlignCenter,
                "FL": Trex.Tool.AlignRight,
                "FR": Trex.Tool.AlignFull
            }[data.imagealign];
            if (_objectStyle && _objectStyle.__TextModeProps && _objectStyle.__TextModeProps['image']) {
                _objstyle = Object.extend(_objstyle, _objectStyle.__TextModeProps['button']['style']);
            }
        }
        return _objstyle;
    },
    /**
     * object를 감싸고 있는 paragraph tag 의 style 값을 가져온다.
     * @function
     */
    getParaStyle: function(data) {
        var _parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
        if (data.imagealign) {
            var _objectStyle = {
                "L": Trex.Tool.AlignLeft,
                "C": Trex.Tool.AlignCenter,
                "FL": Trex.Tool.AlignFull,
                "FR": Trex.Tool.AlignRight
            }[data.imagealign];
            if (_objectStyle && _objectStyle.__TextModeProps && _objectStyle.__TextModeProps['paragraph']) {
                _parastyle = Object.extend(_parastyle, _objectStyle.__TextModeProps['paragraph']['style']);
            }
        }
        return _parastyle;
    },
    getSaveHtml: function(data) {
        return "<a href=\"" + data.attachurl + "\"><img src=\"" + data.prevurl + "\"/> " + data.filename + "</a>";
    },
    getDispHtml: function(data) {
        return "<button id=\"" + data.dispElId + "\" class=\"txc-file\"><img class=\"tx-unresizable\" src=\"" + data.prevurl + "\" ld=\"" + data.attachurl + "\"/> " + data.filename + "</button>";
    },
    getDispText: function(data) {
        return "[" + TXMSG("@file.title") + ":" + data.dataSeq + "]";
    },
    getRegLoad: function(data) {
        return new RegExp("<(?:a|A)\\s*href=\"?" + data.attachurl.getRegExp() + "[^\"]*\"?[^>]*><(?:img|IMG)[^>]*\/?>[\\S\\s]*?<\/(?:a|A)>", "gm");
    },
    getRegHtml: function(data) {
        return new RegExp("<(?:button|BUTTON)[^>]*id=\"?" + data.dispElId + "\"?[^>]*>[\\S\\s]*?" + data.attachurl.getRegExp() + "[\\S\\s]*?<\/(?:button|BUTTON)>", "gm");
    },
    getRegText: function(data) {
        return new RegExp("\\[" + TXMSG("@file.title") + ":" + data.dataSeq + "\\]", "gm");
    }
});

/**
 * LG전자 음성파일 관련
 */
TrexConfig.addTool(
    "voice", {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _FALSE,
    }
);

Trex.Tool.Voice = Trex.Class.create({
    $const: {
        __Identity: 'voice'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,
            function() {
                _editor.getSidebar().getEmbeder("voice").execute('instance=' + _editor.kEditor.instanceId);
            }
        );
    }
});

TrexConfig.addEmbeder(
    "voice", {
        wysiwygonly: _TRUE,
        useCC: _FALSE
    },
    function(root) {
		var _config = root.sidebar.embeder.voice;
		var editor = KEditor.get(root.initializedId);
		if (editor.config.voice && editor.config.voice.enable && editor.config.voice.win) {
			_config.popPageUrl = TrexConfig.getUrl(editor.config.voice.win.url);
			_config.features = TrexConfig.getPopFeatures(editor.config.voice.win.features);
		}
    }
);

Trex.Embeder.Voice = Trex.Class.create({
    $const: {
        __Identity: 'voice'
    },
    $extend: Trex.Embeder,
    name: 'voice',
    title: 'voice',
    canResized: _TRUE,
    getCreatedHtml: function(data) {
        var _html = this.editor.kEditor.config.voice.getHtml(data);
        return _html;
    }
});

TrexConfig.addTool(
    "recorder", {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _FALSE,
    }
);

Trex.Tool.Recorder = Trex.Class.create({
    $const: {
        __Identity: 'recorder'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,
            function() {
                _editor.getSidebar().getEmbeder("recorder").execute('instance=' + _editor.kEditor.instanceId);
            }
        );
    }
});

TrexConfig.addEmbeder(
    "recorder", {
        wysiwygonly: _TRUE,
        useCC: _FALSE
    },
    function(root) {
        var _config = root.sidebar.embeder.recorder;
        var editor = KEditor.get(root.initializedId);
		if (editor.config.recorder && editor.config.recorder.enable && editor.config.recorder.win) {
			_config.popPageUrl = TrexConfig.getUrl(editor.config.recorder.win.url);
			_config.features = TrexConfig.getPopFeatures(editor.config.recorder.win.features);
		}
    }
);

Trex.Embeder.Recorder = Trex.Class.create({
    $const: {
        __Identity: 'recorder'
    },
    $extend: Trex.Embeder,
    name: 'recorder',
    title: 'recorder',
    canResized: _TRUE,
    getCreatedHtml: function(data) {
        var _html = this.editor.kEditor.config.recorder.getHtml(data);
        return _html;
    }
});

TrexConfig.addTool(
    "media", {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        left: -265,
    }
);

TrexMessage.addMsg({
    '@media.title': Trex._I18N.g('media.title', "멀티미디어"),
    '@media.layer.title':Trex._I18N.g('multimedia_title', '외부컨텐츠 삽입'),
    '@media.layer.type.source':Trex._I18N.g('multimedia_html', 'html(embed,object 소스입력)'),
    '@media.layer.type.link':Trex._I18N.g('multimedia_link', '멀티미디어 링크'),
    '@media.layer.source':Trex._I18N.g('multimedia_source', '소스입력'),
    '@media.layer.link':Trex._I18N.g('multimedia_input_link', '링크입력'),
    '@media.prev.url': "#iconpath/spacer2.gif?open&v=2",
    '@media.prev.url.tvpot': "#iconpath/img_multi_tvpot.gif?open&v=2",
    '@media.prev.url.wmp': "#iconpath/spacer2.gif?open&v=2",
    '@media.cancel.image': Trex._I18N.g('btn_cancel', "#iconpath/btn_cancel.gif?open&v=2"),
    '@media.confirm.image': Trex._I18N.g('btn_confirm', "#iconpath/btn_confirm.gif?open&v=2")
});

Trex.Tool.Media = Trex.Class.create({
    $const: {
        __Identity: 'media'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        var _toolHandler = function(data) {
            _editor.getSidebar().getEmbeder("media").embedHandler(data);
        };
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            new Trex.Menu.Media(this.menuCfg),
            _toolHandler,
            null
        );
    }
});

Trex.MarkupTemplate.add(
    'menu.insertmedia', [
        '<div class="tx-menu-inner">',
        '    <dl>',
        '        <dt>',
        '            @media.layer.title',
        '        </dt>',
        '        <dd>',
        '           <ul class="field">',
        '               <li class="codesubmenu">',
        '                   <ol class="codeMenu">',
        '                       <li><input type="radio" id="type_source" value="source" name="codeType" checked="checked" style="border:none" /> ',
        '                       <label for="type_source">@media.layer.type.source</label></li>',
        '                       <li><input type="radio" id="type_url" value="url" name="codeType" style="border:none" /> ',
        '                       <label for="type_url">@media.layer.type.link</label></li>',
        '                   </ol> ',
        '              </li>',
        '               <li class="inputmenu">',
        '                   <ol>',
        '                       <li id="codeSource"><label>@media.layer.source</label><textarea rows="7" name="source"></textarea></li>',
        '                       <li id="codeUrl" class="unselected"><label>@media.layer.link</label><input type="text" name="url" disabled="true" /></li>',
        '                   </ol>',
        '              </li>',
        '           </ul>',
        '        </dd>',
        '        <dd class="tx-hr">',
        '            <hr/>',
        '        </dd>',
        '        <dd>',
        '            <img width="32" height="21" src="@media.confirm.image"/>',
        '            <img width="32" height="21" src="@media.cancel.image"/>',
        '        </dd>',
        '    </dl>',
        '</div>'
    ].join("")
);

Trex.Menu.Media = Trex.Class.create({
    $extend: Trex.Menu,

    ongenerated: function() {
        var _elMenu = this.elMenu;
        var _self = this;
        Trex.MarkupTemplate.get('menu.insertmedia').evaluateToDom({}, _elMenu);

        this.textArea = $tom.collectAll(_elMenu, '#codeSource textarea')[0];
		this.input = $tom.collectAll(_elMenu, '#codeUrl input')[0];
        var inputs = this.inputs = $tom.collectAll(_elMenu, '.codeMenu input');
        $tx.observe(inputs[0], "click", function(ev) {
            _self.selectType('codeSource');
        }.bind(this));
        $tx.observe(inputs[1], "click", function(ev) {
            _self.selectType('codeUrl');
        }.bind(this));

        var _elImgs = $tom.collectAll(_elMenu, 'img');
        $tx.observe(_elImgs[0], "click", function(ev) {
            var _data = {};
            var types = _self.inputs;
            if (types[1].checked) {
                _data.url = _self.input.value.trim();
            } else if (types[0].checked) {
                _data.code = _self.textArea.value.trim();
            }
            if (_data.url || _data.code) {
                _self.onSelect(null, _data);
            } else {
                alert(Trex._I18N.g('multimedia_addr_error', "첨부할 멀티미디어 주소를 바르게 입력해주세요."));
            }
            $tx.stop(ev);
        }.bind(this));
        $tx.observe(_elImgs[1], "click", function() {
            this.onCancel();
        }.bindAsEventListener(this));
    },
    onregenerated: function() {
        this.inputs[1].checked = true;
        this.selectType('codeUrl');
        this.textArea.value = "";
        this.input.value = "";
    },
    selectType:function(id){        
		if ( id == 'codeUrl' ){
			$tx.addClassName($tx('codeSource'), "unselected")
			$tx.removeClassName($tx('codeUrl'), "unselected")
			this.textArea.value = "";
			this.textArea.disabled = true;
			this.input.disabled=false;
			this.input.focus();
		}else{
			$tx.addClassName($tx('codeUrl'), "unselected")
			$tx.removeClassName($tx('codeSource'), "unselected")
			this.textArea.disabled = false;
			this.input.value = "";
			this.input.disabled=true;
			this.textArea.focus();
		}
    }
});

TrexConfig.addEmbeder(
    "media", {
        wysiwygonly: _TRUE,
        useCC: _FALSE,
        features: {
            left: 250,
            top: 65,
            width: 458,
            height: 568,
            resizable: "yes"
        },
        popPageUrl: "#host#path/pages/trex/multimedia.html?open",
        allowNetworkingFilter: _FALSE,
        allowNetworkingSites: []
    },
    function(root) {
        var _config = root.sidebar.embeder.media;
        if (window._KEDITOR_PATH && window._KEDITOR_BODY_PATH) {
            _config.popPageUrl = _config.popPageUrl.replace("#host#path", window._KEDITOR_BODY_PATH.split('/pages')[0]);
        } else {
            _config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
        }
        _config.features = TrexConfig.getPopFeatures(_config.features);
    }
);

(function() {

    Trex.Embeder.Media = Trex.Class.create({
        $const: {
            __Identity: 'media'
        },
        $extend: Trex.Embeder,
        name: 'media',
        title: TXMSG("@media.title"),
        canResized: _TRUE,
        getCreatedHtml: function(data) {
            var _source = data.code || this.makeSourceByUrl(data.url);
            return convertToHtml(_source);
        },
        getDataForEntry: function() {
            //This function is not needed anymore but absence may generate initializing error. So remained...
        },
        makeSourceByUrl: function(url) {
            var ext = this.getUrlExt(url);
            var size = getDefaultSizeByUrl(url);

            switch (ext) {
                case "swf":
                    return this.generateHTMLForFlash(url, size);
                case "mp3":
                case "wma":
                case "asf":
                case "asx":
                case "mpg":
                case "mpeg":
                case "wmv":
                case "avi":
                    return this.generateHTMLForMoviePlayer(url, size);
                case "mov":
                    return this.generateHTMLForQuicktime(url, size);
                case 'jpg':
                case 'bmp':
                case 'gif':
                case 'png':
                    return this.generateHTMLForImage(url, size);
                default:
                    var iframeHtml = this.generateHTMLIfIframeSource(url, size);
                    if (iframeHtml) {
                        return iframeHtml;
                    }

                    return this.generateHTMLForDefaultEmbed(url, size);
            }
        },
        getUrlExt: function(url) {
            return url.split(".").pop().split("?")[0].toLowerCase();
        },
        getAllowScriptAccess: function(url) {
            var allowScriptAccessAttr = " allowScriptAccess='never'";
            if (this.config.allowNetworkingFilter && isAllowNetworkingSite(url, this.config) == _FALSE) {
                allowScriptAccessAttr += " allowNetworking='internal'";
            }
            return allowScriptAccessAttr;
        },
        generateHTMLForDefaultEmbed: function(url, size) {
            return "<embed src=\"" + url + "\" width='" + size.width + "' height='" + size.height + "' " + this.getAllowScriptAccess(url) + " ></embed>";
        },
        generateHTMLForImage: function(url, size) {
            return "<img src=\"" + url + "\" border=\"0\"/>";
        },
        generateHTMLForFlash: function(url, size) {
            return "<embed src=\"" + url + "\" quality='high' " + this.getAllowScriptAccess(url) + " type='application/x-shockwave-flash' allowfullscreen='true' pluginspage='http://www.macromedia.com/go/getflashplayer' wmode='transparent' width='" + size.width + "' height='" + size.height + "'></embed>";
        },
        generateHTMLForMoviePlayer: function(url, size) {
            return "<embed src=\"" + url + "\" type=\"application/x-mplayer2\" pluginspage=\"http://www.microsoft.com/Windows/MediaPlayer/\" width='" + size.width + "' height='" + size.height + "'></embed>";
        },
        generateHTMLForQuicktime: function(url, size) {
            return "<embed src=\"" + url + "\" type=\"video/quicktime\" pluginspage=\"http://www.apple.com/quicktime/download/indext.html\" width='" + size.width + "' height='" + size.height + "'></embed>";
        },
        generateHTMLIfIframeSource: function(url, size) {
            var tvpotKey = getTvPotKey(url);
            if (tvpotKey) {
                return "<iframe src=\"http://videofarm.daum.net/controller/video/viewer/Video.html?play_loc=undefined&vid=" + tvpotKey + "\" width='" + size.width + "' height='" + size.height + "' frameborder=\"0\" allowfullscreen></iframe>";
            }

            if(url.search(/naver.com\/v/i) != -1){
                var _naver_iframe = null;
                $.ajax({
                    async:false,
                    url:'http://uploader.nmv.naver.com/upload/getLinkInfo.nhn?url=' + encodeURIComponent(url) + '&serviceId=2&level=new'
                })
                .then(function(data){
                    if(data && data.videoTemplate){
                        _naver_iframe = data.videoTemplate;
                        data.width = 544;
                        data.height = 306;
                        if(data.width) _naver_iframe = _naver_iframe.replace(/%WIDTH%/, data.width);
                        if(data.height) _naver_iframe = _naver_iframe.replace(/%HEIGHT%/, data.height);
                    }
                });
                if(_naver_iframe) return _naver_iframe;
            }

            var youtubeMovieKey = getYouTubeMovieKey(url);
            if (youtubeMovieKey) {
                return "<iframe src=\"http://www.youtube.com/embed/" + youtubeMovieKey + "\" width='" + size.width + "' height='" + size.height + "' frameborder=\"0\" allowfullscreen></iframe>";
            }

            return _NULL;
        }
    });

    Trex.register("filter > media ", function(editor, toolbar, sidebar) {
        var _config = sidebar.embeders.media.config;
        editor.getDocParser().registerFilter('filter/embeder/media', {
            'text@load': function(contents) {
                return contents;
            },
            'source@load': function(contents) {
                return convertToHtml(contents);
            },
            'html@load': function(contents) {
                return convertToHtml(contents);
            },
            'text4save': function(contents) {
                return contents;
            },
            'source4save': function(contents) {
                contents = convertFromHtml(contents);
                contents = addFlashOptAllowNetworking(contents, _config);
                return contents;
            },
            'html4save': function(contents) {
                contents = convertFromHtml(contents);
                contents = addFlashOptAllowNetworking(contents, _config);
                return contents;
            },
            'text2source': function(contents) {
                return contents;
            },
            'text2html': function(contents) {
                return contents;
            },
            'source2text': function(contents) {
                return contents;
            },
            'source2html': function(contents) {
                return convertToHtml(contents);
            },
            'html2text': function(contents) {
                return convertFromHtml(contents);
            },
            'html2source': function(contents) {
                return convertFromHtml(contents);
            }
        });
    });

    function isAllowNetworkingSite(url, config) {
        var _matchs, host, i, len;
        host = "";
        _matchs = /[\/]*\/\/([^\/]+)\//i.exec(url);
        if (_matchs && _matchs[1]) {
            host = _matchs[1];
        }
        len = config.allowNetworkingSites.length;
        for (i = 0; i < len; i += 1) {
            if (host == config.allowNetworkingSites[i].host) {
                return _TRUE;
            }
        }
        return _FALSE;
    }

    function addFlashOptAllowNetworking(content, config) {
        var filteredContent;
        if (config.allowNetworkingFilter == _FALSE) {
            return content;
        }
        filteredContent = content.replace(/(<object[^>]*>)((?:\n|.)*?)(<\/object>)/gi, function(match, start, param, end) {
            var _matchs, _matchsForUrl;
            var isBlockContent = _FALSE;
            _matchs = /data[\s]*=[\s"']*(http:\/\/[^\/]+\/)[^("'\s)]+/i.exec(start);
            if (_matchs && _matchs.length == 2) {
                _matchsForUrl = _matchs[1];
                if (isAllowNetworkingSite(_matchsForUrl, config) === _FALSE) {
                    isBlockContent = _TRUE;
                }
            }
            _matchs = /<param[^>]*=[^\w]*movie[^\w]+[^>]*>/i.exec(param);
            if (_matchs && _matchs[0]) {
                _matchsForUrl = /\s+value=["']?([^\s"']*)["']?/i.exec(_matchs[0]);
                if (_matchsForUrl && _matchsForUrl[1]) {
                    if (isAllowNetworkingSite(_matchsForUrl[1], config) === _FALSE) {
                        isBlockContent = _TRUE;
                    }
                }
            }
            _matchs = /<param[^>]*=[^\w]*src[^\w]+[^>]*>/i.exec(param);
            if (_matchs && _matchs[0]) {
                _matchsForUrl = /\s+value=["']?([^\s"']*)["']?/i.exec(_matchs[0]);
                if (_matchsForUrl && _matchsForUrl[1]) {
                    if (isAllowNetworkingSite(_matchsForUrl[1], config) === _FALSE) {
                        isBlockContent = _TRUE;
                    }
                }
            }
            if (isBlockContent === _TRUE) {
                param = param.replace(/<param[^>]*=[^\w]*allowNetworking[^\w]+[^>]*>/i, "");
                param = '<param name="allowNetworking" value="internal" />'.concat(param);
            }
            return start + param + end;
        });
        filteredContent = filteredContent.replace(/(<embed)([^>]*)(><\/embed>|\/>)/gi, function(match, start, attr, end) { //NOTE: #FTDUEDTR-1071 -> #FTDUEDTR-1105
            var _matchs = /\s+src=["']?([^\s"']*)["']?/i.exec(attr);
            if (_matchs && _matchs[1]) {
                if (isAllowNetworkingSite(_matchs[1], config)) {
                    return start + attr + end;
                }
            }
            attr = attr.replace(/\s+allowNetworking=["']?[\w]*["']?/i, "").concat(' allowNetworking="internal"');
            return start + attr + end;
        });
        return filteredContent;
    }

    function convertFromHtml(content) {
        var _matchs;
        var _regLoad = new RegExp("<(?:img|IMG)[^>]*txc-media[^>]*\/?>", "gim");
        var tempContent = content;

        while ((_matchs = _regLoad.exec(tempContent)) != _NULL) {
            var _html = _matchs[0];
            var _source = getSourceByExt(_html);
            if (!$tx.msie && _source.indexOf("$") > -1) {
                _source = _source.replace(/\$/g, "$$$$");
            }
            content = content.replace(_html, _source);
        }

        return content;
    }

    function convertToHtml(content) {
        return content; // LG전자 변환 안함.
        /**
         * iNotes가 IE하위 버전에서 실행 됨으로 youtube 동영상에 iframe을 사용하지 않고 
         * 어느 브라우져에서 실행하든 Embed로 변경함. (mobile에서는 embed를 다시 iframe으로 변경)
         */
        function convertIframeToEmbed(_content) {
            _content = _content.replace(/<iframe[^>]*src=("|'|)https?:\/\/www\.youtube\.com\/(?:embed\/|v\/)+([^'">\/]+)(\?[^"']*)?\1[^>]*>\s*<\/iframe>/i, function(html, quote, vid) {
                var matched, width, height;
                matched = html.match(/\swidth=['"]?(\d+)/);
                width = (matched && matched[1]) || "560";
                matched = html.match(/\sheight=['"]?(\d+)/);
                height = (matched && matched[1]) || "315";
                return '<object width="' + width + '" height="' + height + '"><param name="movie" ' + 'value="https://www.youtube.com/v/' + vid + '?version=3&amp;hl=ko_KR" /><param name="allowFullScreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="wmode" value="transparent" /><embed src="https://www.youtube.com/v/' + vid + '?version=3&amp;hl=ko_KR" type="application/x-shockwave-flash" width="' + width + '" height="' + height + '" allowscriptaccess="always" allowfullscreen="true" wmode="transparent"></embed></object>';
            });
            if (/<object/.test(_content) && /<embed[^>]*type=['"]application\/x-shockwave-flash['"][^>]*>/i.test(_content) && !/<object[^>]*type=['"]application\/x-shockwave-flash['"][^>]*>/i.test(_content)) {
                var index = _content.indexOf('>');
                _content = _content.substring(0, index) + ' type="application\/x-shockwave-flash"' + _content.substring(index);
            }
            return _content;
        }
        if ($tx.msie) { //NOTE: #FTDUEDTR-366 + #FTDUEDTR-372 -> #FTDUEDTR-403
            /*if ($tx.msie_ver < 10) {
                content = content.replace(/<iframe[^>]*src=("|'|)https?:\/\/www\.youtube\.com\/embed\/(\w+)\1[^>]*><\/iframe>/i, function (html, quote, vid) {
                    var matched, width, height;
                    matched = html.match(/\swidth=['"]?(\d+)/);
                    width = (matched && matched[1]) || "560";
                    matched = html.match(/\sheight=['"]?(\d+)/);
                    height = (matched && matched[1]) || "315";
                    return '<object width="' + width + '" height="' + height + '"><param name="movie" ' + 'value="https://www.youtube.com/v/' + vid + '?version=3&amp;hl=ko_KR" /><param name="allowFullScreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="wmode" value="transparent" /><embed src="https://www.youtube.com/v/' + vid + '?version=3&amp;hl=ko_KR" type="application/x-shockwave-flash" width="' + width + '" height="' + height + '" allowscriptaccess="always" allowfullscreen="true" wmode="transparent"></embed></object>';
                });
            }
            if(/<object/.test(content) && /<embed[^>]*type=['"]application\/x-shockwave-flash['"][^>]*>/i.test(content) &&!/<object[^>]*type=['"]application\/x-shockwave-flash['"][^>]*>/i.test(content)) {
                var index = content.indexOf('>');
                content = content.substring(0,index)+ ' type="application\/x-shockwave-flash"' + content.substring(index);
            }*/
            content = convertIframeToEmbed(content);
            //			content = content.replace(/(<object[^>]*>)((?:\n|.)*?)(<\/object>)/gi, function(match, start, param, end) {
            //				param = param.replace(/<param[^>]*=[^\w]*wmode[^\w]+[^>]*>/i, "");
            //				param = param.replace(/<param[^>]*=[^\w]*play[^\w]+[^>]*>/i, "");
            //				param = '<param name="wmode" value="transparent" />'.concat(param);
            //				return start + param + end;
            //			});
            //			content = content.replace(/(<embed)([^>]*)(>)/gi, function (match, start, attr, end) {
            //				attr = attr.replace(/\s+wmode=("|'|)\w*\1/i, '');
            //				attr += ' wmode=transparent';
            //				return start + attr + end;
            //			});

            return content;
        } else {
            var _matchs, _source, _html, _embed;
            var tempContent = content;

            /* Substitute <embed tag within script to <xxembed */
            var _regScript = new RegExp("<(?:script)[^>]*>[\\S\\s]*?(<(?:embed|EMBED)[^>]*src=[^>]*>)[\\S\\s]*?<\/(?:script)>", "gim");
            while ((_matchs = _regScript.exec(tempContent)) != _NULL) {
                _source = _matchs[0];
                _html = _source.replace(/<embed/i, "<xxembed");
                content = content.replace(_source, _html);
            }
            /* 왜하는지?
            var _regLoad = new RegExp("<(?:object|OBJECT)[^>]*>[\\S\\s]*?(<(?:embed|EMBED)[^>]*src=[^>]*>)[\\S\\s]*?<\/(?:object|OBJECT)>", "gim");
            while ((_matchs = _regLoad.exec(tempContent)) != _NULL) {
            	_source = _matchs[0];
            	_embed = _matchs[1];
            	_html = getHtmlByExt(_source, _embed);
            	content = content.replace(_source, _html);
            }

            _regLoad = new RegExp("<(?:embed|EMBED)[^>]*src=[^>]*(?:\/?>|><\/(?:embed|EMBED)>)", "gim");
            while ((_matchs = _regLoad.exec(tempContent)) != _NULL) {
            	_source = _matchs[0];
            	_embed = _matchs[0];
            	_html = getHtmlByExt(_source, _embed);
            	content = content.replace(_source, _html);
            }*/

            content = content.replace(/<xxembed/i, "<embed");
            content = convertIframeToEmbed(content);
            return content;
        }
    }

    function getHtmlByExt(source, embed) {
        var _attrs = Trex.Util.getAllAttributesFromEmbed(embed);
        var _url = _attrs['src'];
        var _width = _attrs['width'].isPercent() ? _attrs['width'] : (_attrs['width'] || " ").parsePx();
        var _height = _attrs['height'].isPercent() ? _attrs['height'] : (_attrs['height'] || " ").parsePx();
        if (parseInt(_width, 10) === 0 || parseInt(_height, 10) === 0) {
            var _size = getDefaultSizeByUrl(_url);
            _width = _size.width;
            _height = _size.height;
        }

        /* make new embed source */
        var _newEmbedSrc = "<embed";
        for (var name in _attrs) {
            if (_attrs.hasOwnProperty(name)) {
                _newEmbedSrc += " " + name + "=\"" + _attrs[name] + "\"";
            }
        }
        _newEmbedSrc += ">";

        /* If source has 'object' then it is needed to add 'object' TAG */
        var arr = source.split(embed);
        source = arr[0] + _newEmbedSrc;
        for (var i = 1; i < arr.length; i++) {
            source += arr[i];
        }

        var _prev = getPreviewByUrl(_url);
        return "<img src=\"" + _prev.imageSrc + "\" width=\"" + _width + "\" height=\"" + _height + "\" border=\"0\" class=\"tx-entry-embed txc-media" + _prev.className + "\" ld=\"" + encodeURIComponent(source) + "\"/>";
    }

    function getSourceByExt(html) {
        var _attrs = Trex.Util.getAllAttributes(html);
        var _longdesc = _attrs['ld'];
        if (!_longdesc || _longdesc.length == 0) {
            return "";
        }
        var _width = _attrs['width'];
        var _height = _attrs['height'];
        var _source = decodeURIComponent(_longdesc);

        var _embed = _source;
        if (_source.indexOf("object") > -1 || _source.indexOf("OBJECT") > -1) {
            var _matchs;
            var _regLoad = new RegExp("<(?:embed|EMBED)[^>]*src=[^>]*(?:\/?>|><\/(?:embed|EMBED)>)", "gim");
            while ((_matchs = _regLoad.exec(_source)) != _NULL) {
                _embed = _matchs[0];
            }
        }

        _attrs = Trex.Util.getAllAttributes(_embed);
        var _url = _attrs['src'];
        var _size = getDefaultSizeByUrl(_url);
        if (isNaN(_width)) {
            _source = Trex.String.changeAttribute(_source, "width", _width, _size.width);
        } else {
            _source = Trex.String.changeAttribute(_source, "width", _width, _width);
        }
        if (isNaN(_height)) {
            _source = Trex.String.changeAttribute(_source, "height", _height, _size.height);
        } else {
            _source = Trex.String.changeAttribute(_source, "height", _height, _height);
        }
        return _source;
    }

    function getTvPotKey(url) {
        return (url.match(/http:\/\/tvpot\.daum\.net\/v\/(.{23})/) || [])[1];
    }

    function getYouTubeMovieKey(url) {
        return (url.match(/(?:http:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:embed\/)*(?:v\/)*(?:watch\?v=)?(.+)/) || [])[1];
    }

    function getDefaultSizeByUrl(url) {
        var _width, _height;
        if (url.indexOf("api.bloggernews.media.daum.net/static/recombox1") > -1) {
            _width = 400;
            _height = 80;
        } else if (url.indexOf("flvs.daum.net/flvPlayer") > -1) {
            _width = 502;
            _height = 399;
        } else if (url.indexOf('youtube') != -1 || url.indexOf('youtu.be') != -1 || url.indexOf('tvpot.daum.net') != -1) {
            var size = TrexConfig.get('size');
            if (size.contentWidth > 640) {
                _width = 640;
                _height = 360;
            } else {
                _width = 560;
                _height = 315;
            }
            // else 853x480
        } else {
            var _ext = url.split(".").pop().split("?")[0].toLowerCase();
            switch (_ext) {
                case "mp3":
                case "wma":
                case "asf":
                case "asx":
                    _width = 280;
                    _height = 45;
                    break;
                case "mpg":
                case "mpeg":
                case "wmv":
                case "avi":
                    _width = 320;
                    _height = 285;
                    break;
                default:
                    _width = 400;
                    _height = 300;
                    break;
            }
        }
        return {
            width: _width,
            height: _height
        };
    }

    function getPreviewByUrl(url) {
        var _class = "";
        var _image = "";
        if (url.indexOf("api.bloggernews.media.daum.net/static/recombox1") > -1) {
            _class = "";
            _image = TXMSG("@media.prev.url");
        } else if (url.indexOf("flvs.daum.net/flvPlayer") > -1) {
            _class = " txc-media-tvpot";
            _image = TXMSG("@media.prev.url.tvpot");
        } else {
            var _ext = url.split(".").pop().split("?")[0].toLowerCase();
            switch (_ext) {
                case "mp3":
                case "wma":
                case "asf":
                case "asx":
                    _class = " txc-media-wmp";
                    _image = TXMSG("@media.prev.url.wmp");
                    break;
                case "mpg":
                case "mpeg":
                case "wmv":
                case "avi":
                    _class = " txc-media-wmp";
                    _image = TXMSG("@media.prev.url.wmp");
                    break;
                default:
                    _class = "";
                    _image = TXMSG("@media.prev.url");
                    break;
            }
        }
        return {
            className: _class,
            imageSrc: _image
        };
    }

})();

// TODO change message!
TrexMessage.addMsg({
    '@canvas.unload.message': Trex._I18N.g('canvas.unload.message', "작성하신 내용이 저장되지 않았습니다. 페이지를 떠나시겠습니까?"),
    '@canvas.unload.message.at.modify': Trex._I18N.g('canvas.unload.message.at.modify', "작성하신 내용이 저장되지 않았습니다. 페이지를 떠나시겠습니까?")
});

Trex.install("editor.isDisableUnloadHandler & editor.setDisableUnloadHandler", function(editor) {
    var _beforeUnloadCheck = _TRUE;
    editor.isDisableUnloadHandler = function() {
        return _beforeUnloadCheck;
    };
    editor.setDisableUnloadHandler = function() {
        _beforeUnloadCheck = _FALSE;
    };
    editor.setEnableUnloadHandler = function() {
        _beforeUnloadCheck = _TRUE;
    };
});

Trex.module("observing beforeunload event",
    function(editor, toolbar, sidebar, canvas, config) {
        var _evConfig = config.events;
        var _validator = new Trex.Validator();
        $tx.observe(window, 'beforeunload', function(ev) {
            if (editor.isDisableUnloadHandler()) {
                if (_evConfig.preventUnload) {
                    canvas.fireJobs(Trex.Ev.__CANVAS_BEFORE_UNLOAD);
                    if (_validator.exists(canvas.getContent())) { //NOTE: 작성한 글이 있을 경우에만 확인
                        ev.returnValue = TXMSG("@canvas.unload.message");
                        return TXMSG("@canvas.unload.message");
                    }
                }
            }
        }, _FALSE);
    }
);

/**
 * @fileoverview
 * 에디터의 이미지를 선택시 툴바의 align icon을 변경시키는 module
 */

TrexMessage.addMsg({
    '@align.image.align.center': Trex._I18N.g('align.image.align.center', "가운데정렬"),
    '@align.image.align.full': Trex._I18N.g('align.image.align.full', "오른쪽글흐름"),
    '@align.image.align.left': Trex._I18N.g('align.image.align.left', "왼쪽정렬"),
    '@align.image.align.right': Trex._I18N.g('align.image.align.right', "왼쪽글흐름"),
    '@align.text.align.center': Trex._I18N.g('align.text.align.center', "가운데정렬 (Ctrl+.)"),
    '@align.text.align.full': Trex._I18N.g('align.text.align.full', "양쪽정렬"),
    '@align.text.align.left': Trex._I18N.g('align.text.align.left', "왼쪽정렬 (Ctrl+,)"),
    '@align.text.align.right': Trex._I18N.g('align.text.align.right', "오른쪽정렬 (Ctrl+/)")
});

Trex.module("Register an eventhandler in order to change align icons upon toolbar when user click a specific image or not.",
    function(editor, toolbar, sidebar, canvas) {
        var _imageAlignModeClass = "tx-selected-image";
        var _alignset = [
            toolbar.tools['alignleft'], toolbar.tools['aligncenter'], toolbar.tools['alignright'], toolbar.tools['alignfull']
        ];
        var _excludes = [
            "txc-2image-c", "txc-3image-c", "txc-footnote", "txc-jukebox", "txc-movie", "txc-gallery", "txc-imazing", "txc-map",
            "txc-file", 'txc-emo', "tx-entry-embed", "txc-bgm", "txc-pie"
        ];

        var _changeButton = function(kind) {
            var _exec = function(tool, kind, title) {
                if (!tool) {
                    return;
                }
                var _elList = _NULL;
                var _elIcon = _NULL;
                if (!_elList) {
                    _elList = $tom.find(tool.button.elButton, "li");
                }
                if (!_elIcon) {
                    _elIcon = $tx(tool.button.elIcon);
                }
                _elIcon.title = title;
                if (kind == "image" /*|| (editor._imageResizeCtrl && editor._imageResizeCtrl.isActive)*/ ) {
                    if (!$tx.hasClassName(_elList, _imageAlignModeClass)) {
                        $tx.addClassName(_elList, _imageAlignModeClass);
                    }
                    tool.imageAlignMode = _TRUE;
                } else {
                    if ($tx.hasClassName(_elList, _imageAlignModeClass)) {
                        $tx.removeClassName(_elList, _imageAlignModeClass);
                    }
                    tool.imageAlignMode = _FALSE;
                }
            };
            _exec(_alignset[0], kind, kind == "image" ? TXMSG("@align.image.align.left") : TXMSG("@align.text.align.left"));
            _exec(_alignset[1], kind, kind == "image" ? TXMSG("@align.image.align.center") : TXMSG("@align.text.align.center"));
            _exec(_alignset[2], kind, kind == "image" ? TXMSG("@align.image.align.right") : TXMSG("@align.text.align.right"));
            _exec(_alignset[3], kind, kind == "image" ? TXMSG("@align.image.align.full") : TXMSG("@align.text.align.full"));
        };

        canvas.observeElement([
            { tag: "body" },
            { tag: "table" },
            { tag: "hr" }
        ], function() {
            _changeButton("text");
        });

        canvas.observeElement({ tag: "img" }, function(element) {
            var matched = Trex.Util.getMatchedClassName(element, _excludes);
            if (matched) {
                _changeButton("text");
            } else if ($tom.find(element, 'button')) {
                _changeButton("text");
            } else {
                _changeButton("image");
            }
        });
    }
);

// NOTE 전체적으로 refactoring 필요
Trex.module("make padding area inside Canvas with editor width",
    function(editor, toolbar, sidebar, canvas) {
        var _wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        if (!_wysiwygPanel) {
            return;
        }
        var _elWysiwyg = _wysiwygPanel.el;

        var SCROLL_WIDTH = 16;
        var REQUIRED_MINIMUM_PADDING = 28;
        var BORDER_OF_CANVAS = 2;

        var _elLeftSpace;
        var _elRightSpace;
        var _elLeftSpaceChild;
        var _elRightSpaceChild;

        var sizeConfig = canvas.getSizeConfig();
        var currentCanvasWidth = canvas.getContainerWidth();
        var contentWidth = sizeConfig.contentWidth.toNumber();
        var contentPadding = sizeConfig.contentPadding.toNumber();
        var fixedContentWidth = (currentCanvasWidth > contentWidth); // canvas.js: _sizeConfig.contentWidth = _sizeConfig.wrapWidth 와 얽힌 문제임.
        fixedContentWidth = false; // fixedContentWidth 사용 안함. 작은창에서 Editor 로드 후 창 크기를 키우면 양쪽 여백이 생기는 현상 발생.
        //배경이 적용되었을 경우 사이즈를 변경한다.
        canvas.observeJob('canvas.apply.background', function(data) {
            adjustCanvasPadding({
                top: (data && data.topLeftHeight) ? data.topLeftHeight.parsePx() : 0,
                right: (data && data.midRightWidth) ? data.midRightWidth.parsePx() : 0,
                bottom: (data && data.botLeftHeight) ? data.botLeftHeight.parsePx() : 0,
                left: (data && data.midLeftWidth) ? data.midLeftWidth.parsePx() : 0
            });
        });

        //NOTE: 메일, 편지지가 적용되었을 에디터 영역의 패딩을 조정한다.
        canvas.observeJob('canvas.apply.letterpaper', function(data) {
            adjustCanvasPadding({
                top: (data && data.topHeight) ? data.topHeight.parsePx() : 0,
                right: (data && (data.midColor || data.midUrl)) ? contentPadding : 0,
                bottom: (data && data.botHeight) ? data.botHeight.parsePx() : 0,
                left: (data && (data.midColor || data.midUrl)) ? contentPadding : 0
            });
        });

        // contentWidth가 지정된 경우만, 패딩을 조정할 필요가 있다.
        if (fixedContentWidth) {

            // iframe이 로딩되면 패딩영역을 추가한다.
            canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
                adjustCanvasPadding();
                createGuideArea();
                updatePaddingSpace();
            });

            //모드를 변경하였을 경우 패딩영역 처리
            canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function() {
                adjustGuidAreaPosition();
                updatePaddingSpace();
            });

            //에디터 래퍼의 너비가 변하였을 경우 패딩영역의 위치를 조절한다.
            canvas.observeJob(Trex.Ev.__CANVAS_WRAP_WIDTH_CHANGE, onCanvasWidthChanged);
            canvas.observeJob(Trex.Ev.__CANVAS_NORMAL_SCREEN_CHANGE, onCanvasWidthChanged);
            canvas.observeJob(Trex.Ev.__CANVAS_FULL_SCREEN_CHANGE, onCanvasWidthChanged);


            // 아래 코드의 필요성은 확인 필요
            if (!$tx.msie_nonstd) {
                if ($tx.gecko) {
                    $tx.setStyle(_elWysiwyg, {
                        overflowX: 'auto',
                        overflowY: 'auto'
                    });
                } else if ($tx.chrome) {
                    $tx.setStyle(_elWysiwyg.contentDocument.documentElement, {
                        overflowX: 'auto',
                        overflowY: 'auto'
                    });
                } else {
                    $tx.setStyle(_elWysiwyg, {
                        overflowX: 'auto',
                        overflowY: 'scroll'
                    });
                }
            }
        }

        canvas.getCanvasGuideSize = function() {
            return calculdateGuideArea().leftWidth.parsePx();
        };

        function adjustCanvasPadding(skinStyle) {
            _wysiwygPanel.addStyle(calculdateCanvasPadding(skinStyle));
        }

        //iframe 패딩과 패딩영역의 사이즈를 계산한다.
        function calculdateCanvasPadding(skinStyle) {
            var canvasPadding = {};
            var direction = ['top', 'bottom', 'left', 'right'];

            for (var i = 0; i < direction.length; i++) {
                var key = direction[i];
                canvasPadding[key] = (skinStyle && skinStyle[key]) || contentPadding;
            }

            if (fixedContentWidth) {
                canvasPadding.mleft = Math.max(Math.ceil(getGuideAreaWidth()), 0);
                canvasPadding.mright = Math.max(Math.floor(getGuideAreaWidth()), 0); // for quirks mode

                return {
                    width: contentWidth.toPx(),
                    paddingLeft: canvasPadding.left.toPx(),
                    paddingRight: canvasPadding.right.toPx(),
                    paddingTop: canvasPadding.top.toPx(),
                    paddingBottom: canvasPadding.bottom.toPx(),
                    marginLeft: canvasPadding.mleft.toPx(),
                    marginRight: canvasPadding.mright.toPx()
                };
            } else {
                return {
                    paddingTop: canvasPadding.top.toPx(),
                    paddingRight: canvasPadding.right.toPx(),
                    paddingBottom: canvasPadding.bottom.toPx(),
                    paddingLeft: canvasPadding.left.toPx()
                };
            }
        }

        function getGuideAreaWidth() {
            return (currentCanvasWidth - contentWidth - BORDER_OF_CANVAS - SCROLL_WIDTH) / 2;
        }

        function calculdateGuideArea() {
            var _guideAreaWidth = getGuideAreaWidth();
            if (_guideAreaWidth < REQUIRED_MINIMUM_PADDING) {
                return {
                    leftWidth: '0',
                    rightWidth: '0',
                    rightPos: '0'
                };
            } else {
                return {
                    leftWidth: Math.ceil(_guideAreaWidth - contentPadding).toPx(),
                    rightWidth: Math.max(0, (Math.floor(_guideAreaWidth - contentPadding))).toPx(),
                    rightPos: (contentWidth + Math.ceil(_guideAreaWidth + contentPadding)).toPx()
                };
            }
        }

        function isGuideAreaCreated() {
            return _elLeftSpace && _elRightSpace;
        }

        var queuedJob;

        function onCanvasWidthChanged() {
            // for quirks mode
            clearTimeout(queuedJob);
            queuedJob = setTimeout(function() {
                currentCanvasWidth = canvas.getContainerWidth();
                adjustPanelPandding();
            }, 4);
        }

        function adjustPanelPandding() {
            adjustCanvasPadding();
            adjustGuidAreaPosition();
            updatePaddingSpace();
        }

        function createGuideArea() {
            var canvasTextColor = canvas.getStyleConfig().color;

            _elLeftSpace = tx.div({ className: "tx-wysiwyg-padding" });
            _elLeftSpaceChild = tx.div({
                className: "tx-wysiwyg-padding-divL",
                style: {
                    borderColor: canvasTextColor
                }
            });

            _elRightSpace = tx.div({ className: "tx-wysiwyg-padding" });
            _elRightSpaceChild = tx.div({
                className: "tx-wysiwyg-padding-divR",
                style: {
                    borderColor: canvasTextColor
                }
            });

            var _elHolder = canvas.wysiwygEl;
            _elLeftSpace.appendChild(_elLeftSpaceChild);
            _elHolder.insertBefore(_elLeftSpace, _elWysiwyg);
            _elRightSpace.appendChild(_elRightSpaceChild);
            _elHolder.insertBefore(_elRightSpace, _elWysiwyg);

            adjustGuidAreaPosition();
        }

        function adjustGuidAreaPosition() {
            if (isGuideAreaCreated()) {
                var _guideAreaSizes = calculdateGuideArea();

                $tx.setStyle(_elLeftSpace, {
                    width: _guideAreaSizes.leftWidth
                });
                $tx.setStyle(_elRightSpace, {
                    width: _guideAreaSizes.rightWidth,
                    left: _guideAreaSizes.rightPos
                });

                var enoughSpaceForGuideArea = _guideAreaSizes.leftWidth.parsePx() > REQUIRED_MINIMUM_PADDING;
                var showGuideArea = canvas.getConfig().showGuideArea;
                var guideAreaBorder = enoughSpaceForGuideArea && showGuideArea ? "1px solid" : "0 none";

                $tx.setStyle(_elLeftSpaceChild, {
                    borderRight: guideAreaBorder,
                    borderBottom: guideAreaBorder
                });
                $tx.setStyle(_elRightSpaceChild, {
                    borderLeft: guideAreaBorder,
                    borderBottom: guideAreaBorder
                });
            }
        }

        function updatePaddingSpace() {
            if (isGuideAreaCreated()) {
                if (canvas.mode == Trex.Canvas.__WYSIWYG_MODE) {
                    $tx.show(_elLeftSpace);
                    $tx.show(_elRightSpace);
                } else {
                    $tx.hide(_elLeftSpace);
                    $tx.hide(_elRightSpace);
                }
            }
        }
    }
);


Trex.module("Register an eventhandler in order to resize block and edit search results & some images in wysiwig panel.",
    function(editor, toolbar, sidebar, canvas) {

        if ($tx.msie_nonstd) {
            var _blockResizeHandler = function(element) {
                if (element.onresizestart == _NULL) {
                    element.onresizestart = function() {
                        return _FALSE;
                    };
                }
            };
            canvas.observeElement({ tag: "img", klass: "tx-unresizable" }, _blockResizeHandler);
            canvas.observeElement({ tag: "img", klass: "tx-entry-attach" }, _blockResizeHandler);
            canvas.observeElement({ tag: "img", klass: "txc-footnote" }, _blockResizeHandler);
            canvas.observeElement({ tag: "iframe", klass: "txc-map" }, _blockResizeHandler);
        }

        var _blockSelectHandler;
        if ($tx.msie_nonstd) {
            _blockSelectHandler = function(element) {
                element.setAttribute("unselectable", "on");
                $A(element.getElementsByTagName("*")).each(function(child) {
                    if (child.nodeName.charAt(0) != "/") {
                        child.setAttribute("unselectable", "on");
                    }
                });
                var _processor = canvas.getProcessor();
                _processor.selectControl(element);
            };
        } else {
            _blockSelectHandler = function(element) {
                var _processor = canvas.getProcessor();
                _processor.selectControl(element);
                throw $stop;
            };
        }
        canvas.observeElement({ tag: "button" }, _blockSelectHandler);
        canvas.observeElement({ tag: "img" }, function(element) {
            var _button = $tom.find(element, 'button');
            if (_button) {
                _blockSelectHandler(_button);
                throw $stop;
            }
        });
    }
);


Trex.module("in order to save history for image resizing on IE",
    function(editor, toolbar, sidebar, canvas /*, config*/ ) {
        var _history = canvas.history;
        var _prevImageStatus = {};
        var _imageNode = _NULL;

        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev) {
            var node = $tx.element(ev);
            if (node && node.tagName && node.tagName.toLowerCase() == "img") {
                _imageNode = node;
                _prevImageStatus = $tom.getPosition(node);
            }
        });

        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function() {
            if (_imageNode) {
                var isChanged = _FALSE;
                try {
                    var _curImageStatus = $tom.getPosition(_imageNode);
                    for (var _name in _curImageStatus) {
                        if (_curImageStatus[_name] != _prevImageStatus[_name]) {
                            isChanged = _TRUE;
                        }
                    }
                    if (isChanged) {
                        _history.saveHistory();
                    }
                } catch (e) {} finally {
                    _imageNode = _NULL;
                }
            }
        });
    }
);


Trex.module("Add layer to display notice message on editor area before editing", //NOTE: #FTDUEDTR-18
    function(editor, toolbar, sidebar, canvas, config) {
        if (config.initializedMessage) {
            canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
                var _initializedId = config.initializedId;
                var _noticeDiv = tx.div({ id: "tx-canvas-notice" + _initializedId, className: "tx-canvas-notice" }, config.initializedMessage);
                var txLoading = $tx("tx_loading" + _initializedId);
                var txLoadingParent = txLoading.parentNode;
                txLoadingParent.insertBefore(_noticeDiv, txLoading);

                var disappeared = false;
                var _noticeDivHandler = function() {
                    if (!disappeared && $tx("tx-canvas-notice" + _initializedId)) {
                        disappeared = true;
                        txLoadingParent.removeChild(_noticeDiv);
                        canvas.focus();
                    }
                };

                setTimeout(function() {
                    $tx.observe(canvas.getPanel('html').getWindow(), 'focus', _noticeDivHandler);
                }, 30);
                $tx.observe(_noticeDiv, "click", _noticeDivHandler);
                canvas.observeJob(Trex.Ev.__CANVAS_DATA_INITIALIZE, _noticeDivHandler);
                toolbar.observeJob(Trex.Ev.__TOOL_CLICK, _noticeDivHandler);
            });
        }
    }
);


/*jslint onevar: false, nomen: false*/
/*global Trex, TrexMessage, TXMSG, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.MarkupTemplate.add('table.col.resize.dragger', '<div class="tx-table-col-resize-dragger" style="position:absolute; overflow:hidden; top: 0; left: 0; width: 3px; height: 100%; cursor:col-resize;"><\/div>');
Trex.MarkupTemplate.add('table.row.resize.dragger', '<div class="tx-table-row-resize-dragger" style="position:absolute; overflow:hidden; top: 0; left: 0; width: 100%; height: 3px; cursor:row-resize;"><\/div>');

TrexMessage.addMsg({
    '@table.noselect.alert': Trex._I18N.g('table.noselect.alert', "테이블을 선택하신 후 사용가능합니다.")
});

Trex.Table = {};
Trex.module("table selector", function(editor, toolbar, sidebar, canvas, config) {
    var initDragger;
    initDragger = function(canvas) {
        var colDragger, rowDragger, wysiwygEl;
        colDragger = Trex.MarkupTemplate.get("table.col.resize.dragger").evaluateAsDom({});
        rowDragger = Trex.MarkupTemplate.get("table.row.resize.dragger").evaluateAsDom({});
        wysiwygEl = canvas.wysiwygEl;
        $tom.insertFirst(wysiwygEl, colDragger);
        $tom.insertFirst(wysiwygEl, rowDragger);
        $tx.hide(colDragger);
        $tx.hide(rowDragger);
    };
    canvas.observeJob(Trex.Ev.__CANVAS_PANEL_BACKSPACE_TABLE, function(node) {
        $tom.remove(node);
    });
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
        var tableSelect, tableMerge, tableInsert, tableDelete, tableBorder, tableTemplateLoader, tableCellCopy;

        tableSelect = new Trex.Table.Selector(editor, config);
        tableMerge = new Trex.Table.Merge(editor, config);
        tableInsert = new Trex.Table.Insert(editor, config);
        tableDelete = new Trex.Table.Delete(editor, config);
        tableBorder = new Trex.Table.Border(editor, config);
        tableTemplateLoader = new Trex.Table.TemplateLoader();
        tableCellCopy = new Trex.Table.CellCopy.build(editor, config, tableInsert);

        initDragger(canvas);

        var wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        var processor = wysiwygPanel.getProcessor();
        /**
         * selectCellByCaret
         * 캐럿의 위치에 해당하는 cell 을 선택한다.
         */
        var selectCellByCaret = function() {
            var node, td;
            if (tableSelect.getSelected().isValid() === _FALSE) {
                node = processor.getNode();
                td = Trex.TableUtil.getClosestByTagNames(["td", "th"], node);
                if (td) {
                    tableSelect.selectByTd(td, td);
                }
            }
        };
        /**
         * table 을 선택하면 advanced 가 열림.
         * //CHECK:
         * table 버튼들의 위치가 advanced 라고 가정하고 있음.
         */
        /*
		canvas.observeElement({
			tag: 'table'
		}, function (elem) {
			if (toolbar.tools.advanced) {
				toolbar.tools.advanced.forceOpen();
			}
		});
		*/
        /**
         * border 를 적용하기 위한 4가지 옵션값.
         */
        var borderProperty = {
            range: "all",
            color: "",
            height: 1,
            type: "solid"
        };
        var setDefaultBorderProperty = function() {
            var tool = toolbar.tools.cellslinecolor;
            if (tool) {
                borderProperty.color = tool.config.defaultcolor;
            }
        };
        setDefaultBorderProperty();

        var alertFromNoSelect = function() {
            alert(TXMSG('@table.noselect.alert'));
        };

        processor.table = {
            /**
             * getTdArr
             * 선택한 cell 들의 array.
             * //CHECK: getSelectedCells ?
             * 지금보니 이름이 마음에 들지 않네...
             * @return {Array}
             */
            getTdArr: function() {
                return tableSelect.getSelectedTdArr();
            },
            /**
             * isDuringSelection
             * 선택을 하고 있는 중인지 여부(선택을 위한 드래그 중).
             * @return {boolean}
             */
            isDuringSelection: function() {
                return tableSelect.isDuringSelection();
            },

            execute: function(fn, noCaretSelect) {
                if (!noCaretSelect) {
                    selectCellByCaret();
                }
                if (tableSelect.getSelected().isValid()) {
                    fn();
                    canvas.history.saveHistory();
                } else {
                    alertFromNoSelect();
                }
            },

            merge: function() {
                this.execute(function() {
                    tableMerge.merge(tableSelect);
                }, _TRUE);
            },
            resetMerge: function() {
                this.execute(function() {
                    tableMerge.resetMerge(tableSelect);
                });
            },
            insertRowAbove: function() {
                this.execute(function() {
                    tableInsert.insertRowAbove(tableSelect);
                });
            },
            insertRowBelow: function() {
                this.execute(function() {
                    tableInsert.insertRowBelow(tableSelect);
                });
            },
            insertColLeft: function() {
                this.execute(function() {
                    tableInsert.insertColLeft(tableSelect);
                });
            },
            insertColRight: function() {
                this.execute(function() {
                    tableInsert.insertColRight(tableSelect);
                });
            },
            deleteTable: function() {
                this.execute(function() {
                    tableDelete.deleteTable(tableSelect);
                });
            },
            deleteRow: function() {
                this.execute(function() {
                    tableDelete.deleteRow(tableSelect);
                });
            },
            deleteCol: function() {
                this.execute(function() {
                    tableDelete.deleteCol(tableSelect);
                });
            },
            cellCopy: function(){
                this.execute(function() {
                    tableCellCopy.copy(tableSelect);
                });
            },
            cellPaste: function(){
                this.execute(function() {
                    tableCellCopy.paste(tableSelect);
                });
            },
            setBorderRange: function(outlineType) {
                borderProperty.range = outlineType;
            },
            setBorderColor: function(color) {
                borderProperty.color = color;
                toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
                    color: color
                });
            },
            setBorderHeight: function(height) {
                borderProperty.height = height;
                toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
                    height: height
                });
            },
            setBorderType: function(type) {
                borderProperty.type = type;
                toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
                    type: type
                });
            },
            setNoBorder: function() {
                var self = this;
                this.execute(function() {
                    tableBorder.setTableSelect(tableSelect);
                    tableBorder.setBorderRange("all");
                    tableBorder.changeBorderColor(self.getTdArr(), "");
                    tableBorder.changeBorderHeight(self.getTdArr(), "0");
                    tableBorder.changeBorderType(self.getTdArr(), "none");
                });
            },
            setBorderButtons: function(color, height, type) {
                var tool;
                tool = toolbar.tools.cellslinecolor;
                if (tool) {
                    tool.execute(color);
                }
                tool = toolbar.tools.cellslineheight;
                if (tool) {
                    tool.execute(height);
                }
                tool = toolbar.tools.cellslinestyle;
                if (tool) {
                    tool.execute(type);
                }
            },
            getBorderProperty: function() {
                return {
                    color: borderProperty.color,
                    height: borderProperty.height,
                    type: borderProperty.type
                };
            },
            applyBorder: function() {
                var self = this;
                this.execute(function() {
                    tableBorder.setTableSelect(tableSelect);
                    tableBorder.setBorderRange(borderProperty.range);
                    tableBorder.changeBorderColor(self.getTdArr(), borderProperty.color);
                    tableBorder.changeBorderHeight(self.getTdArr(), borderProperty.height);
                    tableBorder.changeBorderType(self.getTdArr(), borderProperty.type);
                    self.addBorderHistory();
                });
            },
            addBorderHistory: function() {
                var tool;
                tool = toolbar.tools.cellslinepreview;
                if (tool) {
                    tool.addBorderHistory(borderProperty);
                }
            },

            tableBackground: function(value) {
                var self = this;
                value = value || 'transparent';
                this.execute(function() {
                    var style, tdArr, i, len;
                    style = {
                        "backgroundColor": value
                    };
                    tdArr = self.getTdArr();
                    len = tdArr.length;
                    for (i = 0; i < len; i += 1) {
                        $tx.setStyle(tdArr[i], style);
                    }
                    tableSelect.reset();
                });
            },

            setTemplateStyle: function(table, templateIndex) {
                if (table) {
                    var self = this;
                    tableTemplateLoader.getTemplate(templateIndex, function(template) {
                        template.apply(table);
                        self._applyTemplateOutline(table, template.templateData);
                        tableSelect.reset();
                    });
                } else {
                    alertFromNoSelect();
                }
            },
            /**
             * 테이블 템플릿을 적용해도 테두리에 대한 정확한 적용이 되지않아 흰색 혹은 none의 상태가 된다.
             * 이를 보완하기 위해서 테이블 기본 기능을 이용해서 테두리를 재설정 한다.
             *
             * @param table
             * @param templateData
             * @private
             */
            _applyTemplateOutline: function(table, templateData) {
                var item = templateData;
                var self = this;
                var outlineBorder = {
                    top: this._parseBorderStyle(item.firstRow.borderTop),
                    right: this._parseBorderStyle(item.lastCol.borderRight || item.common.borderRight),
                    bottom: this._parseBorderStyle(item.lastRow.borderBottom || item.common.borderBottom),
                    left: this._parseBorderStyle(item.firstCol.borderLeft)
                };

                var tableMatrixer = new Trex.Tool.Table.TableCellMatrixer(table);
                var tdMatrix = tableMatrixer.getTdMatrix();
                var rowSize = tableMatrixer.getRowSize();
                var colSize = tableMatrixer.getColSize();

                if (tdMatrix && tdMatrix.length) {
                    tableSelect.selectByTd(tdMatrix[0][0], tdMatrix[rowSize - 1][colSize - 1]);
                    tableBorder.setTableSelect(tableSelect);

                    var direction = ['top', 'right', 'bottom', 'left'];
                    direction.each(function(dir) {
                        tableBorder.setBorderRange(dir);
                        tableBorder.changeBorderColor(self.getTdArr(), outlineBorder[dir]['color']);
                        tableBorder.changeBorderHeight(self.getTdArr(), outlineBorder[dir]['height']);
                        tableBorder.changeBorderType(self.getTdArr(), outlineBorder[dir]['type']);
                    });
                }
            },
            /**
             * border style을 파싱해서 object로 반환한다.
             *
             * ex1. "1px solid red"
             * ex2. "none"
             *
             * @param styleString
             * @returns {object}
             * @private
             */
            _parseBorderStyle: function(styleString) {
                styleString = styleString.trim().toLowerCase();
                if (styleString === 'none') {
                    return {
                        height: 'none',
                        type: 'solid',
                        color: 'transparent'
                    };
                } else {
                    var parts = styleString.split(' ');
                    if (parts.length != 3) {
                        parts = ['1px', 'solid', '#000'];
                    }
                    return {
                        height: parts[0].parsePx() || 1,
                        type: parts[1],
                        color: parts[2]
                    };
                }
            }
        };

        toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
            color: borderProperty.color,
            height: borderProperty.height,
            type: borderProperty.type,
            fromInit: _TRUE
        });

        toolbar.observeJob(Trex.Ev.__TOOL_CLICK, function(identity) {
            if ([
                    "fontfamily",
                    "fontsize",
                    "bold",
                    "underline",
                    "italic",
                    "strike",
                    "forecolor",
                    "backcolor",
                    "indent",
                    "outdent",
                    "alignleft",
                    "aligncenter",
                    "alignright",
                    "alignfull",
                    "mergecells",
                    "splitcells",
                    "insertcells",
                    "deletecells",
                    "cellsoutline",
                    "cellslinecolor",
                    "cellslineheight",
                    "cellslinestyle",
                    "cellslinepreview",
                    "tablebackcolor",
                    "tabletemplate"
                ].contains(identity) === _FALSE) {
                tableSelect.reset();
            } else {
                tableSelect.hideContextMenu();
            }
            if (identity === "tablebackcolor") {
                selectCellByCaret();
            }
        });
    });
});

TrexMessage.addMsg({
    '@contextmenu.table.cellcopy': Trex._I18N.g('contextmenu.table.cellcopy', "셀 복사"),
    '@contextmenu.table.cellpaste': Trex._I18N.g('contextmenu.table.cellpaste', "셀 붙여넣기"),
    '@contextmenu.table.insertrowabove': Trex._I18N.g('contextmenu.table.insertrowabove', "위에 행 추가"),
    '@contextmenu.table.insertrowbelow': Trex._I18N.g('contextmenu.table.insertrowbelow', "아래에 행 추가"),
    '@contextmenu.table.insertcolleft': Trex._I18N.g('contextmenu.table.insertcolleft', "왼쪽에 열 추가"),
    '@contextmenu.table.insertcolright': Trex._I18N.g('contextmenu.table.insertcolright', "오른쪽에 열 추가"),

    '@contextmenu.table.deletetable': Trex._I18N.g('contextmenu.table.deletetable', "표 삭제"),
    '@contextmenu.table.deleterow': Trex._I18N.g('contextmenu.table.deleterow', "행 삭제"),
    '@contextmenu.table.deletecol': Trex._I18N.g('contextmenu.table.deletecol', "열 삭제"),

    '@contextmenu.table.cellmerge': Trex._I18N.g('contextmenu.table.cellmerge', "셀 병합"),
    '@contextmenu.table.cellsplit': Trex._I18N.g('contextmenu.table.cellsplit', "셀 나누기"),

    '@contextmenu.table.samewidth': Trex._I18N.g('contextmenu.table.samewidth', "셀 너비 같게"),
    '@contextmenu.table.sameheight': Trex._I18N.g('contextmenu.table.sameheight', "셀 높이 같게"),
    '@contextmenu.table.samewh': Trex._I18N.g('contextmenu.table.samewh', "셀 너비/높이 같게"),

    '@contextmenu.table.propcell': Trex._I18N.g('contextmenu.table.propcell', "셀 속성"),
    '@contextmenu.table.proptable': Trex._I18N.g('contextmenu.table.proptable', "표 속성")
});

TrexMessage.addMsg({
    '@table.popup.ok': Trex._I18N.g('table.popup.ok', "확인"),
    '@table.popup.cancel': Trex._I18N.g('table.popup.cancel', "취소"),
    '@table.popup.cellsplit.rowinsert': Trex._I18N.g('table.popup.cellsplit.rowinsert', "행 추가"),
    '@table.popup.cellsplit.columninsert': Trex._I18N.g('table.popup.cellsplit.columninsert', "열 추가"),
    '@table.popup.cellattr.lineselect': Trex._I18N.g('table.popup.cellattr.lineselect', "테두리 선택"),
    '@table.popup.cellattr.h_align': Trex._I18N.g('table.popup.cellattr.h_align', "수평정렬"),
    '@table.popup.cellattr.v_align': Trex._I18N.g('table.popup.cellattr.v_align', "수직정렬")
});

/**
 * 컨텍스트 메뉴 설정
 * label: 구분을 위한 라벨링
 * title: 메뉴명
 * icon: 아이콘명 (경로는 css/trex/editor/contextmenu.css에 설정되어 있음)
 * eventname: Canvas.processor.table에 매칭시킬 함수명
 * check: select(셀이 선택되야만 메뉴 선택가능), no-select(셀이 선택되지 않아야 메뉴 선택가능),
 * 		select_row (여러 행이 선택되야만 메뉴 선택 가능)
 */
TrexConfig.addContextMenu(
    'table', {
        options: [
            { label: Trex._I18N.g('table-insert', "삽입"), title: TXMSG('@contextmenu.table.insertrowabove'), icon: "tabletopinsert", eventname: "insertRowAbove" },
            { label: Trex._I18N.g('table-insert', "삽입"), title: TXMSG('@contextmenu.table.insertrowbelow'), icon: "tablebottominsert", eventname: "insertRowBelow" },
            { label: Trex._I18N.g('table-insert', "삽입"), title: TXMSG('@contextmenu.table.insertcolleft'), icon: "tableleftinsert", eventname: "insertColLeft" },
            { label: Trex._I18N.g('table-insert', "삽입"), title: TXMSG('@contextmenu.table.insertcolright'), icon: "tablerightinsert", eventname: "insertColRight" },
            { label: Trex._I18N.g('table-sepa', "구분"), title: "sepa" },
            { label: 'copy_paste', title: TXMSG('@contextmenu.table.cellcopy'), icon: "tablecellcopy", eventname: "cellCopy" },
            { label: 'copy_paste', title: TXMSG('@contextmenu.table.cellpaste'), icon: "tablecellpaste", eventname: "cellPaste" , check:'cell_paste'},
            { label: 'copy_paste', title: "sepa" },
            { label: Trex._I18N.g('table-delete', "삭제"), title: TXMSG('@contextmenu.table.deletetable'), icon: "tabledelete", eventname: "deleteTable" },
            { label: Trex._I18N.g('table-delete', "삭제"), title: TXMSG('@contextmenu.table.deleterow'), icon: "tablerowdelete", eventname: "deleteRow" },
            { label: Trex._I18N.g('table-delete', "삭제"), title: TXMSG('@contextmenu.table.deletecol'), icon: "tablecolumndelete", eventname: "deleteCol" },
            { label: Trex._I18N.g('table-sepa', "구분"), title: "sepa" },
            { label: Trex._I18N.g('table-merge', "병합"), title: TXMSG('@contextmenu.table.cellmerge'), icon: "tablecellmerge", eventname: "merge", check: "select" },
            { label: Trex._I18N.g('table-split', "분할"), title: TXMSG('@contextmenu.table.cellsplit'), icon: "tablecellsplit", check: "no_select", popup: "CellSplit" },
            { label: Trex._I18N.g('table-sepa', "구분"), title: "sepa" },
            { label: Trex._I18N.g('table-same', "조정"), title: TXMSG('@contextmenu.table.samewidth'), icon: "tablesamecolumn", eventname: "sameWidth", check: "select_cols" },
            { label: Trex._I18N.g('table-same', "조정"), title: TXMSG('@contextmenu.table.sameheight'), icon: "tablesamerow", eventname: "sameHeight", check: "select_rows" },
            { label: Trex._I18N.g('table-sepa', "구분"), title: "sepa" },
            { label: Trex._I18N.g('table-attr', "속성"), title: TXMSG('@contextmenu.table.propcell'), icon: "tablecellattribute", popup: "CellAttr" },
            { label: Trex._I18N.g('table-attr', "속성"), title: TXMSG('@contextmenu.table.proptable'), icon: "table", popup: "TableAttr" }
        ]
    }
);
Trex.MarkupTemplate.add(
    'contextmenu.table.popup.cellsplit', [
        '<div class="cell_split_prop cell_prop">',
        '	<dl>',
        '		<dt><label><input type="radio" name="split_type" class="rdo" value="row_split"/> ' + TXMSG('@table.popup.cellsplit.rowinsert') + '</label></dt>',
        '		<dd><span class="g_select"><input type="text" name="split_row" class="txt txt_sel" value="2"/>' +
        '<button class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span><span class="bg ico_col">행 분할 설명 이미지</span></dd>',
        '		</dl>',
        '	<dl>',
        '		<dt><label><input type="radio" name="split_type" class="rdo" value="col_split"/> ' + TXMSG('@table.popup.cellsplit.columninsert') + '</label></dt>',
        '		<dd><span class="g_select"><input type="text" name="split_col" class="txt txt_sel disable" value="2"/>' +
        '<button class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span><span class="bg ico_row">열 분할 설명 이미지</span></dd>',
        '	</dl>',
        '</div>',
        '<div class="layer_bottom">',
        '	<button class="btn btn_ok">' + TXMSG('@table.popup.ok') + '</button>',
        '	<button class="btn btn_cancel">' + TXMSG('@table.popup.cancel') + '</button>',
        '</div>'
    ].join('')
);
Trex.MarkupTemplate.add(
    'contextmenu.table.popup.cellattr', [
        '<div class="cell_prop">',
        // '	<div class="g_divide g_float line-bottom">',
        // '		<dl>',
        // '			<dt>' + Trex._I18N.g('cellattr_width', '너비') + '</dt>',
        // '			<dd><span class="g_select"><input type="text" name="" class="txt txt_sel" /><button class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가')
        //+ '</button><button class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제')
        //+ '</button></span></dd>',
        // '		</dl>',
        // '		<dl>',
        // '			<dt>' + Trex._I18N.g('cellattr_height', '높이') + '</dt>',
        // '			<dd><span class="g_select"><input type="text" name="" class="txt txt_sel" /><button class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가')
        //+ '</button><button class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제')
        //+ '</button></span></dd>',
        // '		</dl>',
        // '	</div>',
        '	<dl>',
        '		<dt>' + Trex._I18N.g('table.detail.border_style', '테두리 스타일') + '</dt>',
        '		<dd class="g_line_dd"><span class="g_line"><span class="line_style line1"></span><button name="btn_border_style" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        '</button></span>',
        '			<ul class="line_style_option" style="display:none;">',
        '			#{for:line}<li class="#{class}" data-style="#{style}"><a href="javascript:;"></a></li>#{/for:line}',
        '			</ul>',
        '		</dd>',
        '	</dl>',
        '	<dl>',
        '		<dt>' + Trex._I18N.g('table.detail.border_line', '테두리 두께') + '</dt>',
        '		<dd><span class="g_select"><input type="text" name="txt_border_line" class="txt txt_sel" /><button name="btn_line_up" class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span></dd>',
        '	</dl>',
        '	<dl>',
        '		<dt>' + Trex._I18N.g('table.detail.border_color', '테두리 색') + '</dt>',
        '		<dd><input type="text" name="txt_border_color" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '			<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '		</dd>',
        '	</dl>',
        '	<dl class="line-bottom">',
        '		<dt>' + Trex._I18N.g('table.detail.cell_bg', '셀 배경색') + '</dt>',
        '		<dd><input type="text" name="txt_cell_bg" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '			<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '		</dd>',
        '	</dl>',
        '	<dl class="line-bottom">',
        '		<dt>' + Trex._I18N.g('table.popup.cellattr.lineselect', '테두리 선택') + '</dt>',
        '		<dd class="clear">',
        '			<ul class="cell_border">',
        '				<li><button name="btn_border1" class="bg btn btn_border1">' + Trex._I18N.g('cellattr.btn_border1', '테두리없음') + '</button><em>' + Trex._I18N.g('cellattr.btn_border1.txt', '없음') + '</em></li>',
        '				<li><button name="btn_border2" class="bg btn btn_border2">' + Trex._I18N.g('cellattr.btn_border2', '모든 테두리') + '</button><em>' + Trex._I18N.g('cellattr.btn_border2.txt', '전체') + '</em></li>',
        '				<li><button name="btn_border3" class="bg btn btn_border3">' + Trex._I18N.g('cellattr.btn_border3', '바깥쪽 테두리') + '</button><em>' + Trex._I18N.g('cellattr.btn_border3.txt', '바깥쪽') + '</em></li>',
        '				<li><button name="btn_border4" class="bg btn btn_border4">' + Trex._I18N.g('cellattr.btn_border4', '안쪽 테두리') + '</button><em>' + Trex._I18N.g('cellattr.btn_border4.txt', '안쪽') + '</em></li>',
        '			</ul>',
        '			<div class="view_border">',
        '				<table>',
        '					<colgroup>',
        '						<col style="width:50%;" />',
        '						<col style="width:50%;" />',
        '					</colgroup>',
        '					<tr>',
        '						<td class="top left middle center"></td>',
        '						<td class="top right middle"></td>',
        '					</tr>',
        '					<tr>',
        '						<td class="bottom left center"></td>',
        '						<td class="bottom right"></td>',
        '					</tr>',
        '				</table>',
        '				<button name="btn_border_top" class="bg btn btn_top">' + Trex._I18N.g('cellattr.align.top', '위') + '</button>',
        '				<button name="btn_border_middle" class="bg btn btn_middle">' + Trex._I18N.g('cellattr.align.middle', '중간') + '</button>',
        '				<button name="btn_border_bottom" class="bg btn btn_bottom">' + Trex._I18N.g('cellattr.align.bottom', '아래') + '</button>',
        '				<button name="btn_border_left" class="bg btn btn_left">' + Trex._I18N.g('cellattr.align.left', '왼쪽') + '</button>',
        '				<button name="btn_border_center" class="bg btn btn_center">' + Trex._I18N.g('cellattr.align.center', '가운데') + '</button>',
        '				<button name="btn_border_right" class="bg btn btn_right">' + Trex._I18N.g('cellattr.align.right', '오른쪽') + '</button>',
        '			</div>',
        '		</dd>',
        '	</dl>',
        '	<dl>',
        '		<dt>' + Trex._I18N.g('table.popup.cellattr.h_align', '수평정렬') + '</dt>',
        '		<dd>',
        '			<span class="g_align"><span class="align_text">' + /*Trex._I18N.g('cellattr.align.default','안함') + */ '</span><button name="btn_text_align" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        '</button></span>',
        '			<ul class="align_option" style="display:none;">',
        '				<li data-style="">' + /* Trex._I18N.g('cellattr.align.default','안함') +*/ '</li>',
        '				<li data-style="left">' + Trex._I18N.g('cellattr.align.left', '왼쪽') + '</li>',
        '				<li data-style="center">' + Trex._I18N.g('cellattr.align.center', '가운데') + '</li>',
        '				<li data-style="right">' + Trex._I18N.g('cellattr.align.right', '오른쪽') + '</li>',
        '			</ul>',
        '		</dd>',
        '	</dl>',
        '	<dl class="line-bottom">',
        '		<dt>' + Trex._I18N.g('table.popup.cellattr.v_align', '수직정렬') + '</dt>',
        '		<dd>',
        '			<span class="g_align"><span class="align_text">' + /* Trex._I18N.g('cellattr.align.default','안함') +*/ '</span><button name="btn_vertical_align" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        '</button></span>',
        '			<ul class="align_option" style="display:none;">',
        '				<li data-style="">' + /* Trex._I18N.g('cellattr.align.default','안함') + */ '</li>',
        '				<li data-style="top">' + Trex._I18N.g('cellattr.align.top', '위쪽') + '</li>',
        '				<li data-style="middle">' + Trex._I18N.g('cellattr.align.middle', '중앙') + '</li>',
        '				<li data-style="bottom">' + Trex._I18N.g('cellattr.align.bottom', '아래쪽') + '</li>',
        '			</ul>',
        '		</dd>',
        '	</dl>',
        '	<dl>',
        '		<dt>' + Trex._I18N.g('table.detail.cell_padding', '셀 여백') + '</dt>',
        '		<dd><span class="g_select"><input type="text" name="txt_cell_padding" class="txt txt_sel" /><button name="btn_cell_padding_up" class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_cell_padding_down" class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span></dd>',
        '	</dl>',
        '</div>',
        '<div class="layer_bottom">',
        '	<button class="btn btn_ok">' + TXMSG('@table.popup.ok') + '</button>',
        '	<button class="btn btn_cancel">' + TXMSG('@table.popup.cancel') + '</button>',
        '<div>'
    ].join('')
);

Trex.MarkupTemplate.add(
    'contextmenu.table.popup.tableattr', [
        '	<div class="cell_prop table_prop">',
        '		<dl class="line-bottom">',
        '			<dt class="tit"><label><input type="radio" name="rdo_table_style" class="rdo" value="custom" checked /> <strong style="cursor:pointer;">@table.detail.menual</strong></label></dt>',
        '			<dd class="clear depth2">',
        '				<dl>',
        '					<dt>@table.detail.border_style</dt>',
        '					<dd class="g_line_dd">',
        '						<span class="g_line"><span class="line_style line1"></span><button name="btn_border_style" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') + '</button></span>',
        '						<ul class="line_style_option" style="display:none;">',
        '							#{for:line}<li class="#{class}" data-style="#{style}"><a href="javascript:;"></a></li>#{/for:line}',
        '						</ul>',
        '					</dd>',
        '				</dl>',
        '				<dl>',
        '					<dt>@table.detail.border_line</dt>',
        '					<dd><span class="g_select"><input type="text" name="txt_border_line" class="txt txt_sel" /><button name="btn_line_up" class="bg btn btn_up_arrow">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow">' + Trex._I18N.g('btn_down_arrow', '삭제') + '</button></span></dd>',
        '				</dl>',
        '				<dl>',
        '					<dt>@table.detail.border_color</dt>',
        '					<dd><input type="text" name="txt_border_color" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '						<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '					</dd>',
        '				</dl>',
        '				<dl>',
        '					<dt>@table.detail.cell_bg</dt>',
        '					<dd><input type="text" name="txt_cell_bg" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '						<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '					</dd>',
        '				</dl>',
        '			</dd>',
        '		</dl>',
        '		<dl class="table_style">',
        '			<dt class="tit"><label><input type="radio" name="rdo_table_style" class="rdo" value="style" /> <strong class="s_disabled" style="cursor:pointer;">@table.detail.style</strong></label></dt>',
        '			<dd>',
        '				<span class="g_style"><span class="td_style style1"></span><button name="btn_table_style" class="bg btn btn_down_arrow2">' + Trex._I18N.g('btn_down_arrow2', '펼치기') + '</button></span>',
        '				<ul class="td_style_option" style="display:none;">',
        '					#{for:items}<li><span class="td_style #{text}" data-style="#{style}">#{text}</span></li>#{/for:items}',
        '				</ul>',
        '			</dd>',
        '		</dl>',
        '		<div class="custom_block"></div>',
        '		<div class="style_block"></div>',
        '	</div>',
        '	<div class="layer_bottom">',
        '		<button name="btn_detail_ok" class="btn btn_ok">@table.detail.ok</button>',
        '		<button name="btn_detail_cancel" class="btn btn_cancel">@table.detail.cancel</button>',
        '	<div>'
    ].join("")
);

Trex.Table.ContextMenu = Trex.Class.create({
    initialize: function(editor, tableSelect, rootConfig) {
        this._initializedId = ((rootConfig.initializedId) ? rootConfig.initializedId : "");
        this.config = rootConfig;
        this.menus = TrexConfig.getContextMenu('table').options;
        this.editor = editor;
        this.canvas = tableSelect.canvas;
        this.tableSelect = tableSelect;
        this.elContextMenu = document.getElementById('tx_contextmenu_div' + this._initializedId);
        this.elEditorBlockUI = document.getElementById('tx_editor_blockui' + this._initializedId);
        this.generateContextMenu();
        this.observeEvent();
        this.elPopup = {
            CellSplit: _NULL,
            CellProp: _NULL,
            TableProp: _NULL
        }

        _WIN.context = this;
    },
    /**
     * 컨텍스트 메뉴의 HTML을 생성한다
     */
    generateContextMenu: function() {
        var self = this;
        var menu, icon, text;
        var _ul = $(this.elContextMenu).find('ul');
        $.each(this.menus, function(idx, obj) {
            menu = $('<li class="tx-contextmenu ' + (obj.title == 'sepa' ? 'sepa' : 'menu') + '"></li>');
            var aWrapper = null;
            if (obj.title != 'sepa' && $tx.msie && document.documentMode < 8) {
                aWrapper = $('<a href="javascript:;" class="tx-contextmenu_a"></a>');
                menu.append(aWrapper);
            }
            if (obj.title != 'sepa') {
                icon = $('<div class="ts-contextmenu-icon' + (typeof(obj.icon) ? ' ' + obj.icon : '') + '"></div>');
                text = $('<span>' + obj.title + '</span>');
                menu.data('eventname', obj.eventname)
                    .data('popupname', obj.popup);
                (aWrapper ? aWrapper : menu).append(icon).append(text);

                if (obj.check) {
                    menu.addClass(obj.check == 'select' ? 'check1' :
                        obj.check == 'select_rows' ? 'check3' :
                        obj.check == 'select_cols' ? 'check4' :
                        obj.check == 'cell_paste' ? 'check5' :
                        'check2');
                }
            }

            $(_ul).append(menu);
        });
    },
    createColorPallete: function(element, fn, inputHidden, elInput, elPreview) {
        var self = this;
        var pallete = new Trex.Menu.ColorPallete({
            el: element,
            thumbs: Trex.__CONFIG_COMMON.thumbs,
            colorInputHidden: inputHidden
        });
        pallete.setCommand(fn);
        return pallete;
    },
    showContextMenu: function(e) {
        var canvas_top = $(this.canvas.elContainer).offset().top - $(this.editor.getWrapper()).offset().top,
            canvas_left = $(this.canvas.elContainer).offset().left - $(this.editor.getWrapper()).offset().left,
            canvas_width = $(this.canvas.elContainer).width(),
            canvas_height = $(this.canvas.elContainer).height(),
            // pointerX = $tx.pointerX(e) + 5,
            // pointerY = $tx.pointerY(e) + 5,
            pointerX = e.clientX + 5,
            pointerY = e.clientY + 5,
            context_top = pointerY + canvas_top,
            context_left = pointerX + canvas_left,
            context_width = $(this.elContextMenu).outerWidth(),
            context_height = $(this.elContextMenu).outerHeight(),
            overflow_width = context_width + pointerX - canvas_width,
            overflow_height = context_height + pointerY - canvas_height;
        if (overflow_height > 0) {
            context_top -= overflow_height;
        }

        if (overflow_width > 0) {
            //context_left -= overflow_width;
            context_left -= context_width + 10; //마우스 왼쪽으로 띄우기
        }

        context_top = (context_top < 0 ? 0 : context_top);
        context_left = (context_left < 0 ? 0 : context_left);

        this.elContextMenu.style.top = context_top.toPx();
        this.elContextMenu.style.left = context_left.toPx();

        var chk1 = $(this.elContextMenu).find('.check1');
        var chk2 = $(this.elContextMenu).find('.check2');
        var chk3 = $(this.elContextMenu).find('.check3');
        var chk4 = $(this.elContextMenu).find('.check4');
        var chk5 = $(this.elContextMenu).find('.check5');

        //셀을 선택하지 않은 경우 해당 셀 선택처리
        if (!this.tableSelect.getSelected().isValid()) {
            if (this.tableSelect.currentTable != null) {
                this.tableSelect.selectEnd(this.tableSelect.currentTd);
                this.tableSelect.applySelected();
            } else {
                return;
            }
        }
        if (this.tableSelect.getSelectedTdArr().length > 1) {
            //셀 여러개 선택시
            $(chk1).removeClass('disable');
            $(chk2).addClass('disable');
            var sTr = this.tableSelect.getSelectedTrArr(false).selectedTr;
            $(chk3)[sTr.length > 1 ? 'removeClass' : 'addClass']('disable');
            $(chk4)[sTr.length > 0 && sTr[0].cells.length > 1 ? 'removeClass' : 'addClass']('disable');
        } else {
            //셀 하나 선택시
            $(chk1).addClass('disable');
            $(chk2).removeClass('disable');
            $(chk3).addClass('disable');
            $(chk4).addClass('disable');
        }
        var _cellCopy = Trex.Table.CellCopy.instance;
        $(chk5)[_cellCopy && _cellCopy.hasCell()?'removeClass':'addClass']('disable');
        // var range = this.canvas.getProcessor().createGoogRange();
        // this.savedCaret = range.saveUsingCarets();
        $tx.show(this.elContextMenu);
    },
    hideContextMenu: function() {
        $tx.hide(this.elContextMenu);
    },
    showPopup: function(name) {
        //팝업 HTML initialize
        if (!this.elPopup[name]) this.elPopup[name] = this.generatePopupHtml(name);

        //BlockUI 처리
        $tx.show(this.elEditorBlockUI);

        //팝업창 Canvas영역 중앙에 표시
        var $container = $(this.canvas.elContainer),
            $popup = $(this.elPopup[name]);

        var canvas_w = $container.outerWidth(),
            canvas_h = $container.outerHeight(),
            popup_w = $popup.outerWidth(),
            popup_h = $popup.outerHeight(),
            left = (Math.ceil(canvas_w / 2) - Math.ceil(popup_w / 2)) + $container.position().left,
            top = (Math.ceil(canvas_h / 2) - Math.ceil(popup_h / 2)) + $container.position().top;

        $popup.css({ 'top': top, 'left': left });

        //팝업 오픈 처리
        this.hideContextMenu();
        $tx.show(this.elPopup[name]);
    },
    hidePopup: function(name) {
        //BlockUI 처리
        $tx.hide(this.elEditorBlockUI);

        //팝업 클로즈 처리
        if (name) {
            $tx.hide(this.elPopup[name]);
        } else {
            $.each(this.elPopup, function(key, val) {
                (val != _NULL ? $tx.hide(this) : '');
            });
        }
        Editor.focus();
    },
    observeEvent: function() {
        var self = this;

        //컨텍스트 메뉴 제어
        this.canvas.observeJob(Trex.Ev.__CANVAS_CONTEXTMENU_SHOW, function(e) {
            var _el = $tx.findElement(e, 'table');
            var _el_img = $tx.findElement(e, 'img');
            if(_el_img&&_el_img.tagName && _el_img.tagName.toLowerCase() == "img"){
            }else if (_el.tagName && _el.tagName.toLowerCase() == 'table') {
                self.showContextMenu(e);
                $tx.stop(e);
            } else {
                self.tableSelect.onmousedown($tx.element(e), e);
            }
        });

        //각 메뉴에 이벤트 bind
        $(this.elContextMenu).find('li')
            .on('mousedown', function(e) { e.preventDefault(); }) //포커싱 제어
            .on('click', function(e) {
                if ($(this).hasClass('disable')) return;
                if ($(this).data('popupname')) {
                    self.showPopup($(this).data('popupname'));
                    e.preventDefault();
                    return;
                }

                var ev_name = $(this).data('eventname');
                var processor = self.canvas.getProcessor();
                if (processor.table[ev_name]) {
                    processor.table[ev_name]();
                } else if (self[ev_name]) {
                    self[ev_name]();
                }
                // var endCaret = self.savedCaret.getCaret(_FALSE);
                // if(endCaret) processor.moveCaretTo(endCaret, 0, _FALSE);
                e.preventDefault();
            });

        //BlockUI 이벤트 bind
        $(this.elEditorBlockUI).on('mousedown', function(e) { return false; });
    },
    generatePopupHtml: function(name) {
        var el, html, nm;
        nm = name.toLowerCase();
        el = document.getElementById(nm + '_wrap' + this._initializedId);
        var tableStyle = {};
        if (nm == 'cellattr' || nm == 'tableattr') {
            tableStyle.line = [
                { "class": 'line1', "style": 'solid' },
                { "class": 'line2', "style": 'dotted' },
                { "class": 'line3', "style": 'double' }
            ];
        }
        if (nm == 'tableattr') {
            tableStyle.items = [];
            for (var i = 1; i <= 45; i++) {
                tableStyle.items.push({ text: 'style' + i, style: i });
            }
        }
        Trex.MarkupTemplate.get("contextmenu.table.popup." + nm).evaluateToDom(tableStyle, el);
        this.popupObserveEvent(el, name);

        return el;
    },
    popupObserveEvent: function(el, name) {
        var self = this;
        var ok = $(el).find('.btn_ok');
        var cancel = $(el).find('.btn_cancel');

        /***************  셀 나누기 이벤트 시작 ***************/
        if (name == 'CellSplit') {
            var split_type = 'row'; //기본값 : Row(행 나누기)

            //이벤트 대상 Element
            var rdo_row = $(el).find('input[name=split_type]:eq(0)'),
                rdo_col = $(el).find('input[name=split_type]:eq(1)'),
                txt_row = $(el).find('input[name=split_row]'),
                txt_col = $(el).find('input[name=split_col]'),
                btn_row_up = $(el).find('button.btn_up_arrow:eq(0)'),
                btn_row_dn = $(el).find('button.btn_down_arrow:eq(0)'),
                btn_col_up = $(el).find('button.btn_up_arrow:eq(1)'),
                btn_col_dn = $(el).find('button.btn_down_arrow:eq(1)');

            //기본값 설정 함수
            var defaultSetting = function() {
                (split_type == 'row' ? rdo_row.click() : rdo_col.click());
                txt_row.val(2);
                txt_col.val(2);
            }

            //Validation Check
            var validCheck = function(num) {
                if (isNaN(num)) {
                    alert(Trex._I18N.g('num_validation', "입력된 값이 숫자가 아닙니다. 2~10 사이로 입력해주세요"));
                    return false;
                } else if (num < 2 || num > 10) {
                    alert(Trex._I18N.g('num_validation_2-10', "2~10 사이로 입력해주세요"));
                    return false;
                } else {
                    return true;
                }
            }

            rdo_row.on('click', function() {
                txt_row.removeClass('disable').prop('readOnly', false);
                txt_col.addClass('disable').prop('readOnly', true);
                btn_row_up.prop('disabled', false);
                btn_row_dn.prop('disabled', false);
                btn_col_up.prop('disabled', true);
                btn_col_dn.prop('disabled', true);
            });

            rdo_col.on('click', function() {
                txt_row.addClass('disable').prop('readOnly', true);
                txt_col.removeClass('disable').prop('readOnly', false);
                btn_row_up.prop('disabled', true);
                btn_row_dn.prop('disabled', true);
                btn_col_up.prop('disabled', false);
                btn_col_dn.prop('disabled', false);
            });

            btn_row_up.on('click', function() {
                var num = parseInt(txt_row.val()) + 1;
                if (!validCheck(num)) return;
                txt_row.val(num);
            });

            btn_row_dn.on('click', function() {
                var num = parseInt(txt_row.val()) - 1;
                if (!validCheck(num)) return;
                txt_row.val(num);
            });

            btn_col_up.on('click', function() {
                var num = parseInt(txt_col.val()) + 1;
                if (!validCheck(num)) return;
                txt_col.val(num);
            });

            btn_col_dn.on('click', function() {
                var num = parseInt(txt_col.val()) - 1;
                if (!validCheck(num)) return;
                txt_col.val(num);
            });

            defaultSetting();

            ok.on('click', function() {
                var type = (rdo_row.prop('checked') ? 'row' : 'col');
                var num = (type == 'row' ? txt_row.val() : txt_col.val());
                if (!validCheck(num)) return;
                self.splitCells(type, parseInt(num));
                self.hidePopup(name);
                var td = self.tableSelect.currentTd;
                self.tableSelect.reset();
                defaultSetting();
                self.canvas.history.saveHistory();
                if ($tx.msie && td) self.canvas.getProcessor().selectFirstText(td);
            });

            cancel.on('click', function() {
                self.hidePopup(name);
                var td = self.tableSelect.currentTd;
                self.tableSelect.reset();
                defaultSetting();
                if ($tx.msie && td) self.canvas.getProcessor().selectFirstText(td);
            });
        }

        /*************** 셀 속성 이벤트 시작 ***************/
        if (name == 'CellAttr') {
            var _self = self;
            (function() {

                var btn_border_style = $(el).find('button[name=btn_border_style]'),
                    border_list = $(btn_border_style).closest('dd').find('ul:eq(0)'),
                    txt_border_line = $(el).find('input[name=txt_border_line]'),
                    btn_line_up = $(el).find('button[name=btn_line_up]'),
                    btn_line_dn = $(el).find('button[name=btn_line_down]'),
                    txt_border_color = $(el).find('input[name=txt_border_color]'),
                    btn_line_color = $(txt_border_color).next(),
                    span_line_color = $(btn_line_color).find('span'),
                    line_color_pal = $(btn_line_color).next(),
                    txt_cell_bg = $(el).find('input[name=txt_cell_bg]'),
                    btn_cell_bg = $(txt_cell_bg).next(),
                    span_cell_bg = $(btn_cell_bg).find('span'),
                    cell_bg_pal = $(btn_cell_bg).next(),
                    btn_border1 = $(el).find('button[name=btn_border1]'),
                    btn_border2 = $(el).find('button[name=btn_border2]'),
                    btn_border3 = $(el).find('button[name=btn_border3]'),
                    btn_border4 = $(el).find('button[name=btn_border4]'),
                    btn_border_top = $(el).find('button[name=btn_border_top]'),
                    btn_border_middle = $(el).find('button[name=btn_border_middle]'),
                    btn_border_bottom = $(el).find('button[name=btn_border_bottom]'),
                    btn_border_left = $(el).find('button[name=btn_border_left]'),
                    btn_border_center = $(el).find('button[name=btn_border_center]'),
                    btn_border_right = $(el).find('button[name=btn_border_right]'),
                    border_top = $(el).find('.view_border td.top'),
                    border_middle = $(el).find('.view_border td.middle'),
                    border_bottom = $(el).find('.view_border td.bottom'),
                    border_left = $(el).find('.view_border td.left'),
                    border_center = $(el).find('.view_border td.center'),
                    border_right = $(el).find('.view_border td.right'),
                    btn_text_align = $(el).find('button[name=btn_text_align]'),
                    text_align_list = $(btn_text_align).closest('dd').find('ul:eq(0)'),
                    btn_vertical_align = $(el).find('button[name=btn_vertical_align]'),
                    vertical_align_list = $(btn_vertical_align).closest('dd').find('ul:eq(0)'),
                    txt_cell_padding = $(el).find('input[name=txt_cell_padding]'),
                    btn_cell_padding_up = $(el).find('button[name=btn_cell_padding_up]'),
                    btn_cell_padding_dn = $(el).find('button[name=btn_cell_padding_down]');
                var _cellAtt = null;

                var _B = { T: 1, M: 2, B: 4, L: 8, C: 16, R: 32 };

                function _setBorder(_type, reset) {
                    var _BT = _cellAtt.borderStyle = (reset ? _type : _cellAtt.borderStyle ^ _type);
                    btn_border_top[(_BT & _B.T) != 0 ? "addClass" : "removeClass"]('on');
                    btn_border_middle[(_BT & _B.M) != 0 ? "addClass" : "removeClass"]('on');
                    btn_border_bottom[(_BT & _B.B) != 0 ? "addClass" : "removeClass"]('on');
                    btn_border_left[(_BT & _B.L) != 0 ? "addClass" : "removeClass"]('on');
                    btn_border_center[(_BT & _B.C) != 0 ? "addClass" : "removeClass"]('on');
                    btn_border_right[(_BT & _B.R) != 0 ? "addClass" : "removeClass"]('on');
                    var _on = "1px solid #666666";
                    var _off = "1px solid #c7c7c7";
                    border_top.css("border-top", (_BT & _B.T) != 0 ? _on : _off);
                    border_middle.css("border-bottom", (_BT & _B.M) != 0 ? _on : _off);
                    border_bottom.css("border-top", (_BT & _B.M) != 0 ? _on : _off);
                    border_bottom.css("border-bottom", (_BT & _B.B) != 0 ? _on : _off);
                    border_left.css("border-left", (_BT & _B.L) != 0 ? _on : _off);
                    border_center.css("border-right", (_BT & _B.C) != 0 ? _on : _off);
                    border_right.css("border-left", (_BT & _B.C) != 0 ? _on : _off);
                    border_right.css("border-right", (_BT & _B.R) != 0 ? _on : _off);
                }

                function initCellAtt() {
                    _cellAtt = {
                        lineStyle: 'solid',
                        lineWidth: '',
                        borderStyle: 0
                    };
                    _setBorder(_B.T | _B.M | _B.B | _B.L | _B.C | _B.R, true); // 기본 전체 선택
                }
                initCellAtt();
                var defaultSetting = function() {
                    $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                    $tx.hide(border_list.get(0));
                    var span = btn_border_style.closest('span');
                    span.find('.line_style').remove();
                    span.prepend('<span class="line_style line1"></span>');

                    _cellAtt.lineStyle = 'solid';
                    txt_border_line.get(0).value = "";
                    txt_border_color.get(0).value = '';
                    span_line_color.css('background', "#dfeef9");
                    txt_cell_bg.val('');
                    span_cell_bg.css('background', '#dfeef9');

                    span = btn_text_align.closest('span');
                    span.find('.align_text').remove();
                    span.prepend('<span class="align_text">' + /*Trex._I18N.g('cellattr.align.default','안함') + */ '</span>');

                    span = btn_vertical_align.closest('span');
                    span.find('.align_text').remove();
                    span.prepend('<span class="align_text">' + /*Trex._I18N.g('cellattr.align.default','안함') + */ '</span>');

                    txt_cell_padding.get(0).value = "";

                    initCellAtt();
                }

                function _closeSubLayer(_cur) {
                    if (_cur != btn_cell_bg && _self.cellPallete_c) _self.cellPallete_c.hide();
                    if (_cur != btn_line_color && _self.linePallete_c) _self.linePallete_c.hide();
                    if (_cur != btn_border_style) {
                        $(btn_border_style).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(border_list.get(0));
                    }
                    if (_cur != btn_text_align) {
                        $(btn_text_align).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(text_align_list.get(0));
                    }
                    if (_cur != btn_vertical_align) {
                        $(btn_vertical_align).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(vertical_align_list.get(0));
                    }
                }
                var validCheck = {
                    calculate: function(type, operand) {
                        var value = (type == 'line' ? (_cellAtt.lineWidth ? _cellAtt.lineWidth : 0) :
                            type == 'padding' ? (_cellAtt.padding ? _cellAtt.padding : 0) :
                            '');
                        var max = (type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                            type == 'padding' ? Trex.Menu.Table.MAX_PADDING :
                            '');
                        value = parseInt(value);
                        if (isNaN(value)) value = 1;
                        if (value + operand > max || value + operand < 0) {
                            if (type != 'line' && type != 'padding') alert(TXMSG("@table.alert"));
                            return value;
                        }
                        value = value + operand;
                        if (value < 0) value = 0;
                        return value.toString();
                    },
                    getValidValue: function(type, value, previousValue, obj) {
                        var max = (type == 'row' ? Trex.Menu.Table.MAX_ROW :
                            type == 'col' ? Trex.Menu.Table.MAX_COL :
                            type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                            type == 'padding' ? Trex.Menu.Table.MAX_PADDING :
                            '');
                        if (isNaN(value)) return previousValue;
                        if (value < 0 || value > max) {
                            value = value > max ? max : previousValue;
                            if (obj) obj.value = value;
                            alert(Trex._I18N.g('number.alert', '1', max.toString(), '1 이상 ' + max + ' 이하의 숫자만 입력 가능합니다.'));
                        }
                        return value;
                    },
                    validColor: function(type, color, previousValue) {
                        var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
                        if (m === _NULL || color.length > 8) {
                            return previousValue;
                        }
                        if (m[1].length == 3) {
                            //return "#" + m[1] + m[1];
                            return "#" + m[1].toLowerCase();
                        } else {
                            return "#" + m[1].toLowerCase();
                        }
                    }
                };
                //테두리 스타일
                btn_border_style.on('click', function() {
                    _closeSubLayer(btn_border_style);
                    if ($(this).hasClass('btn_down_arrow1')) {
                        $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                        if ($tx.ltie8 && $(border_list).data('ltie8') != 'true') {
                            $(border_list).data('dd', $(this).closest('dd'));
                            $('.cell_prop', el).append(border_list);
                            border_list.css('top', '30px');
                            border_list.css('right', '10px');
                            $(border_list).data('ltie8', 'true');
                        }
                        $tx.show(border_list.get(0));
                    } else {
                        $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(border_list.get(0));
                    }
                    return false;
                });
                btn_border_style.closest('span').on('click', function() {
                    btn_border_style.click();
                });
                border_list.find('li').on('click', function(el) {
                    var span = null;
                    if ($tx.ltie8) {
                        span = $(this).closest('ul').data('dd').find('.g_line:eq(0)');
                    } else {
                        span = $(this).closest('dd').find('.g_line:eq(0)');
                    }
                    var cls = $(this).attr('class');
                    var style = $(this).data('style');

                    if (!span.find('.line_style').hasClass(cls)) {
                        span.find('.line_style').remove();
                        span.prepend('<span class="line_style ' + cls + '"></span>');
                    }
                    _cellAtt.lineStyle = style;
                    btn_border_style.click();
                    el.preventDefault();
                });
                // 테두리 두께
                function setLineColor() {
                    if (_cellAtt.lineWidth != "" && _cellAtt.lineWidth != "0" && !_cellAtt.lineColor) {
                        _cellAtt.lineColor = "#ccc";
                        txt_border_color.val(_cellAtt.lineColor);
                    } else if (_cellAtt.lineWidth == "" || _cellAtt.lineWidth == "0") {
                        _cellAtt.lineColor = "";
                        txt_border_color.val(_cellAtt.lineColor);
                    }
                    if (!_cellAtt.lineColor) {
                        span_line_color.css('background', '#dfeef9');
                    } else {
                        span_line_color.css('background', _cellAtt.lineColor);
                    }
                }

                function setLineWidth() {
                    if (_cellAtt.lineColor != "" && !_cellAtt.lineWidth) {
                        _cellAtt.lineWidth = "1";
                        txt_border_line.val(_cellAtt.lineWidth);
                    } else if (_cellAtt.lineColor == "" && _cellAtt.lineWidth != "0") {
                        _cellAtt.lineWidth = "";
                        txt_border_line.val(_cellAtt.lineWidth);
                    }
                }
                // 테두리 두께
                txt_border_line.on('blur', function() {
                    this.value = _cellAtt.lineWidth = validCheck.getValidValue('line', this.value, '', this);
                    setLineColor();
                });
                txt_border_line.on('keyup', function() {
                    this.value = _cellAtt.lineWidth = validCheck.getValidValue('line', this.value, '', this);
                    setLineColor();
                });
                btn_line_up.on('click', function() {
                    txt_border_line.get(0).value = _cellAtt.lineWidth = validCheck.calculate('line', 1);
                    setLineColor();
                });
                btn_line_dn.on('click', function() {
                    txt_border_line.get(0).value = _cellAtt.lineWidth = validCheck.calculate('line', -1);
                    setLineColor();
                });
                // 테두리 색
                txt_border_color.on('blur', function() {
                    this.value = _cellAtt.lineColor = validCheck.validColor('line', this.value, '');
                    if (this.value == '') {
                        span_line_color.css('background', '#dfeef9');
                    } else {
                        span_line_color.css('background', this.value);
                    }
                    setLineWidth();
                });
                btn_line_color.on('click', function() {
                    _closeSubLayer(btn_line_color);
                    if (_self.linePallete_c == _NULL) {
                        if ($tx.ltie8) {
                            $('.cell_prop', el).append(line_color_pal);
                            $(line_color_pal).css('top', '80px');
                            $(line_color_pal).css('right', '10px');
                        }
                        _self.linePallete_c = _self.createColorPallete(line_color_pal.get(0), function(color) {
                            color = color.toLowerCase();
                            _cellAtt.lineColor = color;
                            txt_border_color.val(color);
                            if (color == '') {
                                span_line_color.css('background', '#dfeef9');
                            } else {
                                span_line_color.css('background', color);
                            }
                            setLineWidth();
                        }, false);
                    }
                    $tx.hide(border_list.get(0));
                    if (_self.cellPallete_c) _self.cellPallete_c.hide();
                    _self.linePallete_c.toggle();
                    _self.linePallete_c.remainColor(txt_border_color.val());
                    return false;
                });
                // 셀 배경색
                txt_cell_bg.on('blur', function() {
                    this.value = _cellAtt.cellColor = validCheck.validColor('cell', this.value, '');
                    if (this.value == '') {
                        span_cell_bg.css('background', '#dfeef9');
                    } else {
                        span_cell_bg.css('background', this.value);
                    }
                });
                btn_cell_bg.on('click', function() {
                    _closeSubLayer(btn_cell_bg);
                    if (_self.cellPallete_c == _NULL) {
                        if ($tx.ltie8) {
                            $('.cell_prop', el).append(cell_bg_pal);
                            $(cell_bg_pal).css('top', '105px');
                            $(cell_bg_pal).css('right', '10px');
                        }
                        _self.cellPallete_c = _self.createColorPallete(cell_bg_pal.get(0), function(color) {
                            color = color.toLowerCase();
                            _cellAtt.cellColor = color;
                            txt_cell_bg.val(color);
                            if (color == '') {
                                span_cell_bg.css('background', '#dfeef9');
                            } else {
                                span_cell_bg.css('background', color);
                            }
                        }, false);
                    }
                    $tx.hide(border_list.get(0));
                    if (_self.linePallete_c) _self.linePallete_c.hide();
                    _self.cellPallete_c.toggle();
                    _self.cellPallete_c.remainColor(txt_cell_bg.val());
                    return false;
                });
                // Border
                btn_border1.on('click', function() {
                    _setBorder(0, true);
                    return false;
                });
                btn_border2.on('click', function() {
                    _setBorder(_B.T | _B.M | _B.B | _B.L | _B.C | _B.R, true);
                    return false;
                });
                btn_border3.on('click', function() {
                    _setBorder(_B.T | _B.B | _B.L | _B.R, true);
                    return false;
                });
                btn_border4.on('click', function() {
                    _setBorder(_B.M | _B.C, true);
                    return false;
                });
                btn_border_top.on('click', function() {
                    _setBorder(_B.T);
                    return false;
                });
                btn_border_middle.on('click', function() {
                    _setBorder(_B.M);
                    return false;
                });
                btn_border_bottom.on('click', function() {
                    _setBorder(_B.B);
                    return false;
                });
                btn_border_left.on('click', function() {
                    _setBorder(_B.L);
                    return false;
                });
                btn_border_center.on('click', function() {
                    _setBorder(_B.C);
                    return false;
                });
                btn_border_right.on('click', function() {
                    _setBorder(_B.R);
                    return false;
                });
                //text-align
                btn_text_align.on('click', function() {
                    _closeSubLayer(btn_text_align);
                    if ($(this).hasClass('btn_down_arrow1')) {
                        $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                        if ($tx.ltie8 && $(text_align_list).data('ltie8') != 'true') {
                            $(text_align_list).data('dd', $(this).closest('dd'));
                            $('.cell_prop', el).append(text_align_list);
                            text_align_list.css('top', '231px');
                            text_align_list.css('right', '10px');
                            $(text_align_list).data('ltie8', 'true');
                        }
                        $tx.show(text_align_list.get(0));
                    } else {
                        $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(text_align_list.get(0));
                    }
                    return false;
                });
                btn_text_align.closest('span').on('click', function() {
                    btn_text_align.click();
                });
                text_align_list.find('li').on('click', function() {
                    var span = null;
                    if ($tx.ltie8) {
                        span = $(this).closest('ul').data('dd').find('.g_align:eq(0)');
                    } else {
                        span = $(this).closest('dd').find('.g_align:eq(0)');
                    }
                    var txt = $(this).html();
                    var style = $(this).data('style');
                    span.find('.align_text').remove();
                    span.prepend('<span class="align_text">' + txt + '</span>');
                    _cellAtt.textAlign = style;
                    btn_text_align.click();
                });
                //vertical-align
                btn_vertical_align.on('click', function() {
                    _closeSubLayer(btn_vertical_align);
                    if ($(this).hasClass('btn_down_arrow1')) {
                        $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                        if ($tx.ltie8 && $(vertical_align_list).data('ltie8') != 'true') {
                            $(vertical_align_list).data('dd', $(this).closest('dd'));
                            $('.cell_prop', el).append(vertical_align_list);
                            vertical_align_list.css('top', '255px');
                            vertical_align_list.css('right', '10px');
                            $(vertical_align_list).data('ltie8', 'true');
                        }
                        $tx.show(vertical_align_list.get(0));
                    } else {
                        $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(vertical_align_list.get(0));
                    }
                    return false;
                });
                btn_vertical_align.closest('span').on('click', function() {
                    btn_vertical_align.click();
                });
                vertical_align_list.find('li').on('click', function() {
                    var span = null;
                    if ($tx.ltie8) {
                        span = $(this).closest('ul').data('dd').find('.g_align:eq(0)');
                    } else {
                        span = $(this).closest('dd').find('.g_align:eq(0)');
                    }
                    var txt = $(this).html();
                    var style = $(this).data('style');
                    span.find('.align_text').remove();
                    span.prepend('<span class="align_text">' + txt + '</span>');
                    _cellAtt.verticalAlign = style;
                    btn_vertical_align.click();
                });
                // 셀 여백
                txt_cell_padding.on('blur', function() {
                    this.value = _cellAtt.padding = validCheck.getValidValue('padding', this.value, '', this);
                });
                txt_cell_padding.on('keyup', function() {
                    this.value = _cellAtt.padding = validCheck.getValidValue('padding', this.value, '', this);
                });
                btn_cell_padding_up.on('click', function() {
                    txt_cell_padding.get(0).value = _cellAtt.padding = validCheck.calculate('padding', 1);
                });
                btn_cell_padding_dn.on('click', function() {
                    txt_cell_padding.get(0).value = _cellAtt.padding = validCheck.calculate('padding', -1);
                });

                defaultSetting();
                ok.on('click', function() {
                    var info = _self.tableSelect.getSelectedTrArr(true);
                    var sArr = info.selectedTr;
                    var aArr = info.allTr;
                    var last_x, last_y;
                    last_x = sArr.length > 0 ? (sArr[0].cells[0].index + sArr[0].cells.length - 1) : 0;
                    last_y = (sArr[0] || { index: 0 }).index + sArr.length - 1;

                    function _getAdjacent(_d, index, cell, arr) {
                        var row_idx;
                        if (_d == 'top' || _d == 'bottom') {
                            row_idx = index + (_d == 'top' ? -1 : cell.rowSpan - 0);
                            if (row_idx < 0) return;
                            var row = aArr[row_idx];
                            if (!row) return;
                            for (var i = cell.index, max = cell.index - 0 + cell.colSpan; i < max; i++) {
                                var _c = row.cells[i];
                                if (_c && (_c.colSpan + i - 1) <= last_x) {
                                    arr.push(_c.cell);
                                }
                            }
                        } else if (_d == 'left' || _d == 'right') {
                            row_idx = index; // + (_d == 'left'?-1:cell.colSpan-0);
                            if (row_idx < 0) return;
                            var row = aArr[row_idx];
                            if (!row) return;
                            var cell_idx = cell.index + (_d == 'left' ? -1 : cell.colSpan - 0);
                            if (cell_idx < 0 || cell_idx > last_x) return;
                            for (var i = 0, max = cell.rowSpan; i < max; i++) {
                                var tr = aArr[row_idx + i];
                                if (!tr) break;
                                var _c = tr.cells[cell_idx];
                                if (_c && (_c.rowSpan + i + row_idx - 1) <= last_y) {
                                    arr.push(_c.cell);
                                }
                            }
                        }
                    }
                    var _border = {
                        _BT: { 'border-bottom': [], 'border-top': [] },
                        _BM: { 'border-bottom': [], 'border-top': [] },
                        _BB: { 'border-top': [], 'border-bottom': [] },
                        _BL: { 'border-right': [], 'border-left': [] },
                        _BC: { 'border-right': [], 'border-left': [] },
                        _BR: { 'border-left': [], 'border-right': [] }
                    };
                    var _is_set_border = (_cellAtt.borderStyle != (_B.T | _B.M | _B.B | _B.L | _B.C | _B.R) || _cellAtt.lineWidth != '');
                    var last_row = [],
                        last_row_index = null,
                        row_count = 0;
                    row_count = sArr.length;
                    for (var ri = 0, last = sArr.length - 1; ri <= last; ri++) {
                        var row = sArr[ri],
                            last_cell = null,
                            last_cell_index = 0;
                        last_row_index = row.index;
                        last_cell_index = row.cells[row.cells.length - 1].index;
                        for (var ci = 0; ci < row.cells.length; ci++) {
                            var cell = row.cells[ci];
                            var bb = null;
                            if (cell.cell) {
                                // background
                                if (_cellAtt.cellColor) {
                                    $(cell.cell.cell).css('background', _cellAtt.cellColor);
                                }
                                // text-align
                                if (_cellAtt.textAlign) {
                                    $(cell.cell.cell).css('text-align', _cellAtt.textAlign);
                                }
                                // vertical-align
                                if (_cellAtt.verticalAlign) {
                                    $(cell.cell.cell).css('vertical-align', _cellAtt.verticalAlign);
                                }
                                // padding
                                if (_cellAtt.padding) {
                                    $(cell.cell.cell).css('padding', _cellAtt.padding + 'px');
                                }
                            }
                            if (_is_set_border) {
                                if (ri == 0) { // _BT
                                    if (cell.cell) {
                                        _border._BT['border-top'].push(cell.cell.cell);
                                        _getAdjacent("top", row.index, cell.cell, _border._BT['border-bottom']);
                                    }
                                }
                                if (ri != 0) { // _BM
                                    if (cell.cell) {
                                        _border._BM['border-top'].push(cell.cell.cell);
                                        _getAdjacent("top", row.index, cell.cell, _border._BM['border-bottom']);
                                    }
                                }
                                if (ci == 0) { // _BL
                                    if (cell.cell) {
                                        _border._BL['border-left'].push(cell.cell.cell);
                                        _getAdjacent("left", row.index, cell.cell, _border._BL['border-right']);
                                    }
                                }
                                if (ci != 0) { // _BC
                                    if (cell.cell) {
                                        _border._BC['border-left'].push(cell.cell.cell);
                                        _getAdjacent("left", row.index, cell.cell, _border._BC['border-right']);
                                    }
                                }
                                if (cell.cell) last_cell = last_row[ci] = cell.cell;
                            }
                        }
                        // _BR : last_cell
                        if (_is_set_border && last_cell && last_cell.cell && (last_cell.index - 0 + last_cell.colSpan - 1) == last_cell_index) {
                            _border._BR['border-right'].push(last_cell.cell);
                            _getAdjacent("right", row.index, last_cell, _border._BR['border-left']);
                        }
                    }
                    if (_is_set_border && last_row) {
                        // _BB : last_row
                        for (var ti = 0; ti < last_row.length; ti++) {
                            var cell = last_row[ti];
                            if (cell.cell && (cell.rowIndex - 0 + cell.rowSpan - 1) == last_row_index) {
                                _border._BB['border-bottom'].push(cell.cell);
                                _getAdjacent("bottom", last_row_index, cell, _border._BB['border-top']);
                            }
                        }
                    }
                    // border
                    var _B_ = {
                        _BT: _B.T,
                        _BM: _B.M,
                        _BB: _B.B,
                        _BL: _B.L,
                        _BC: _B.C,
                        _BR: _B.R
                    };
                    for (var bt in _border) {
                        var border_css = '';
                        if ((_cellAtt.borderStyle & _B_[bt]) != 0 && _cellAtt.lineWidth != "") {
                            /* lineWidth가 설정된 경우 선택된 위치의 border만 적용 */
                            if (_cellAtt.lineWidth == "0") border_css = "0px";
                            else border_css = _cellAtt.lineWidth + 'px ' + _cellAtt.lineStyle + ' ' + _cellAtt.lineColor;
                        } else if (_cellAtt.borderStyle == 0) { // 전체 border값이 없을경우에만 border:0px을 줌.
                            /* 선택된 위치가 없는 경우(기본 전체 선택) 즉 모든 선택을 지운경우, lineWidth값에 무관하게 전체 border 0 */
                            border_css = "0px";
                        } else if ((_cellAtt.borderStyle & _B_[bt]) == 0 && _cellAtt.lineWidth == "") {
                            /* lineWidth가 ""이고 특정위치의 선택을 해제한 경우 해제된 위치만 border:0px;*/
                            border_css = "0px";
                        }
                        if (border_css != "") {
                            for (var bs in _border[bt]) {
                                for (var i = 0; i < _border[bt][bs].length; i++) {
                                    $(_border[bt][bs][i]).css(bs, border_css);
                                }
                            }
                        }
                    }
                    self.hidePopup(name);
                    var td = self.tableSelect.currentTd;
                    self.tableSelect.reset();
                    self.canvas.history.saveHistory();
                    defaultSetting();
                    if ($tx.msie && td) self.canvas.getProcessor().selectFirstText(td);
                });
                cancel.on('click', function() {
                    self.hidePopup(name);
                    var td = self.tableSelect.currentTd;
                    self.tableSelect.reset();
                    defaultSetting();
                    if ($tx.msie && td) self.canvas.getProcessor().selectFirstText(td);
                });
            })();
        }
        /*************** 테이블 속성 이벤트 시작 ***************/
        if (name == 'TableAttr') {
            var _self = self;
            (function() {
                var rdo_table_style = $(el).find('input[type=radio]'),
                    btn_border_style = $(el).find('button[name=btn_border_style]'),
                    border_list = $(btn_border_style).closest('dd').find('ul:eq(0)'),
                    txt_border_line = $(el).find('input[name=txt_border_line]'),
                    btn_line_up = $(el).find('button[name=btn_line_up]'),
                    btn_line_dn = $(el).find('button[name=btn_line_down]'),
                    txt_border_color = $(el).find('input[name=txt_border_color]'),
                    btn_line_color = $(txt_border_color).next(),
                    span_line_color = $(btn_line_color).find('span'),
                    line_color_pal = $(btn_line_color).next(),
                    txt_cell_bg = $(el).find('input[name=txt_cell_bg]'),
                    btn_cell_bg = $(txt_cell_bg).next(),
                    span_cell_bg = $(btn_cell_bg).find('span'),
                    cell_bg_pal = $(btn_cell_bg).next(),
                    btn_table_style = $(el).find('button[name=btn_table_style]'),
                    style_list = $(btn_table_style).closest('dd').find('ul:eq(0)');

                var _tableAtt = null;

                function initTableAtt() {
                    _tableAtt = {};
                }
                initTableAtt();
                var defaultSetting = function() {
                    //셀 배경색 및 기타설정
                    initTableAtt();

                    rdo_table_style.get(0).checked = true;
                    rdo_table_style.eq(0).next().removeClass('s_disabled');
                    rdo_table_style.eq(1).next().addClass('s_disabled');
                    $(el).find('.custom_block').hide();
                    $(el).find('.style_block').show();

                    var cell_bg = '#fff',
                        border_line = 1,
                        border_color = '#ccc';
                    // 기본값 제거
                    cell_bg = '';
                    border_line = '';
                    border_color = '';
                    _tableAtt.cellColor = cell_bg;
                    _tableAtt.lineWidth = border_line;
                    _tableAtt.lineColor = border_color;
                    _tableAtt.lineStyle = 'solid';

                    txt_cell_bg.val(cell_bg);
                    txt_cell_bg.closest('dd').find('span').css('background', cell_bg || '#dfeef9');
                    txt_border_line.val(border_line);
                    txt_border_color.val(border_color);
                    txt_border_color.closest('dd').find('span').css('background', border_color || '#dfeef9');

                    //테이블 스타일
                    var span = $(style_list).closest('dd').find('.g_style:eq(0)');
                    span.find('.td_style').remove();
                    span.prepend('<span class="td_style style1"></span>');
                    _tableAtt.tableStyle = '1';
                };

                function _closeSubLayer(_cur) {
                    if (_cur != btn_table_style) style_list.hide();
                    if (_cur != btn_border_style) {
                        $(btn_border_style).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(border_list.get(0));
                    }
                    if (_cur != btn_cell_bg && _self.cellPallete_t) _self.cellPallete_t.hide();
                    if (_cur != btn_line_color && _self.linePallete_t) _self.linePallete_t.hide();
                }
                var validCheck = {
                    calculate: function(type, operand) {
                        var value = (type == 'line' ? (_tableAtt.lineWidth ? _tableAtt.lineWidth : 0) :
                            '');
                        var max = (type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                            '');
                        value = parseInt(value);
                        if (isNaN(value)) value = 1;
                        if (value + operand > max || value + operand < 0) {
                            if (type != 'line' && type != 'padding') alert(TXMSG("@table.alert"));
                            return value;
                        }
                        value = value + operand;
                        if (value < 0) value = 0;
                        return value.toString();
                    },
                    getValidValue: function(type, value, previousValue, obj) {
                        var max = (type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                            '');
                        if (isNaN(value)) return previousValue;
                        if (value < 0 || value > max) {
                            value = value > max ? max : previousValue;
                            if (obj) obj.value = value;
                            alert(Trex._I18N.g('number.alert', '1', max.toString(), '1 이상 ' + max + ' 이하의 숫자만 입력 가능합니다.'));
                        }
                        return value;
                    },
                    validColor: function(type, color, previousValue) {
                        var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
                        if (m === _NULL || color.length > 8) {
                            return previousValue;
                        }
                        if (m[1].length == 3) {
                            //return "#" + m[1] + m[1];
                            return "#" + m[1].toLowerCase();
                        } else {
                            return "#" + m[1].toLowerCase();
                        }
                    }
                };
                // 라디오
                rdo_table_style.on('click', function() {
                    if (this.value == 'custom') {
                        $(this).next().removeClass('s_disabled');
                        rdo_table_style.eq(1).next().addClass('s_disabled');
                        $(el).find('.custom_block').hide();
                        $(el).find('.style_block').show();
                    } else {
                        $(this).next().removeClass('s_disabled');
                        rdo_table_style.eq(0).next().addClass('s_disabled');
                        $(el).find('.custom_block').show();
                        $(el).find('.style_block').hide();
                    }
                    _closeSubLayer(null);
                });

                //테두리 스타일
                btn_border_style.on('click', function() {
                    _closeSubLayer(btn_border_style);
                    if ($(this).hasClass('btn_down_arrow1')) {
                        $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                        if ($tx.ltie8 && $(border_list).data('ltie8') != 'true') {
                            $(border_list).data('dd', $(this).closest('dd'));
                            $('.cell_prop', el).append(border_list);
                            border_list.css('top', '58px');
                            border_list.css('right', '10px');
                            $(border_list).data('ltie8', 'true');
                        }
                        $tx.show(border_list.get(0));
                    } else {
                        $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                        $tx.hide(border_list.get(0));
                    }
                    return false;
                });
                btn_border_style.closest('span').on('click', function() {
                    btn_border_style.click();
                });
                border_list.find('li').on('click', function(el) {
                    var span = null;
                    if ($tx.ltie8) {
                        span = $(this).closest('ul').data('dd').find('.g_line:eq(0)');
                    } else {
                        span = $(this).closest('dd').find('.g_line:eq(0)');
                    }
                    var cls = $(this).attr('class');
                    var style = $(this).data('style');

                    if (!span.find('.line_style').hasClass(cls)) {
                        span.find('.line_style').remove();
                        span.prepend('<span class="line_style ' + cls + '"></span>');
                    }
                    _tableAtt.lineStyle = style;
                    btn_border_style.click();
                    el.preventDefault();
                });
                // 테두리 두께
                function tblSetLineColor() {
                    if (_tableAtt.lineWidth != "" && _tableAtt.lineWidth != "0" && !_tableAtt.lineColor) {
                        _tableAtt.lineColor = "#ccc";
                        txt_border_color.val(_tableAtt.lineColor);
                    } else if (_tableAtt.lineWidth == "" || _tableAtt.lineWidth == "0") {
                        _tableAtt.lineColor = "";
                        txt_border_color.val(_tableAtt.lineColor);
                    }
                    if (!_tableAtt.lineColor) {
                        span_line_color.css('background', '#dfeef9');
                    } else {
                        span_line_color.css('background', _tableAtt.lineColor);
                    }
                }

                function tblSetLineWidth() {
                    if (_tableAtt.lineColor != "" && !_tableAtt.lineWidth) {
                        _tableAtt.lineWidth = "1";
                        txt_border_line.val(_tableAtt.lineWidth);
                    } else if (_tableAtt.lineColor == "" && _tableAtt.lineWidth != "0") {
                        _tableAtt.lineWidth = "";
                        txt_border_line.val(_tableAtt.lineWidth);
                    }
                }
                // 테두리 두께
                txt_border_line.on('blur', function() {
                    this.value = _tableAtt.lineWidth = validCheck.getValidValue('line', this.value, /*_tableAtt.lineWidth*/ '', this);
                    tblSetLineColor();
                });
                txt_border_line.on('keyup', function() {
                    this.value = _tableAtt.lineWidth = validCheck.getValidValue('line', this.value, /*_tableAtt.lineWidth*/ '', this);
                    tblSetLineColor();
                });
                btn_line_up.on('click', function() {
                    txt_border_line.get(0).value = _tableAtt.lineWidth = validCheck.calculate('line', 1);
                    tblSetLineColor();
                });
                btn_line_dn.on('click', function() {
                    txt_border_line.get(0).value = _tableAtt.lineWidth = validCheck.calculate('line', -1);
                    tblSetLineColor();
                });
                // 테두리 색
                txt_border_color.on('blur', function() {
                    this.value = _tableAtt.lineColor = validCheck.validColor('line', this.value, /*_tableAtt.lineColor*/ '');
                    if (this.value == '') {
                        span_line_color.css('background', '#dfeef9');
                    } else {
                        span_line_color.css('background', this.value);
                    }
                    tblSetLineWidth();
                });
                btn_line_color.on('click', function() {
                    _closeSubLayer(btn_line_color);
                    if (_self.linePallete_t == _NULL) {
                        if ($tx.ltie8) {
                            $('.cell_prop', el).append(line_color_pal);
                            $(line_color_pal).css('top', '105px');
                            $(line_color_pal).css('right', '10px');
                        }
                        _self.linePallete_t = _self.createColorPallete(line_color_pal.get(0), function(color) {
                            color = color.toLowerCase();
                            _tableAtt.lineColor = color;
                            txt_border_color.val(color);
                            if (color == '') {
                                span_line_color.css('background', '#dfeef9');
                            } else {
                                span_line_color.css('background', color);
                            }
                            tblSetLineWidth();
                        }, false);
                    }
                    $tx.hide(border_list.get(0));
                    if (_self.cellPallete_t) _self.cellPallete_t.hide();
                    _self.linePallete_t.toggle();
                    _self.linePallete_t.remainColor(txt_border_color.val());
                    return false;
                });
                // 셀 배경색
                txt_cell_bg.on('blur', function() {
                    this.value = _tableAtt.cellColor = validCheck.validColor('cell', this.value, /*_tableAtt.cellColor*/ '');
                    if (this.value == '') {
                        span_cell_bg.css('background', '#dfeef9');
                    } else {
                        span_cell_bg.css('background', this.value);
                    }
                });
                btn_cell_bg.on('click', function() {
                    _closeSubLayer(btn_cell_bg);
                    if (_self.cellPallete_t == _NULL) {
                        if ($tx.ltie8) {
                            $('.cell_prop', el).append(cell_bg_pal);
                            $(cell_bg_pal).css('top', '135px');
                            $(cell_bg_pal).css('right', '10px');
                        }
                        _self.cellPallete_t = _self.createColorPallete(cell_bg_pal.get(0), function(color) {
                            color = color.toLowerCase();
                            _tableAtt.cellColor = color;
                            txt_cell_bg.val(color);
                            if (color == '') {
                                span_cell_bg.css('background', '#dfeef9');
                            } else {
                                span_cell_bg.css('background', color);
                            }
                        }, false);
                    }
                    $tx.hide(border_list.get(0));
                    if (_self.linePallete_t) _self.linePallete_t.hide();
                    _self.cellPallete_t.toggle();
                    _self.cellPallete_t.remainColor(txt_cell_bg.val());
                    return false;
                });

                //테이블 스타일
                btn_table_style.on('click', function() {
                    _closeSubLayer(btn_table_style);
                    if ($(this).hasClass('btn_down_arrow2')) {
                        $(this).removeClass('btn_down_arrow2').addClass('btn_up_arrow2');
                        if ($tx.ltie8 && $(style_list).data('ltie8') != 'true') {
                            $(style_list).data('dd', $(this).closest('dd'));
                            $('.cell_prop', el).append(style_list);
                            style_list.css('bottom', '50px');
                            //style_list.css('right', '10px');
                            $(style_list).data('ltie8', 'true');
                        }
                        style_list.show();
                    } else {
                        $(this).removeClass('btn_up_arrow2').addClass('btn_down_arrow2');
                        style_list.hide();
                    }
                    return false;
                });
                btn_table_style.closest('span').on('click', function() {
                    btn_table_style.click();
                });
                style_list.find('span').on('click', function() {
                    var span = null;
                    if ($tx.ltie8) {
                        span = $(this).closest('ul').data('dd').find('.g_style:eq(0)');
                    } else {
                        span = $(this).closest('dd').find('.g_style:eq(0)');
                    }
                    var cls = $(this).text();
                    var style = $(this).data('style');
                    if (!span.find('.td_style').hasClass(cls)) {
                        span.find('.td_style').remove();
                        span.prepend('<span class="td_style ' + cls + '"></span>');
                    }
                    _tableAtt.tableStyle = style;
                    btn_table_style.click();
                });

                defaultSetting();
                ok.on('click', function() {
                    var info = _self.tableSelect.getSelectedTrArr(true);
                    var sArr = info.selectedTr;
                    var aArr = info.allTr;
                    var _table = _self.tableSelect.currentTable;
                    if ($(el).find('input[type=radio]:checked').val() == 'custom') {
                        // if (_tableAtt.lineWidth == null || _tableAtt.lineWidth == '') _tableAtt.lineWidth = '1';
                        if (!_tableAtt.lineStyle) _tableAtt.lineStyle = 'solid';
                        var _css = {};
                        if (_tableAtt.lineWidth == '0') _css.border = '0';
                        else if (!(_tableAtt.lineWidth == null || _tableAtt.lineWidth == '')) _css.border = _tableAtt.lineWidth + 'px ' + _tableAtt.lineStyle + ' ' + (_tableAtt.lineColor || '#ccc');
                        if (_tableAtt.cellColor) _css.background = _tableAtt.cellColor;
                        if (_css.border || _css.background) {
                            for (var ri = 0, last = aArr.length - 1; ri <= last; ri++) {
                                var row = aArr[ri];
                                for (var ci = 0; ci < row.cells.length; ci++) {
                                    var cell_obj = row.cells[ci];
                                    var cell = null;
                                    if (cell_obj) cell = cell_obj.cell;
                                    if (cell) $(cell).css(_css);
                                }
                            }
                        }
                    } else {
                        if (!_self.tableTemplateLoader) _self.tableTemplateLoader = new Trex.Table.TemplateLoader();
                        _self.tableTemplateLoader.getTemplate(_tableAtt.tableStyle, function(template) {
                            template.apply(_table);
                        });
                    }
                    _closeSubLayer();
                    self.hidePopup(name);
                    var td = self.tableSelect.currentTd;
                    self.tableSelect.reset();
                    self.canvas.history.saveHistory();
                    defaultSetting();
                    if ($tx.msie && td) self.canvas.getProcessor().selectFirstText(td);
                });
                cancel.on('click', function() {
                    _closeSubLayer();
                    self.hidePopup(name);
                    var td = self.tableSelect.currentTd;
                    self.tableSelect.reset();
                    defaultSetting();
                    if ($tx.msie && td) self.canvas.getProcessor().selectFirstText(td);
                });
            })();
        }
    },
    /**
     * 셀 나누기 (추가 기능)
     */
    splitCells: function(split_type, split_num) {
        var indexer = this.tableSelect.getIndexer(),
            currentTd = this.tableSelect.currentTd,
            currentTr = $(this.tableSelect.currentTd).closest('tr').get(0),
            currentTable = this.tableSelect.currentTable,
            copy_td = $(currentTd).clone(),
            selected = this.tableSelect.getSelected(),
            cells = _NULL,
            rowspan = _NULL,
            colspan = _NULL,
            remain = _NULL,
            self = this;

        Trex.TableUtil.emptyTd(copy_td.get(0));

        var addRow = function(add_row, height) {
            //선택된 이외의 셀에 rowspan이 있는지 검토하여 수정
            var procTd, row_idx, insertTr;
            row_idx = self.tableSelect.getSelected().bottom;
            cells = indexer.indexData[row_idx];

            $.each(cells, function() {
                var checkTd = $(this).get(0);
                if (procTd == checkTd) return true;
                if (!$(this).hasClass(self.tableSelect.SELECTED_CLASS_NAME)) {
                    var rowspan = checkTd.rowSpan;
                    checkTd.rowSpan = rowspan + add_row;
                }
                procTd = checkTd;
            });

            for (var i = 0; i < add_row; i++) {
                if ($tx.msie && $tx.msie_docmode <= 8) {
                    var _row = indexer.table.insertRow(row_idx + i + 1);
                    var _cell = _row.insertCell(0);
                    _cell.style.cssText = copy_td[0].style.cssText;
                    _cell.style.height = height + 'px';
                } else {
                    var new_td = copy_td.clone().height(height);
                    var new_tr = $('<tr></tr>').append(new_td);
                    insertTr = indexer.table.rows[row_idx + i];
                    $(insertTr).after(new_tr);
                }
            }
        }

        var addColumn = function(add_col) {
            cells = indexer.getTdArr(new Trex.TableUtil.Boundary({
                top: 0,
                right: selected.left,
                bottom: indexer.getRowSize() - 1,
                left: selected.left
            }));

            $(currentTd).width(Math.floor($(currentTd).width() / (add_col + 1)));
            $.each(cells, function() {
                for (var col = 1; col <= add_col; col++) {
                    if (this != currentTd) {
                        this.colSpan++;
                    } else {
                        $(currentTd).after($(currentTd).clone());
                    }
                }
            });
        }

        var splitColumn = function(split_num) {
            $(currentTd).width(Math.floor($(currentTd).width() / currentTd.colSpan));
            for (var col = 1; col < split_num; col++) {
                (currentTd.colSpan == 2 ? ($tx.ltie8 ? $(currentTd)[0].colSpan = 1 : currentTd.removeAttribute('colspan')) : currentTd.colSpan--);
                var tdClone = $(currentTd).clone();
                if ($tx.ltie8) {
                    $(tdClone)[0].colSpan = 1;
                } else {
                    tdClone.removeAttr('colspan');
                }
                //$(currentTd).after($(currentTd).clone().removeAttr('colspan'));
                $(currentTd).after(tdClone);
            }
        }

        if (split_type == 'row') {
            var td_height = 24; //기본 높이
            rowspan = currentTd.rowSpan;
            remain = split_num - rowspan;
            if ($tx.ltie8) {
                $(copy_td)[0].rowSpan = 1;
            } else {
                copy_td.removeAttr('rowspan');
            }

            //현재 선택된 셀에 rowspan 속성이 있는 경우
            for (var row = 1; row < split_num; row++) {
                rowspan = currentTd.rowSpan;

                //추가되야 하는 Cell의 위치 찾기
                var dst_td;

                //기존 셀에 rowspan값이 있는 경우 rowspan속성 수정 및 TD추가
                if (rowspan > 1) {
                    var last_tr = currentTable.rows[currentTr.rowIndex + rowspan - 1];
                    /**
                     * target의 전체 cell이 병합되 있는 경우 오류 처리
                     */
                    if (last_tr.cells.length == 0) {
                        $(copy_td).appendTo(last_tr).height(td_height);
                        (currentTd.rowSpan == 2 ?
                            ($tx.ltie8 ? $(currentTd)[0].rowSpan = 1 : currentTd.removeAttribute('rowspan')) :
                            currentTd.rowSpan--);
                        /**
                         * td의 최소 height 보장.
                         */
                        var he = $(currentTd).height() - td_height;
                        $(currentTd).height(he < td_height ? td_height : he);
                    } else {
                        for (var idx = 0; idx < last_tr.cells.length; idx++) {
                            dst_td = last_tr.cells[idx];
                            if ($(last_tr.cells[idx]).position().left > $(currentTd).position().left) break;
                        }
                        //최하단 tr에 td추가
                        var new_td = copy_td.clone();
                        $(new_td).height($(dst_td).height());
                        $(dst_td).before(new_td);

                        //원본 TD에 rowspan값 조정
                        (currentTd.rowSpan == 2 ?
                            ($tx.ltie8 ? $(currentTd)[0].rowSpan = 1 : currentTd.removeAttribute('rowspan')) : currentTd.rowSpan--);
                        /**
                         * td의 최소 height 보장.
                         */
                        var nhe = $(new_td).height();
                        var he = $(currentTd).height() - nhe;
                        $(currentTd).height(he < td_height ? nhe : he);
                    }
                } else {
                    //TR새로 추가 및 다른 셀의 rowspan값 조정
                    addRow(remain, td_height);
                    if ($tx.ltie8) {
                        $(currentTd)[0].rowSpan = 1;
                    } else {
                        $(currentTd).removeAttr('rowspan');
                    }
                    break;
                }
            }
        } else {

            colspan = currentTd.colSpan;
            remain = split_num - colspan;

            //쪼개지는 개수가 합쳐져있던 개수보다 작거나 같으면 해당 tr만 처리하면 됨...
            if (split_num <= colspan) {
                splitColumn(split_num);
            } else {
                //합쳐져있던 column처리
                if (colspan > 1) splitColumn(colspan);

                //추가되는 column처리
                addColumn(remain);
            }
        }
    },
    sameWidth: function() {
        if (this.tableSelect.currentTable)
            this.tableSelect.currentTable.style.breakWord = "break-all";
        var info = this.tableSelect.getSelectedTrArr(true);
        var trArr = info.allTr;
        var selectedIndexer = info.selectedTr;
        var totalWidth = 0;
        var cells = selectedIndexer[0].cells;
        for (var i = 0; i < cells.length; i++) {
            var item = cells[i].cell;
            if (item) totalWidth += $(item.cell).width();
        }
        var startIndex = cells[0].cell.index;
        var endIndex = cells[cells.length - 1].cell.index;
        var cellCount = 0;
        for (var i = 0; i < cells.length; i++) {
            if (cells[i].cell) cellCount += cells[i].cell.cColSpan - 0;
        }
        var cellWidth = Math.round(totalWidth / cellCount);
        for (var rowIdx = 0; rowIdx < trArr.length; rowIdx++) {
            var row = trArr[rowIdx].cells;
            for (var colIdx = startIndex; colIdx <= endIndex; colIdx++) {
                if (row[colIdx]) {
                    var col_span = row[colIdx].cColSpan;
                    $(row[colIdx].cell).width(col_span * cellWidth);
                }
            }
        }
        this.hideContextMenu();
        var td = this.tableSelect.currentTd;
        if ($tx.msie && $tx.msie_docmode <= 8 && td) this.canvas.getProcessor().selectFirstText(td);
    },
    sameHeight: function() {
        if (this.tableSelect.currentTable)
            this.tableSelect.currentTable.style.breakWord = "break-all";
        var info = this.tableSelect.getSelectedTrArr(true);
        var trArr = info.allTr;
        var selectedIndexer = info.selectedTr;
        var totalHeight = 0;
        var rows = selectedIndexer;
        for (var i = 0; i < rows.length; i++) {
            var item = rows[i].cells[0].cell;
            if (item) totalHeight += $(item.cell).height();
        }
        var startIndex = rows[0].index;
        var endIndex = rows[rows.length - 1].index;
        var rowCount = endIndex - startIndex + 1;
        var cellHeight = Math.round(totalHeight / rowCount);
        if (cellHeight < 20) cellHeight = 20;
        for (var rowIdx = startIndex; rowIdx <= endIndex; rowIdx++) {
            var row = trArr[rowIdx].cells;
            for (var colIdx = 0; colIdx < row.length; colIdx++) {
                if (row[colIdx]) {
                    $(row[colIdx].cell).height(row[colIdx].rowSpan * cellHeight);
                }
            }
        }
        this.hideContextMenu();
        var td = this.tableSelect.currentTd;
        if ($tx.msie && $tx.msie_docmode <= 8 && td) this.canvas.getProcessor().selectFirstText(td);
    }
});

/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.Table.Selector = Trex.Class.create({
    SELECTED_CLASS_NAME: "tx_table_selected_cell",
    SELECTED_CSS_TEXT: "{background:#e9eeff !important}",
    initialize: function(editor, config) {
        this.canvas = editor.getCanvas();
        this.wysiwygPanel = this.canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        this.htmlBody = this.getHtmlBody();
        this.isDragging = _FALSE;
        this.currentTable = _NULL;
        this.currentTd = _NULL;
        this.paintedTdArr = [];
        this.startCellBoundary = new Trex.TableUtil.Boundary();
        this.endCellBoundary = this.startCellBoundary;
        this.selectedBoundary = new Trex.TableUtil.Boundary();
        this.tableIndexer = _NULL;
        this.tableContextMenu = new Trex.Table.ContextMenu(editor, this, config);
        this.applyCss();

        //키보드 이벤트 생성
        var keyobserver = new Trex.Class.create({
            $mixins: [Trex.I.KeyObservable],
            initialize: function() {}
        });
        this.tableKeyObserver = new keyobserver;

        this.observeEvent();
    },
    hideContextMenu: function() {
        this.tableContextMenu.hideContextMenu();
    },
    /**
     * @private
     * @return {Element}
     */
    getHtmlBody: function() {
        var doc;
        doc = this.wysiwygPanel.getDocument();
        return doc.body;
    },
    /**
     * @private
     */
    applyCss: function() {
        var doc;
        doc = this.wysiwygPanel.getDocument();
        $tx.applyCSSText(doc, "." + this.SELECTED_CLASS_NAME + this.SELECTED_CSS_TEXT);
    },
    /**
     * @private
     * @param {Element} body
     */
    observeEvent: function() {
        var self;
        self = this;

        /**
         * 크롬 브라우져 계열에서 테이블 위아래 이동 처리
         */
        function checkTd(elem) {
            var result, td;
            if (self.canvas.config.readonly === _FALSE) {
                td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
                isTxInfo = $tom.find(td, ".txc-info");
                if (td && !isTxInfo) {
                    result = td;
                }
            }
            return result;
        }

        function moveRange(isUp) {
            if (!$tx.webkit) return;
            var range = self.canvas.getProcessor().getRange();
            range[isUp ? "setEndBefore" : "setEndAfter"](self.currentTable);
            range.collapse(false);
            goog.dom.Range.createFromBrowserRange(range).select();
        }

        function isMoveAvailable(prev) {
            var range = self.canvas.getProcessor().getRange();
            range.collapse(false),
                range = range.startContainer,
                range.nodeType === goog.dom.NodeType.TEXT && (range = range.parentElement),
                prev = checkTd(prev);
            var result = true,
                next = checkTd(range);
            if (next !== prev) {
                result = $(prev).closest("table").get(0) === $(next).closest("table").get(0);
            }
            return result;
        }

        if ($tx.webkit) {
            this.tableKeyObserver.observeKey({ keyCode: 38 }, function(ev) {
                var elem, td;
                elem = self.canvas.getProcessor().getNode();
                td = checkTd(elem);
                if (td) {
                    setTimeout(function() {
                        if (isMoveAvailable(td)) {
                            $tx.stop(ev),
                                self.currentTable || self.setTable(td);
                            var indexer = self.tableIndexer.getBoundary(td);
                            td = self.tableIndexer.getTd(indexer.top - 1, indexer.left);
                            (td ? Trex.TableUtil.collapseLastCaret(self.wysiwygPanel, td) : moveRange(true));
                        }
                    }, 0);
                }
            });

            this.tableKeyObserver.observeKey({ keyCode: 40 }, function(ev) {
                var elem, td;
                elem = self.canvas.getProcessor().getNode();
                td = checkTd(elem);
                if (td) {
                    setTimeout(function() {
                        if (isMoveAvailable(td)) {
                            $tx.stop(ev),
                                self.currentTable || self.setTable(td);
                            var indexer = self.tableIndexer.getBoundary(td);
                            td = self.tableIndexer.getTd(indexer.bottom + 1, indexer.left);
                            (td ? Trex.TableUtil.collapseCaret(self.wysiwygPanel, td) : moveRange(false));
                        }
                    }, 0);
                }
            });
        }


        this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(e) {
            var elem;
            elem = $tx.element(e);
            self.onmousedown(elem, e);
        });
        $tx.observe(this.htmlBody, "mousemove", function(e) {
            var elem;
            elem = $tx.element(e);
            self.onmousemove(elem);
        });
        this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(e) {
            self.onmouseup();
        });
        var _tempWinTop; // #FTDUEDTR-1426
        try {
            _tempWinTop = _WIN.top;
            var _tempWinDoc = _tempWinTop.document;
        } catch (e) {
            _tempWinTop = _WIN;
        }
        $tx.observe(_tempWinTop, "mouseup", function(e) {
            self.onmouseup();
        });
        this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYDOWN, function(e) {
            if (self.isDragging) {
                $tx.stop(e);
                self.reset();
            } else {
                self.onkeydown(e.ctrlKey, e.keyCode, e);
            }
        });
        this.canvas.observeJob(Trex.Ev.__CANVAS_DATA_INITIALIZE, function(mode) {
            if (mode === Trex.Canvas.__WYSIWYG_MODE) {
                self.clearSelected();
            }
        });
    },
    /**
     * @private
     * @param {Element} elem
     */
    onmousedown: function(elem, e) {
        var td, isTxInfo;

        //우클릭 제어
        if ($tx.isRightClick(e)) {
            td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
            if ($(td).hasClass(this.SELECTED_CLASS_NAME)) {
                $tx.stop(e);
                return;
            }
        }

        this.reset();
        if (this.canvas.config.readonly === _FALSE) {
            if (!td) td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
            isTxInfo = $tom.find(td, ".txc-info");
            if (td && !isTxInfo) {
                this.selectStart(td);
                this.turnOnDragging();
            }
        }
    },
    /**
     * @private
     * @param {Element} elem
     */
    onmousemove: function(elem) {
        if (this.isDragging) {
            var td, table, notSelected;
            td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
            if (td) {
                table = Trex.TableUtil.getClosestByTagNames(["table"], td);
                if (table === this.currentTable && td !== this.currentTd) {
                    this.selectEnd(td);
                    this.applySelected();
                    Trex.TableUtil.collapseCaret(this.wysiwygPanel, elem);
                }
            } else {
                notSelected = (this.endCellBoundary === this.startCellBoundary);
                if (this.currentTd && notSelected) {
                    this.selectEnd(this.currentTd);
                    this.applySelected();
                    Trex.TableUtil.collapseCaret(this.wysiwygPanel, elem);
                }
            }
        }
    },
    /**
     * @private
     */
    onmouseup: function() {
        if (this.isDragging) {
            this.turnOffDragging();
        }
    },
    /**
     * @private
     */
    onkeydown: function(ctrlKey, keyCode, e) {
        var selectedTdArr, len, i;
        if (ctrlKey === _FALSE) {
            //BlockUI가 닫혀있는지 확인...
            if (this.tableContextMenu.elEditorBlockUI.style.display == 'none') {
                this.tableKeyObserver.fireKeys(e, true);
                if (keyCode === $tx.KEY_DELETE) {
                    //선택된 셀 내용 삭제
                    selectedTdArr = this.getSelectedTdArr();
                    len = selectedTdArr.length;
                    for (i = 0; i < len; i += 1) {
                        Trex.TableUtil.emptyTd(selectedTdArr[i]);
                    }
                }
                this.reset();
            } else {
                $tx.stop(e);
                if (keyCode == $tx.KEY_ESC) {
                    this.tableContextMenu.hidePopup();
                    this.reset();
                }
            }
        } else {
            if(keyCode == 67){
                var _cellCopy = Trex.Table.CellCopy.instance;
                if(_cellCopy && _cellCopy.copy(this)) $tx.stop(e);                
            }
            try { if ((keyCode == 67 || keyCode == 86) && this.currentTable) this.reset(); } catch (e) {}
        }
    },
    setTable: function(elem) {
        this.currentTable = Trex.TableUtil.getClosestByTagNames(["table"], elem);
        this.tableIndexer = new Trex.TableUtil.Indexer(this.currentTable);
    },
    /**
     * @private
     * @param {Element} td
     */
    selectStart: function(td) {
        this.currentTable = Trex.TableUtil.getClosestByTagNames(["table"], td);
        this.tableIndexer = new Trex.TableUtil.Indexer(this.currentTable);
        this.startCellBoundary = this.tableIndexer.getBoundary(td);
        this.endCellBoundary = this.startCellBoundary;
        this.currentTd = td;
    },
    /**
     * @private
     * @param {Element} td
     */
    selectEnd: function(td) {
        this.endCellBoundary = this.tableIndexer.getBoundary(td);
        this.currentTd = td;
    },
    /**
     * @private
     */
    applySelected: function() {
        this.calculateSelectedBoundary();
        this.extendSelectedBoundary();
        this.paint();
    },
    /**
     * @private
     */
    calculateSelectedBoundary: function() {
        this.selectedBoundary = new Trex.TableUtil.Boundary();
        this.selectedBoundary.merge(this.startCellBoundary);
        this.selectedBoundary.merge(this.endCellBoundary);
    },
    /**
     * @private
     */
    extendSelectedBoundary: function() {
        var needExtend;
        needExtend = this.selectedBoundary.isValid();
        while (needExtend) {
            needExtend = this.oneTimeExtendBoundary();
        }
    },
    /**
     * @private
     * @return {boolean} wasExtended
     */
    oneTimeExtendBoundary: function() {
        var selectedTdArr, i, len, extendedBoundary, wasExtended;
        selectedTdArr = this.tableIndexer.getTdArr(this.selectedBoundary);
        len = selectedTdArr.length;
        for (i = 0; i < len; i += 1) {
            extendedBoundary = this.tableIndexer.getBoundary(selectedTdArr[i]);
            wasExtended = this.selectedBoundary.merge(extendedBoundary);
            if (wasExtended) {
                return _TRUE;
            }
        }
        return _FALSE;
    },
    /**
     * @private
     */
    paint: function() {
        var tdArrToSelect, tdArrToUnselect;
        tdArrToSelect = this.tableIndexer.getTdArr(this.selectedBoundary);
        tdArrToUnselect = Array.prototype.without.apply(this.paintedTdArr, tdArrToSelect);

        this.paintSelected(tdArrToSelect);
        this.eraseSelected(tdArrToUnselect);
    },
    /**
     * @private
     * @param {Array} tdArr
     */
    paintSelected: function(tdArr) {
        var self;
        self = this;
        this.paintedTdArr = [];
        tdArr.each(function(td) {
            $tx.addClassName(td, self.SELECTED_CLASS_NAME);
            self.paintedTdArr.push(td);
        });
    },
    /**
     * @private
     * @param {Array} tdArr
     */
    eraseSelected: function(tdArr) {
        this.removeClassName(tdArr);
        this.paintedTdArr = Array.prototype.without.apply(this.paintedTdArr, tdArr);
    },
    /**
     * @private
     * @param {Array} tdArr
     */
    removeClassName: function(tdArr) {
        var self;
        self = this;
        tdArr.each(function(td) {
            var removeAttrResult;
            $tx.removeClassName(td, self.SELECTED_CLASS_NAME);
            if (td.className === "") {
                removeAttrResult = td.removeAttribute("class");
                if (removeAttrResult === _FALSE) { //for IE6, IE7.
                    td.removeAttribute("className");
                }
            }
        });
    },
    /**
     * @private
     */
    clearSelected: function() {
        var tdArr;
        //tdArr = $tom.collectAll(this.htmlBody, "." + this.SELECTED_CLASS_NAME);
        // TODO KEDITOR 위 소스가 너무 느려서 변경함. 설정하는 부분은 paintSelected 한군데 임.
        try {
            tdArr = this.paintedTdArr
        } catch (e) {
            tdArr = $tom.collectAll(this.htmlBody, "." + this.SELECTED_CLASS_NAME);
        }
        this.removeClassName(tdArr);
        this.paintedTdArr = [];
    },
    /**
     * @private
     */
    resetBoundary: function() {
        this.startCellBoundary = new Trex.TableUtil.Boundary();
        this.endCellBoundary = this.startCellBoundary;
        this.selectedBoundary = new Trex.TableUtil.Boundary();
    },
    /**
     * @private
     */
    turnOnDragging: function() {
        this.isDragging = _TRUE;
    },
    /**
     * @private
     */
    turnOffDragging: function() {
        this.isDragging = _FALSE;
    },
    /**
     * @private
     */
    resetDragging: function() {
        this.isDragging = _FALSE;
        this.currentTable = _NULL;
        this.currentTd = _NULL;
    },
    /**
     * isDuringSelection
     * @return {boolean} isDragging
     */
    isDuringSelection: function() {
        return this.isDragging;
    },
    /**
     * getIndexer
     * @return {Trex.TableUtil.Indexer} indexer
     */
    getIndexer: function() {
        return this.tableIndexer;
    },
    /**
     * getSelected
     * @return {Trex.TableUtil.Boundary} boundary
     */
    getSelected: function() {
        return this.selectedBoundary;
    },
    /**
     * getSelectedTdArr
     * @return {Array} tddArr
     */
    getSelectedTdArr: function() {
        if (this.selectedBoundary.isValid()) {
            return this.tableIndexer.getTdArr(this.selectedBoundary);
        }
        return [];
    },
    /**
     * KEDITOR
     * getSelectedTrArr
     * @return {Array} trArr
     */
    getSelectedTrArr: function(getAllTr) {
        if (this.selectedBoundary.isValid()) {
            return this.tableIndexer.getTrArr(this.selectedBoundary, getAllTr);
        }
        return { selectedTr: null, allTr: null };
    },
    /**
     * selectByBoundary
     * @param {Trex.TableUtil.Boundary} boundary
     */
    selectByBoundary: function(boundary) {
        this.resetBoundary();
        this.selectedBoundary = boundary;
        this.paint();
    },
    /**
     * selectByTd
     * @param {Element} startTd
     * @param {Element} endTd
     */
    selectByTd: function(startTd, endTd) {
        this.selectStart(startTd);
        this.selectEnd(endTd);
        this.applySelected();
    },
    /**
     * reset
     */
    reset: function() {
        this.clearSelected();
        this.resetBoundary();
        this.resetDragging();
        this.reloadIndexer();
        this.hideContextMenu();
    },
    /**
     * reloadIndexer
     */
    reloadIndexer: function() {
        if (this.tableIndexer) {
            this.tableIndexer.reload();
        }
    },
    /**
     * getSizeOfSelected
     * @return {Object} size(width,height)
     */
    getSizeOfSelected: function() {
        var selectedTdArr, firstTd, lastTd, firstTdPosition, lastTdPosition;
        selectedTdArr = this.getSelectedTdArr();
        if (0 < selectedTdArr.length) {
            firstTd = selectedTdArr[0];
            lastTd = selectedTdArr[selectedTdArr.length - 1];
            firstTdPosition = $tom.getPosition(firstTd);
            lastTdPosition = $tom.getPosition(lastTd);
            return {
                width: lastTdPosition.x + lastTdPosition.width - firstTdPosition.x,
                height: lastTdPosition.y + lastTdPosition.height - firstTdPosition.y
            };
        }
        return {
            width: 0,
            height: 0
        };
    }
});
Trex.Table.CellCopy = Trex.Class.create({
    initialize: function(editor, config, tableInsert) {
        var canvas;
        canvas = editor.getCanvas();
        this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        this.selectedCells = null;
        this.tableInsert = tableInsert;
    },
    copy: function(tableSelector){
        tableSelector.reloadIndexer();
        var selArr = tableSelector.getSelectedTrArr(true);
        var aTr = selArr.allTr;
        var sTr = selArr.selectedTr;
        var items = this.selectedCells = $.extend(true, [], sTr);

        var _table = null;
        var _isCollapse = false;
        if(items.length > 0){
            var _ot = tableSelector.currentTable;
            var _tmp = $('<table></table>');
            _tmp[0].style.cssText = _ot.style.cssText||'';
            _tmp[0].style.width = '';
            _tmp[0].style.height = '';
            var css = (_tmp[0].style.cssText||'');
            _isCollapse = _tmp[0].style.borderCollapse == "collapse";
            _tmp = null;
            _table = $('<div><br><br><table style="' + css + '"'
             + (_ot&&_ot.border?' border="' + _ot.border + '"':'')
             + (_ot&&_ot.cellSpacing?' cellSpacing="' + _ot.border + '"':'')
             + (_ot&&_ot.cellPadding?' border="' + _ot.cellPadding + '"':'') + '><tbody></tbody></table><br><br></div>');
        }
        for(var i = 0; i < items.length; i++){
            var item = items[i];
            var _tr = $('<tr></tr>');
            $('tbody', _table).append(_tr);
            for(var j = 0; j < item.cells.length; j++){
                var _cell = item.cells[j];
                if(_cell.cell && _cell.cell.cell){
                    _cell.cell.cell = $(_cell.cell.cell).clone().removeClass('tx_table_selected_cell')[0];
                    var _td = _cell.cell.cell;
                    try{
                        if(i == 0 && _isCollapse) {
                            var prev = _cell.cell.rowIndex - 1;
                            if(prev >= 0){
                                var _p = aTr[prev];
                                var _pc = _p && _p.cells[_cell.cell.index];
                                _pc = _pc && _pc.cell;
                                if(_pc && _pc.style.borderBottom) {
                                    _td.style.borderTop = _pc.style.borderBottom;
                                }
                            }
                        }
                        if(j == 0 && _isCollapse) {
                            var prev = _cell.cell.index - 1;
                            if(prev >= 0){
                                var _p = aTr[_cell.cell.rowIndex];
                                var _pc = _p && _p.cells[prev];
                                _pc = _pc && _pc.cell;
                                if(_pc && _pc.style.borderRight) {
                                    _td.style.borderLeft = _pc.style.borderRight;
                                }
                            }
                        }
                        _td.setAttribute('style', _td.style.cssText);
                    }catch(e){}                                        
                    _tr.append(_td);
                }
            }
        }
        tableSelector.hideContextMenu();
        if(items.length > 0){
            if(window.getSelection && (($tx.msie && $tx.msie_ver > 10) || $tx.chrome)){
                var _div = $('<div style="top:-5000px;left:-5000px;opacity:0"></div>');
                _div.append(_table);
                $(document.body).append(_div);
                var _tb = $('table', _div)[0];
                var _sel = window.getSelection();
                _sel.removeAllRanges();
                var _range = document.createRange();
                _range.selectNode(_tb);
                _sel.addRange(_range);
                document.execCommand('copy');
                _div.remove();
                return true;
            }else{
                return false;
            }
        }else{
            this.selectedCells = null;
            return false;
        }
    },
    paste: function(tableSelector){
        /**
         * - 위치확인
         * - 붙여넣을 공간 확보(행, 열 추가, 병합제거)
         * - 붙여넣기, 병합.
         */
        function splitCol(__tr, __cell, __col){
            var flag = false;
            if(__cell.colSpan > 1){
                var cols = __cell.colSpan - 1;
                if(cols > 0){
                    if ($tx.ltie8) {                        
                        __cell.cell.colSpan = 1;
                    } else {
                        $(__cell.cell).removeAttr('colspan');
                    }
                    __cell.colSpan = 1;
                    $(__cell.cell).removeAttr('width');
                    __cell.cell.style.width = '';
                    var copy_td = $(__cell.cell).clone();                        
                    for(var i = 0; i < cols; i++){
                        var new_td = copy_td.clone();
                        $(__cell.cell).after(new_td);
                        __tr.cells[__col + 1 + i] = {};
                        $.extend(__tr.cells[__col + 1 + i], __cell);
                        __tr.cells[__col + 1 + i].cell = new_td[0];
                    }
                }
                flag = true;
            }
            return flag;
        }

        tableSelector.reloadIndexer();
        var pTr = this.selectedCells;
        var trArr = tableSelector.getSelectedTrArr(true);
        var sTr = trArr.selectedTr;
        var aTr = trArr.allTr;
        var _pos = tableSelector.getSelected();
        var _row_size = pTr.length;
        var _col_size = pTr[0].cells.length;
        
        // 붙여넣는 위치에 따라 추가로 행/열이 필요한 경우 행/열 증가
        var _top = _pos.top, _left = _pos.left, _top_b = (_pos.top + _row_size - 1), _left_r = (_pos.left + _col_size - 1);
        var _addRow = (_pos.top + _row_size) - aTr.length;
        var _addCol = (_pos.left + _col_size) - aTr[0].cells.length;
        
        var indexer = tableSelector.getIndexer();
        if(_addRow > 0){
            var _t = aTr.length - 1;
            var tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
                top: _t,
                right: indexer.getColSize() - 1,
                bottom: _t,
                left: 0
            }));
            var tdArrForClone = indexer.getTdArrHasTop(_t);
            this.tableInsert.addRow(indexer.table, _addRow, _t + 1, tdArrAtBoundaryLine, tdArrForClone);
        }
        if(_addCol > 0){
            var _l = indexer.getColSize() - 1;
            var tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
                top: 0,
                right: _l,
                bottom: indexer.getRowSize() - 1,
                left: _l
            }));
            var tdArrForClone = indexer.getTdArrHasLeft(_l);
            this.tableInsert.addCol(_addCol, tdArrAtBoundaryLine, tdArrForClone, this.tableInsert.COL_DIRECTION.LEFT);
        }
        tableSelector.reloadIndexer();
        aTr = tableSelector.getSelectedTrArr(true).allTr;
        // 붙여넣을 영역 Cell 분할
        var _max_col = indexer.getColSize();
        var flag = false;
        for(var row = _top; row <= _top_b; row++){
            var _tr = aTr[row];
            for(var col = _left; col <= _left_r; col++){
                var _cell = _tr.cells[col];
                var _pCell = null;
                var addSpan = 0;
                var copy_td = null;
                var next_td = null;
                // Row분할
                if(_cell == null || _cell.cell == null){
                    // RowSpan 시작점 찾기
                    var mSpan = 0;
                    for(var uRow = row - 1; uRow >= 0; uRow--){
                        mSpan++;
                        _pCell = aTr[uRow].cells[col];
                        if(_pCell) break;
                    }
                    addSpan = _pCell.rowSpan - mSpan;
                    _pCell.cell.rowSpan = _pCell.rowSpan = mSpan;
                    if(_pCell.cell.rowSpan == 1){
                        if ($tx.ltie8) {
                            _pCell.cell.rowSpan = 1;
                        } else {
                            $(_pCell.cell).removeAttr('rowspan');
                        }
                    }
                    $(_pCell.cell).removeAttr('height');
                    _pCell.cell.style.height = '';
                    copy_td = $(_pCell.cell).clone();
                    Trex.TableUtil.emptyTd(copy_td.get(0));
                    if ($tx.ltie8) {
                        $(copy_td)[0].rowSpan = 1;
                    } else {
                        copy_td.removeAttr('rowspan');
                    }
                    copy_td.removeAttr('height');
                    $(copy_td)[0].style.height = '';

                    _tr.cells[col] = {};
                    $.extend(_tr.cells[col], _pCell);
                    _cell = _tr.cells[col];
                    _cell.rowSpan = 1;
                    _cell.cell = copy_td[0];

                    for(var _nd = col + 1; _nd < _max_col; _nd++){
                        next_td = _tr.cells[_nd]&&_tr.cells[_nd].cell||null;
                        if(next_td) break;
                    }
                    if(next_td){
                        $(next_td).before(copy_td);
                    }else{
                        $(copy_td).appendTo($('tr', indexer.table)[row]);
                    }
                }else{
                    addSpan = _cell.rowSpan;
                    if(addSpan > 1){
                        if ($tx.ltie8) {                        
                            _cell.cell.rowSpan = 1;
                        } else {
                            $(_cell.cell).removeAttr('rowspan');
                        }

                        _cell.rowSpan = 1;

                        $(_cell.cell).removeAttr('height');
                        _cell.cell.style.height = '';
                    
                        copy_td = $(_cell.cell).clone();
                        copy_td.removeAttr('height');
                        $(copy_td)[0].style.height = '';
                        Trex.TableUtil.emptyTd(copy_td.get(0));
                    }
                }
                for(var i = 1; i < addSpan; i++){
                    var _nTr = aTr[row + i];
                    for(var _nd = col + 1; _nd < _max_col; _nd++){
                        next_td = _nTr.cells[_nd]&&_nTr.cells[_nd].cell||null;
                        if(next_td) break;
                    }
                    var new_td = $(copy_td).clone();

                    _nTr.cells[col] = {};
                    $.extend(_nTr.cells[col], _cell);
                    var _ncell = _nTr.cells[col];
                    _ncell.cell = new_td[0];

                    if(next_td){
                        $(next_td).before(new_td);
                    }else{
                        $(new_td).appendTo($('tr', indexer.table)[row + i]);
                    }
                    splitCol(_nTr, _ncell, col);
                    flag = true;
                }
                // Col 분할
                if(splitCol(_tr, _cell, col)) flag = true;
            }
        }
        if(flag){
            tableSelector.reloadIndexer();
            aTr = tableSelector.getSelectedTrArr(true).allTr;
        }
        var indexData = tableSelector.tableIndexer.indexData;

        // 붙여넣기....
        var _isCollapse = indexer.table.style.borderCollapse == "collapse";
        for(var row = _top; row <= _top_b; row++){
            var _sTr = pTr[row - _top];
            var _tTr = aTr[row];
            var _tIdx = indexData[row];
            for(var col = _left; col <= _left_r; col++){
                var _sCell = _sTr.cells[col - _left];
                _sCell = _sCell && _sCell.cell || null;
                var _tCell = _tTr.cells[col];
                if(!_sCell) continue;
                if(_sCell.colSpan > 1 || _sCell.rowSpan > 1){
                    // target Merge
                    if(_sCell.colSpan > 1) _tCell.cell.colSpan = _sCell.colSpan;
                    if(_sCell.rowSpan > 1) _tCell.cell.rowSpan = _sCell.rowSpan;
                    for(var dCol = col; dCol < col + _sCell.colSpan; dCol++){
                        for(var dRow = row; dRow < row + _sCell.rowSpan; dRow++){
                            if(dRow == row && dCol == col) continue; // 처음 Cell은 삭제 안함.
                            var _dTr = aTr[dRow];
                            var _dCell = _dTr.cells[dCol];
                            if(_dCell && _dCell.cell){
                                var _p = _dCell.cell.parentElement;
                                $tom.remove(_dCell.cell);
                                _tIdx[dCol] = _tCell.cell;
                                if(_p && _p.cells && _p.cells.length == 0){
                                    for (var j = 0; j < _tIdx.length; j++) {
                                        if (_tIdx[j] && (_tIdx[j].rowSpan || 1) > 1) {
                                            _tIdx[j].rowSpan = _tIdx[j].rowSpan - 1;
                                            if (_tIdx[j].rowSpan == 1 && !$tx.ltie8) _tIdx[j].removeAttribute("rowspan");
                                        }
                                        if (_tIdx[j] && (_tIdx[j].colSpan || 1) > 1) j = j + (_tIdx[j].colSpan - 1);
                                    }
                                    $tom.remove(_p);
                                }
                            }
                        }
                    }
                }
                // 내용 복사.
                _tCell.cell.innerHTML = _sCell.cell.innerHTML;
                $.extend(false, _tCell.cell.style, _sCell.cell.style);
                _tCell.cell.width = _sCell.cell.width;
                _tCell.cell.height = _sCell.cell.height;
                _tCell.cell.align = _sCell.cell.align;
                if(row == _top && _isCollapse) {
                    var _bt = _tCell.cell.style.borderTop;
                    var _p = row > 0?aTr[row - 1]:null;
                    var _pc = _p && _p.cells[col];
                    if(_bt && _bt != 'currentColor' && _pc && _pc.cell) _pc.cell.style.borderBottom = _bt;
                }
                if(col == _left && _isCollapse) {
                    var _bl = _tCell.cell.style.borderLeft;                    
                    var _pc = col > 0?_tTr.cells[col - 1]:null;
                    if(_bl && _bl != 'currentColor' && _pc && _pc.cell) _pc.cell.style.borderRight = _bt;
                }
            }
        }
        tableSelector.hideContextMenu();
    },
    hasCell: function(){
        return this.selectedCells != null;
    }
});
Trex.Table.CellCopy.instance = null;
Trex.Table.CellCopy.build = function(editor, config, tableInsert){
    if(!Trex.Table.CellCopy.instance) Trex.Table.CellCopy.instance = new Trex.Table.CellCopy(editor, config, tableInsert);
    return Trex.Table.CellCopy.instance;
};
/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE, TXMSG */
TrexMessage.addMsg({
    '@table.merge.confirm': Trex._I18N.g('table.merge.confirm', '셀을 병합하면 맨 위쪽 셀에 있는 값만 남고 나머지 값은 잃게 됩니다.'),
    '@table.merge.more.select.cells': Trex._I18N.g('table.merge.more.select.cells', '두 개 이상의 셀을 선택해주세요.')
});

Trex.Table.Merge = Trex.Class.create({
    initialize: function(editor /*, config*/ ) {
        var canvas;
        canvas = editor.getCanvas();

        this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
    },
    /**
     * merge
     * @param {Trex.Table.Selector} tableSelector
     */
    merge: function(tableSelector) {
        var tdArr, td, selectedSize;
        tableSelector.reloadIndexer();
        tdArr = tableSelector.getSelectedTdArr();
        if (1 < tdArr.length) {
            var isExistContent = this.isExistContents(tdArr, 1); // 0번째는 merge시 남겨지는 데이터이므로 무시한다.
            if (isExistContent && confirm(TXMSG('@table.merge.confirm')) == _FALSE) {
                return;
            }

            selectedSize = tableSelector.getSizeOfSelected();
            td = tdArr[0];

            this._removeRowCount = 0;
            this.deleteCellForMerge(tdArr, tableSelector);
            this.extendCellForMerge(td, tableSelector, selectedSize);
            this._removeRowCount = null;

            tableSelector.reset();
            //tableSelector.selectByTd(td, td);
            Trex.TableUtil.collapseCaret(this.wysiwygPanel, td);
        } else {
            alert(TXMSG('@table.merge.more.select.cells'));
        }
    },
    isExistContents: function(tdArr, startIndex) {
        /**
         * KEDITOR
         * 빈 Cell이 있을경우 False 가 아니라 Data가 있는 cell이 있을경우 True를 반환 하도록 변경함.
         */
        startIndex = startIndex || 0; // default 0
        var flag = _FALSE;
        for (var i = startIndex, max = tdArr.length; i < max; i++) {
            var entry = tdArr[i] || "";
            var html = entry.innerHTML.trim().toLowerCase().replace(/(&nbsp;|\s)/g, '');
            var equalBogusType1 = (html == "<p></p>"), // &nbsp; 는 치환하므로 존재할 수 없음
                equalBogusType2 = (html == "<p><br></p>"),
                equalEmpty = (html == "");

            if (!(equalBogusType1 || equalBogusType2 || equalEmpty)) {
                flag = _TRUE;
                break;
            }
        }
        return flag;
    },
    /**
     * @private
     * @param {Array} tdArr
     */
    deleteCellForMerge: function(tdArr, tableSelector) {
        var data, trimedData, i, len;
        data = tdArr[0].innerHTML;
        len = tdArr.length;
        var indexData = tableSelector.tableIndexer.indexData;
        /**
         * KEDITOR
         * trimedData 가 "<p></p>" , "<p><br></p>" 인것도 비교함.
         * 처음 값이 나오는 cell을 찾기 위함.
         */
        for (i = 1; i < len; i += 1) {
            trimedData = data.replace(Trex.__WORD_JOINER_REGEXP, "").trim();
            if (trimedData === "" || trimedData === "&nbsp;" ||
                trimedData == "<p></p>" ||
                trimedData == "<p><br></p>") {
                data = tdArr[i].innerHTML;
            }
            /**
             * KEDITOR
             * cell 을 삭제 할때 tr의 전체 td가 지워지면 tr을 지우고 rowSpan 값을 - 1함.
             * 빈 <tr>이 있는경우 문제 됨.
             */
            var parent = tdArr[i].parentElement; // <--
            $tom.remove(tdArr[i]);
            if (parent && parent.cells && parent.cells.length == 0) {
                var rowIndex = parent.rowIndex;
                var cols = indexData[rowIndex];
                for (var j = 0; j < cols.length; j++) {
                    if (cols[j] && (cols[j].rowSpan || 1) > 1) {
                        cols[j].rowSpan = cols[j].rowSpan - 1;
                        if (cols[j].rowSpan == 1 && !$tx.ltie8) cols[j].removeAttribute("rowspan");
                    }
                    if (cols[j] && (cols[j].colSpan || 1) > 1) j = j + (cols[j].colSpan - 1);
                }
                $tom.remove(parent);
                this._removeRowCount++;
            }
        }
        tdArr[0].innerHTML = data;
    },
    /**
     * @private
     * @param {Element} td
     * @param {Trex.Table.Selector} tableSelector
     * @param {Object} selectedSize
     */
    extendCellForMerge: function(td, tableSelector, selectedSize) {
        var selectedBoundary;
        selectedBoundary = tableSelector.getSelected();
        td.colSpan = selectedBoundary.right - selectedBoundary.left + 1;
        var rowSpan = selectedBoundary.bottom - selectedBoundary.top + 1 - this._removeRowCount;
        if (rowSpan < 1) rowSpan = 1;
        td.rowSpan = rowSpan;
        if (td.rowSpan == 1 && !$tx.ltie8) td.removeAttribute("rowspan");
        if (td.colSpan == 1 && !$tx.ltie8) td.removeAttribute("colspan");
        if (td.style.width) $tom.setWidth(td, selectedSize.width + "px");
        if (td.style.height) $tom.setHeight(td, selectedSize.height + "px");
    },
    /**
     * resetMerge
     * @param {Trex.Table.Selector} tableSelector
     */
    resetMerge: function(tableSelector) {
        //TODO.azki cancel -> reset 으로 바꿀까!?
        var colResult, rowResult;
        tableSelector.reloadIndexer();
        colResult = this.splitCol(tableSelector);
        tableSelector.reloadIndexer();
        rowResult = this.splitRow(tableSelector);
        if (colResult === _FALSE && rowResult === _FALSE) {
            alert(Trex._I18N.g('resetMerge_error', "이미 합쳐진 셀만 분할 가능합니다."));
        } else {
            tableSelector.reloadIndexer();
            tableSelector.hideContextMenu();
        }
    },
    /**
     * @private
     * @param {Trex.Table.Selector} tableSelector
     * @return {boolean} changed
     */
    splitCol: function(tableSelector) {
        var changed, tdArr, td, i, len, splitTdResult;
        changed = _FALSE;
        tdArr = tableSelector.getSelectedTdArr();
        len = tdArr.length;
        if (0 < len) {
            for (i = 0; i < len; i += 1) {
                td = tdArr[i];
                splitTdResult = this.splitTdByColSpan(td);
                changed = changed || splitTdResult;
            }
        }
        return changed;
    },
    /**
     * @private
     * @param {Trex.Table.Selector} tableSelector
     * @return {boolean} changed
     */
    splitRow: function(tableSelector) {
        var changed, tdArr, td, i, len, splitTdResult;
        changed = _FALSE;
        tdArr = tableSelector.getSelectedTdArr();
        len = tdArr.length;
        if (0 < len) {
            for (i = 0; i < len; i += 1) {
                td = tdArr[i];
                splitTdResult = this.splitTdByRowSpan(td);
                changed = changed || splitTdResult;
            }
        }
        return changed;
    },
    /**
     * @private
     * @param {Element} td
     * @return {boolean} changed
     */
    splitTdByColSpan: function(td) {
        var newTdCount, newTd, changed;
        newTdCount = td.colSpan - 1;
        changed = 0 < newTdCount;
        Trex.TableUtil.splitWidthByColSpan(td);
        td.colSpan = 1;
        while (0 < newTdCount) {
            newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
            //TODO.azki set border top/left.
            $tom.insertNext(newTd, td);
            newTdCount -= 1;
        }
        return changed;
    },
    /**
     * @private
     * @param {Element} td
     * @return {boolean} changed
     */
    splitTdByRowSpan: function(td) {
        var changed, newTdCount;
        newTdCount = td.rowSpan - 1;
        changed = 0 < newTdCount;
        Trex.TableUtil.splitHeightByRowSpan(td);
        while (0 < newTdCount) {
            this.splitTdOneByOne(td);
            newTdCount -= 1;
        }
        return changed;
    },
    /**
     * @private
     * @param {Element} td
     */
    splitTdOneByOne: function(td) {
        var trForInsert, tdForInsert, newTd;
        trForInsert = this.getTrForInsert(td);
        tdForInsert = this.getTdForInsert(td, trForInsert);
        newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
        newTd.rowSpan = 1;
        td.rowSpan -= 1;
        if (tdForInsert) {
            $tom.insertAt(newTd, tdForInsert);
        } else {
            $tom.append(trForInsert, newTd);
        }
    },
    /**
     * @private
     * @param {Element} td
     */
    getTrForInsert: function(td) {
        var i, len, trForInsert;
        trForInsert = $tom.parent(td);
        len = td.rowSpan - 1;
        for (i = 0; i < len; i += 1) {
            trForInsert = $tom.next(trForInsert, "tr");
        }
        return trForInsert;
    },
    /**
     * @private
     * @param {Element} td
     * @param {Element} trForInsert
     */
    getTdForInsert: function(td, trForInsert) {
        var tableIndexer, currentBoundary, colForInsert, cells, len, i, cell, cellBoundary;
        tableIndexer = Trex.TableUtil.getTableIndexerFromTd(td);
        currentBoundary = tableIndexer.getBoundary(td);
        colForInsert = currentBoundary.left;
        cells = trForInsert.cells;
        len = cells.length;
        for (i = 0; i < len; i += 1) {
            cell = cells[i];
            cellBoundary = tableIndexer.getBoundary(cell);
            if (colForInsert <= cellBoundary.left) {
                return cell;
            }
        }
        return _NULL;
    }
});
/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.Table.Insert = Trex.Class.create({
    COL_DIRECTION: {
        LEFT: "left",
        RIGHT: "right"
    },

    initialize: function(editor /*, config*/ ) {
        var canvas;
        canvas = editor.getCanvas();

        this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
    },
    /**
     * insertRowAbove
     * @param {Trex.Table.Selector} tableSelector
     */
    insertRowAbove: function(tableSelector) {
        var boundary, indexer;
        tableSelector.reloadIndexer();
        boundary = tableSelector.getSelected();
        if (boundary.isValid()) {
            indexer = tableSelector.getIndexer();
            this.insertRowAboveByBoundary(boundary, indexer);
            var td = tableSelector.currentTd;
            tableSelector.reset();
            if ($tx.msie && $tx.msie_docmode <= 8 && td) this.wysiwygPanel.processor.selectFirstText(td);
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Boundary} boundary
     * @param {Trex.TableUtil.Indexer} indexer
     */
    insertRowAboveByBoundary: function(boundary, indexer) {
        var table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone;
        table = indexer.table;
        //1개의 row만 추가되도록 변경
        rowCount = 1; //boundary.bottom - boundary.top + 1;
        insertIndex = boundary.top;
        tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
            top: boundary.top,
            right: indexer.getColSize() - 1,
            bottom: boundary.top,
            left: 0
        }));
        tdArrForClone = indexer.getTdArrHasTop(boundary.top);
        this.addRow(table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone);
    },
    /**
     * addRow
     * @param {Element} table
     * @param {number} rowCount
     * @param {number} insertIndex
     * @param {Array} tdArrAtBoundaryLine
     * @param {Array} tdArrForClone
     */
    addRow: function(table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone) {
        var fn, i, tr_closure;
        fn = function(td) {
            var newTd;
            if (tdArrForClone.contains(td)) {
                newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
                Trex.TableUtil.splitHeightByRowSpan(newTd);
                //TODO.azki left / top 보더 세팅이 필요할지도.?
                newTd.rowSpan = 1;
                $(newTd).removeClass('tx_table_selected_cell');
                tr_closure.appendChild(newTd); //tr_closure is closure variable.
            } else {
                td.rowSpan += 1;
            }
        };
        for (i = 0; i < rowCount; i += 1) {
            tr_closure = table.insertRow(insertIndex);
            tdArrAtBoundaryLine.each(fn);
        }
    },
    /**
     * insertRowBelow
     * @param {Trex.Table.Selector} tableSelector
     */
    insertRowBelow: function(tableSelector) {
        var boundary, indexer;
        tableSelector.reloadIndexer();
        boundary = tableSelector.getSelected();
        if (boundary.isValid()) {
            indexer = tableSelector.getIndexer();
            this.insertRowBelowByBoundary(boundary, indexer);
            var td = tableSelector.currentTd;
            tableSelector.reset();
            if ($tx.msie && $tx.msie_docmode <= 8 && td) this.wysiwygPanel.processor.selectFirstText(td);
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Boundary} boundary
     * @param {Trex.TableUtil.Indexer} indexer
     */
    insertRowBelowByBoundary: function(boundary, indexer) {
        var table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone;
        table = indexer.table;
        //1개의 row만 추가되도록 변경
        rowCount = 1; //boundary.bottom - boundary.top + 1;
        insertIndex = boundary.bottom + 1;
        tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
            top: boundary.bottom,
            right: indexer.getColSize() - 1,
            bottom: boundary.bottom,
            left: 0
        }));
        tdArrForClone = indexer.getTdArrHasBottom(boundary.bottom);
        this.addRow(table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone);
    },
    /**
     * insertColLeft
     * @param {Trex.Table.Selector} tableSelector
     */
    insertColLeft: function(tableSelector) {
        var boundary, indexer;
        tableSelector.reloadIndexer();
        boundary = tableSelector.getSelected();
        if (boundary.isValid()) {
            indexer = tableSelector.getIndexer();
            this.insertColLeftByBoundary(boundary, indexer);
            var td = tableSelector.currentTd;
            tableSelector.reset();
            if ($tx.msie && $tx.msie_docmode <= 8 && td) this.wysiwygPanel.processor.selectFirstText(td);
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Boundary} boundary
     * @param {Trex.TableUtil.Indexer} indexer
     */
    insertColLeftByBoundary: function(boundary, indexer) {
        var colCount, tdArrAtBoundaryLine, tdArrForClone;
        //1개의 column만 추가되도록 변경
        colCount = 1; //boundary.right - boundary.left + 1;
        tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
            top: 0,
            right: boundary.left,
            bottom: indexer.getRowSize() - 1,
            left: boundary.left
        }));
        tdArrForClone = indexer.getTdArrHasLeft(boundary.left);
        this.addCol(colCount, tdArrAtBoundaryLine, tdArrForClone, this.COL_DIRECTION.LEFT);
    },
    /**
     * addCol
     * @param {number} colCount
     * @param {Array} tdArrAtBoundaryLine
     * @param {Array} tdArrForClone
     * @param {Trex.Table.Insert.COL_DIRECTION} direction
     */
    addCol: function(colCount, tdArrAtBoundaryLine, tdArrForClone, direction) {
        var self, fn, i;
        self = this;
        fn = function(td) {
            var newTd;
            if (tdArrForClone.contains(td)) {
                newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
                Trex.TableUtil.splitWidthByColSpan(newTd);
                //TODO.azki left / top 보더 세팅이 필요할지도.?
                newTd.colSpan = 1;
                $(newTd).removeClass('tx_table_selected_cell');
                if (direction === self.COL_DIRECTION.LEFT) {
                    $tom.insertAt(newTd, td);
                } else {
                    $tom.insertNext(newTd, td);
                }
            } else {
                td.colSpan += 1;
            }
        };
        for (i = 0; i < colCount; i += 1) {
            tdArrAtBoundaryLine.each(fn);
        }
    },
    /**
     * insertColRight
     * @param {Trex.Table.Selector} tableSelector
     */
    insertColRight: function(tableSelector) {
        var boundary, indexer;
        tableSelector.reloadIndexer();
        boundary = tableSelector.getSelected();
        if (boundary.isValid()) {
            indexer = tableSelector.getIndexer();
            this.insertColRightByBoundary(boundary, indexer);
            var td = tableSelector.currentTd;
            tableSelector.reset();
            if ($tx.msie && $tx.msie_docmode <= 8 && td) this.wysiwygPanel.processor.selectFirstText(td);
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Boundary} boundary
     * @param {Trex.TableUtil.Indexer} indexer
     */
    insertColRightByBoundary: function(boundary, indexer) {
        var colCount, tdArrAtBoundaryLine, tdArrForClone;
        //1개의 column만 추가되도록 변경
        colCount = 1; //boundary.right - boundary.left + 1;
        tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
            top: 0,
            right: boundary.right,
            bottom: indexer.getRowSize() - 1,
            left: boundary.right
        }));
        tdArrForClone = indexer.getTdArrHasRight(boundary.right);
        this.addCol(colCount, tdArrAtBoundaryLine, tdArrForClone, this.COL_DIRECTION.RIGHT);
    }
});
/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.Table.Delete = Trex.Class.create({
    initialize: function(editor /*, config*/ ) {
        var canvas;
        canvas = editor.getCanvas();

        this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
    },
    /**
     * deleteRow
     * @param {Trex.Table.Selector} tableSelector
     */
    deleteRow: function(tableSelector) {
        var boundary;
        boundary = tableSelector.getSelected();
        if (boundary.isValid()) {
            //this.deleteRowOneByOne(tableSelector);
            if($tx.msie){
                try{
                    var sel = this.wysiwygPanel.wysiwygDoc.getSelection();
                    sel.removeAllRanges();
                }catch(e){}
            }
            this.deleteSelectedRow(tableSelector);
            tableSelector.reset();
            if ($tx.msie /*&& $tx.msie_docmode <= 8*/) {
                var indexer = tableSelector.getIndexer();
                boundary.bottom = boundary.top;
                boundary.right = boundary.left = 0;
                if (!indexer.indexData[boundary.top]) boundary.bottom = boundary.top = boundary.top - 1;
                var td = null;
                try {
                    var selectedTdArr = indexer.getTdArr(boundary);
                    td = selectedTdArr[0];
                } catch (e) {}
                if (td) this.wysiwygPanel.processor.selectFirstText(td);
            }
            this.deleteEmptyTableByTableSelector(tableSelector);
        }
    },
    deleteTable: function(tableSelector){
        var indexer, table;
        indexer = tableSelector.getIndexer();
        table = indexer.table;
        var p = table.previousSibling || table.parentNode;
        tableSelector.reset();
        $tom.remove(table);
        if (p) this.wysiwygPanel.processor.selectLastText(p);        
    },
    /**
     * 새로 추가한 함수
     * 기존 삭제 기능은 아래와 같은 오류가 있음
     *   - 오류 유형1 : 셀이 나뉘어진 2번째 셀 이상에서 삭제 할 경우 오류
     *   - 오류 유형1 : 셀이 나뉘어지고 rowspan값이 있는 셀에서 삭제하는 경우 오류
     * 사용자가 선택한 셀만 삭제하도록 기능 변경
     */
    deleteSelectedRow: function(tableSelector) {
        var boundary, selectedTdArr, indexer, row_idx, count, td;
        boundary = tableSelector.getSelected();
        indexer = tableSelector.getIndexer();
        selectedTdArr = indexer.getTdArr(boundary);

        var deletedRowIndex = [];
        for (var i = 0; i < selectedTdArr.length; i++) {
            td = selectedTdArr[i];
            boundary = indexer.getBoundary(td);
            row_idx = boundary.top;
            count = boundary.bottom;

            //선택된 셀의 row를 삭제한다
            for (row_idx; row_idx <= count; row_idx++) {
                //이미 처리된 row는 pass처리
                if (deletedRowIndex.contains(row_idx)) continue;
                this.deleteRowProc(indexer, td, row_idx);
                deletedRowIndex.push(row_idx);
            }
        }

        //제일 윗줄이 삭제된 경우 border값 처리
        if (deletedRowIndex.contains(0)) {
            this.drawTopBorder(tableSelector);
        }
    },
    deleteRowProc: function(indexer, td, row_idx) {
        var tdArr; //해당 row의 td
        var checkTd, checkTr;
        var tr, boundary;
        tdArr = this.getTdArrByRowIndex(indexer, row_idx);
        tr = $tom.parent(td);
        for (var i = 0; i < tdArr.length; i++) {
            checkTd = tdArr[i];
            checkTr = $tom.parent(checkTd);
            if (1 < checkTd.rowSpan) {
                (checkTd.rowSpan == 2 ? ($tx.ltie8 ? $(checkTd)[0].rowSpan = 1 : checkTd.removeAttribute("rowspan")) : checkTd.rowSpan--);
                boundary = indexer.getBoundary(checkTd);
                this.reduceHeight(checkTd, td);

                //삭제 대상 td와 같은 tr에 포함된 경우 next tr로 이동처리
                if (checkTr == tr) {
                    // console.log('여기');
                    this.shiftRowOfTd(checkTd, indexer);
                }
            } else {
                $tom.remove(checkTd);
                //if (checkTr.childElementCount == 0) {
                if (checkTr.children.length == 0) {
                    $tom.remove(checkTr);
                }
            }
        }
    },
    reduceHeight: function(checkTd, selTd) {
        $(checkTd).height($(checkTd).height() - $(selTd).height());
    },
    /**
     * @private
     * @param {Trex.Table.Selector} tableSelector
     */
    deleteRowOneByOne: function(tableSelector) {
        var deleteStartIndex, count, boundary, indexer;
        boundary = tableSelector.getSelected();
        deleteStartIndex = boundary.top;
        count = boundary.bottom - boundary.top + 1;
        while (0 < count) {
            tableSelector.reloadIndexer();
            indexer = tableSelector.getIndexer();
            this.deleteRowByIndex(indexer, deleteStartIndex);
            count -= 1;
        }
        if (deleteStartIndex === 0) {
            this.drawTopBorder(tableSelector);
        }
    },
    drawTopBorder: function(tableSelector) {
        var indexer, tdArr, len, i, td;
        tableSelector.reloadIndexer();
        indexer = tableSelector.getIndexer();
        tdArr = indexer.getTdArrHasTop(0);
        len = tdArr.length;
        for (i = 0; i < len; i += 1) {
            td = tdArr[i];
            if ((td.style.borderTop === "" || td.style.borderTop === "none" || td.style.borderTop === "currentColor") && td.style.borderBottom !== "") {
                td.style.borderTop = td.style.borderBottom;
            }
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Indexer} indexer
     * @param {number} index
     */
    deleteRowByIndex: function(indexer, index) {
        var tdArr, hasTopTdArr, len, tr;
        tdArr = this.getTdArrByRowIndex(indexer, index);
        hasTopTdArr = this.getTdArrByHasTop(indexer, index);
        len = hasTopTdArr.length;
        if (0 < len) {
            tr = $tom.parent(tdArr[0]);
            this.deleteTdInDeleteRow(tdArr, hasTopTdArr, tr, indexer);
            $tom.remove(tr);
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Indexer} indexer
     * @param {number} index
     */
    getTdArrByRowIndex: function(indexer, index) {
        return indexer.getTdArr(new Trex.TableUtil.Boundary({
            top: index,
            right: indexer.getColSize() - 1,
            bottom: index,
            left: 0
        }));
    },
    /**
     * @private
     * @param {Trex.TableUtil.Indexer} indexer
     * @param {number} index
     */
    getTdArrByHasTop: function(indexer, index) {
        return indexer.getTdArrHasTop(index);
    },
    /**
     *
     * @param {Array} tdArr
     * @param {Array} hasTopTdArr
     * @param {Element} tr
     * @param {Trex.TableUtil.Indexer} indexer
     */
    deleteTdInDeleteRow: function(tdArr, hasTopTdArr, tr, indexer) {
        var len, i, td;
        len = tdArr.length;
        for (i = 0; i < len; i += 1) {
            td = tdArr[i];
            if (1 < td.rowSpan) {
                (td.rowSpan == 2 ? ($tx.ltie8 ? $(td)[0].rowSpan = 1 : td.removeAttribute("rowspan")) : td.rowSpan--);
                this.reduceHeightAsRow(td, tr);
                if (hasTopTdArr.contains(td)) {
                    this.shiftRowOfTd(td, indexer);
                }
            } else {
                $tom.remove(td);
            }
        }
    },
    reduceHeightAsRow: function(td, tr) {
        var styleHeight, newHeight;
        if (td.style.height) {
            styleHeight = parseInt(td.style.height, 10);
            newHeight = styleHeight - tr.offsetHeight;
            if (0 < newHeight) {
                $tom.setStyles(td, {
                    height: newHeight + "px"
                }, _TRUE);
            }
        }
    },
    /**
     * @private
     * @param {Eelement} td
     * @param {Trex.TableUtil.Indexer} indexer
     */
    shiftRowOfTd: function(td, indexer) {
        var tr, trForInsert, tdForInsert;
        tr = $tom.parent(td);
        trForInsert = $tom.next(tr, "tr");
        tdForInsert = this.getTdForInsert(td, trForInsert, indexer);
        if (tdForInsert) {
            $tom.insertAt(td, tdForInsert);
        } else {
            $tom.append(trForInsert, td);
        }
    },
    /**
     * @private
     * @param {Element} td
     * @param {Element} trForInsert
     * @param {Trex.TableUtil.Indexer} indexer
     */
    getTdForInsert: function(td, trForInsert, indexer) {
        var currentBoundary, colForInsert, cells, len, i, cell, cellBoundary;
        currentBoundary = indexer.getBoundary(td);
        colForInsert = currentBoundary.left;
        cells = trForInsert.cells;
        len = cells.length;
        for (i = 0; i < len; i += 1) {
            cell = cells[i];
            cellBoundary = indexer.getBoundary(cell);
            if (colForInsert <= cellBoundary.left) {
                return cell;
            }
        }
        return _NULL;
    },
    /**
     * @private
     * @param {Trex.Table.Selector} tableSelector
     */
    deleteEmptyTableByTableSelector: function(tableSelector) {
        var indexer, table, p;
        indexer = tableSelector.getIndexer();
        table = indexer.table;
        if(table) p = table.previousSibling || table.parentNode;
        if (table && 
            ((table.rows && table.rows.length === 0) 
                || (table.cells && table.cells.length === 0)
                || (!table.cells && indexer && indexer.indexData && indexer.indexData.length === 0)
            )
        ) {
            $tom.remove(table);
            if (p) this.wysiwygPanel.processor.selectLastText(p);
        }
    },
    /**
     * deleteCol
     * @param {Trex.Table.Selector} tableSelector
     */
    deleteCol: function(tableSelector) {
        var boundary;
        boundary = tableSelector.getSelected();
        if (boundary.isValid()) {
            if($tx.msie){
                try{
                    var sel = this.wysiwygPanel.wysiwygDoc.getSelection();
                    sel.removeAllRanges();
                }catch(e){}
            }
            this.deleteColOneByOne(tableSelector);
            tableSelector.reset();
            if ($tx.msie /*&& $tx.msie_docmode <= 8*/) {
                var indexer = tableSelector.getIndexer();
                boundary.bottom = boundary.top;
                boundary.right = boundary.left;
                var td = null;
                try {
                    var selectedTdArr = indexer.getTdArr(boundary);
                    td = selectedTdArr[0];
                } catch (e) {}
                if (!td) {
                    try {
                        boundary.right = boundary.left = boundary.left - 1;
                        var selectedTdArr = indexer.getTdArr(boundary);
                        td = selectedTdArr[0];
                    } catch (e) {}
                }
                if (td) this.wysiwygPanel.processor.selectFirstText(td);
            }
            this.deleteEmptyTableByTableSelector(tableSelector);
        }
    },
    /**
     * @private
     * @param {Trex.Table.Selector} tableSelector
     */
    deleteColOneByOne: function(tableSelector) {
        var deleteStartIndex, count, boundary, indexer;
        boundary = tableSelector.getSelected();
        deleteStartIndex = boundary.left;
        count = boundary.right - boundary.left + 1;
        while (0 < count) {
            tableSelector.reloadIndexer();
            indexer = tableSelector.getIndexer();
            this.deleteColByIndex(indexer, deleteStartIndex);
            count -= 1;
        }
        if (deleteStartIndex === 0) {
            this.drawLeftBorder(tableSelector);
        }
    },
    drawLeftBorder: function(tableSelector) {
        var indexer, tdArr, len, i, td;
        tableSelector.reloadIndexer();
        indexer = tableSelector.getIndexer();
        tdArr = indexer.getTdArrHasLeft(0);
        len = tdArr.length;
        for (i = 0; i < len; i += 1) {
            td = tdArr[i];
            if ((td.style.borderLeft === "" || td.style.borderLeft === "none" || td.style.borderLeft === "currentColor") && td.style.borderRight !== "") {
                td.style.borderLeft = td.style.borderRight;
            }
        }
    },
    /**
     * @private
     * @param {Trex.TableUtil.Indexer} indexer
     * @param {number} index
     */
    deleteColByIndex: function(indexer, index) {
        var tdArr, len, i, td;
        tdArr = this.getTdArrByColIndex(indexer, index);
        len = tdArr.length;
        for (i = 0; i < len; i += 1) {
            td = tdArr[i];
            if (1 < td.colSpan) {
                (td.colSpan == 2 ? ($tx.ltie8 ? $(td)[0].colSpan = 1 : td.removeAttribute('colspan')) : td.colSpan--);
                //TODO.azki width 조절..?
            } else {
                $tom.remove(td);
            }
        }
    },
    getTdArrByColIndex: function(indexer, index) {
        return indexer.getTdArr(new Trex.TableUtil.Boundary({
            top: 0,
            right: index,
            bottom: indexer.getRowSize() - 1,
            left: index
        }));
    }
});


Trex.Table.Border = Trex.Class.create({
    $const: {
        BORDER_STYLE: "1px solid #ccc"
    },
    initialize: function(editor, config) {
        var canvas;
        canvas = editor.getCanvas();

        this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        this.borderRange = "all";
        this.borderColor = "#4174D9";
        this.tableSelect = _NULL;
        this.selectedBoundary = _NULL;

    },

    setBorderRange: function(value) {
        this.borderRange = value;
    },

    setTableSelect: function(tableSelect) {
        this.tableSelect = tableSelect;
        this.selectedBoundary = tableSelect.getSelected();
    },

    changeTopBorderStyle: function(tdArr, styleType, value) {
        var style = {};
        var boundary = this.selectedBoundary;
        var borderStyle, tdArray;
        var indexer = this.tableSelect.getIndexer();
        var tempBoundary;

        if (boundary.top == 0) {
            borderStyle = "borderTop" + styleType;
            tempBoundary = new Trex.TableUtil.Boundary({
                "top": boundary.top,
                "bottom": boundary.top,
                "left": boundary.left,
                "right": boundary.right
            });

        } else {
            borderStyle = "borderBottom" + styleType;
            tempBoundary = new Trex.TableUtil.Boundary({
                "top": boundary.top - 1,
                "bottom": boundary.top - 1,
                "left": boundary.left,
                "right": boundary.right
            });

        }

        tdArray = indexer.getTdArr(tempBoundary);
        style[borderStyle] = value;

        for (var i = 0; i < tdArray.length; i++) {
            $tx.setStyle(tdArray[i], style);
        }
    },

    changeBottomBorderStyle: function(tdArr, styleType, value) {
        var style = {};
        var boundary = this.selectedBoundary;
        var borderStyle, tdArray, tempBoundary;
        var indexer = this.tableSelect.getIndexer();

        borderStyle = "borderBottom" + styleType;
        tempBoundary = new Trex.TableUtil.Boundary({
            "top": boundary.bottom,
            "bottom": boundary.bottom,
            "left": boundary.left,
            "right": boundary.right
        });

        tdArray = indexer.getTdArr(tempBoundary);
        style[borderStyle] = value;

        for (var i = 0; i < tdArray.length; i++) {
            $tx.setStyle(tdArray[i], style);
        }
    },

    changeLeftBorderStyle: function(tdArr, styleType, value) {
        var style = {};
        var boundary = this.selectedBoundary;
        var borderStyle, tdArray;
        var indexer = this.tableSelect.getIndexer();
        var tempBoundary;

        if (boundary.left == 0) {
            borderStyle = "borderLeft" + styleType;
            tempBoundary = new Trex.TableUtil.Boundary({
                "top": boundary.top,
                "bottom": boundary.bottom,
                "left": boundary.left,
                "right": boundary.left
            });

        } else {
            borderStyle = "borderRight" + styleType;
            tempBoundary = new Trex.TableUtil.Boundary({
                "top": boundary.top,
                "bottom": boundary.bottom,
                "left": boundary.left - 1,
                "right": boundary.left - 1
            });

        }

        tdArray = indexer.getTdArr(tempBoundary);
        style[borderStyle] = value;

        for (var i = 0; i < tdArray.length; i++) {
            $tx.setStyle(tdArray[i], style);
        }
    },

    changeRightBorderStyle: function(tdArr, styleType, value) {
        var style = {};
        var boundary = this.selectedBoundary;
        var borderStyle, tdArray;
        var indexer = this.tableSelect.getIndexer();
        var tempBoundary;

        borderStyle = "borderRight" + styleType;
        tempBoundary = new Trex.TableUtil.Boundary({
            "top": boundary.top,
            "bottom": boundary.bottom,
            "left": boundary.right,
            "right": boundary.right
        });

        tdArray = indexer.getTdArr(tempBoundary);
        style[borderStyle] = value;

        for (var i = 0; i < tdArray.length; i++) {
            $tx.setStyle(tdArray[i], style);
        }
    },

    changeInBorderStyle: function(tdArr, styleType, value) {
        var colStyle = {};
        var rowStyle = {};
        var boundary = this.selectedBoundary;
        var colTdArray, rowTdArray, colBorderStyle, rowBorderStyle;
        var colBoundary, rowBoundary;
        var indexer = this.tableSelect.getIndexer();

        colBorderStyle = "borderBottom" + styleType;
        colBoundary = new Trex.TableUtil.Boundary({
            "top": boundary.top,
            "bottom": boundary.bottom - 1,
            "left": boundary.left,
            "right": boundary.right
        });
        colTdArray = indexer.getTdArr(colBoundary);
        colStyle[colBorderStyle] = value;

        for (var i = 0; i < colTdArray.length; i++) {
            $tx.setStyle(colTdArray[i], colStyle);
        }

        rowBorderStyle = "borderRight" + styleType;
        rowBoundary = new Trex.TableUtil.Boundary({
            "top": boundary.top,
            "bottom": boundary.bottom,
            "left": boundary.left,
            "right": boundary.right - 1
        });
        rowTdArray = indexer.getTdArr(rowBoundary);
        rowStyle[rowBorderStyle] = value;

        for (var i = 0; i < rowTdArray.length; i++) {
            $tx.setStyle(rowTdArray[i], rowStyle);
        }
    },

    changeOutBorderStyle: function(tdArr, styleType, value) {
        this.changeTopBorderStyle(tdArr, styleType, value);
        this.changeBottomBorderStyle(tdArr, styleType, value);
        this.changeLeftBorderStyle(tdArr, styleType, value);
        this.changeRightBorderStyle(tdArr, styleType, value);
    },

    changeNoneBorderStyle: function(tdArr, styleType, value) {


    },

    changeBorderStyle: function(tdArr, styleType, value) {

        var borderRange = this.borderRange;
        switch (borderRange) {
            case "top":
                this.changeTopBorderStyle(tdArr, styleType, value);
                break;
            case "bottom":
                this.changeBottomBorderStyle(tdArr, styleType, value);
                break;
            case "left":
                this.changeLeftBorderStyle(tdArr, styleType, value);
                break;
            case "right":
                this.changeRightBorderStyle(tdArr, styleType, value);
                break;
            case "in":
                this.changeInBorderStyle(tdArr, styleType, value);
                break;
            case "out":
                this.changeOutBorderStyle(tdArr, styleType, value);
                break;
            case "all":
                this.changeInBorderStyle(tdArr, styleType, value);
                this.changeOutBorderStyle(tdArr, styleType, value);
                break;
            case "none":
                this.changeInBorderStyle(tdArr, styleType, value);
                this.changeOutBorderStyle(tdArr, styleType, value);
                break;
            default:
                break;
        }
    },
    changeBorderColor: function(tdArr, value) {
        if (value != _NULL) {
            this.borderColor = value;
        }
        this.changeBorderStyle(tdArr, "Color", this.borderColor);
    },
    changeBorderType: function(tdArr, value) {
        this.changeBorderStyle(tdArr, "Style", value);
        this.changeBorderColor(tdArr);
    },
    changeBorderHeight: function(tdArr, value) {
        var width = value.toPx();
        this.changeBorderStyle(tdArr, "Width", width);
        this.changeBorderColor(tdArr);
    }

});
(function() {

    Trex.Table.TemplateLoader = Trex.Class.create({
        initialize: function() {
            this.templateList = _NULL;
        },
        getTemplate: function(index, callback) {
            if (isNaN(index)) {
                return;
            }

            if (this.templateList) {
                callback(new TableTemplate(this.templateList[index]));
            } else {
                var self = this;
                this.loadTemplate(function(templateList) {
                    self.templateList = templateList;
                    callback(new TableTemplate(self.templateList[index]));
                });
            }
        },
        loadTemplate: function(onLoadComplete) {
            var url = this.getJSBasePath() + "trex/modules/table/async/template_data" + (Trex._JS_MIN ? '.min' : '') + ".js";
            if (EditorJSLoader.getOption('environment') == 'development') {
                url += '?dummy=' + (new Date()).getTime();
            }
            EditorJSLoader.asyncLoadModule({
                url: TrexConfig.getUrl(url),
                callback: function() {
                    var templateList = getTableTemplateList();
                    onLoadComplete(templateList);
                }
            });
        },
        getJSBasePath: function() {
            var basePath;
            try {
                basePath = EditorJSLoader.getJSBasePath("editor.js");
            } catch (e) {
                basePath = EditorJSLoader.getJSBasePath();
            }
            return basePath;
        }
    });


    var TableTemplate = Trex.Class.create({
        initialize: function(templateData) {
            this.templateData = templateData;
        },
        apply: function(table) {
            var tableMatrixer = new Trex.Tool.Table.TableCellMatrixer(table);
            var tdMatrix = tableMatrixer.getTdMatrix();
            var self = this;

            for (var i = 0; i < tdMatrix.length; i++) {
                for (var j = 0; j < tdMatrix[i].length; j++) {
                    self.setCellStyle(tdMatrix[i][j], {
                        isEvenRow: (i % 2) == 1,
                        isFirstRow: i == 0,
                        isLastRow: i == tdMatrix.length - 1,
                        isFirstCol: j == 0,
                        isLastCol: (j == tdMatrix[i].length - 1)
                    });
                }
            }
        },
        setCellStyle: function(elTd, truthMap) {
            var t = this.templateData;
            var style = Object.extend({}, t['common']);
            Object.extend(style, (truthMap.isEvenRow) ? t['evenRow'] : t['oddRow']);
            Object.extend(style, (truthMap.isFirstRow) ? t['firstRow'] : (truthMap.isLastRow) ? t['lastRow'] : {});
            Object.extend(style, (truthMap.isLastCol) ? t['lastCol'] : {});
            Object.extend(style, (truthMap.isFirstCol) ? t['firstCol'] : {});
            txlib.setStyle(elTd, style);
        }
    });
})();

/**
 * Created by sungwon on 14. 7. 21.
 */
Trex.module("page up & down", function(editor, toolbar, sidebar, canvas, config) {
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(doc) {
        function exeHandler() {
            moveScroll();
        }

        function moveScroll() {
            var top = (_WIN.pageYOffset || _DOC.documentElement.scrollTop) - (_DOC.documentElement.clientTop || 0);
            var left = (_WIN.pageXOffset || _DOC.documentElement.scrollLeft) - (_DOC.documentElement.clientLeft || 0);

            function fixscroll(e) {
                window.scrollTo(left, top);
            }

            $tx.observe(_WIN, 'scroll', fixscroll);

            setTimeout(function() {
                $tx.stopObserving(_WIN, 'scroll', fixscroll);
            }, 30);

        }
        $tx.observe(doc, 'keydown', function(e) {
            if (/^(33|34)$/.test(e.keyCode)) {
                exeHandler();
            }

        });

    });
});
Trex.module("table resize dragger", function(editor, toolbar, sidebar, canvas) {
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {

        var wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        var doc = wysiwygPanel.getDocument();
        var win = wysiwygPanel.getWindow();
        var body = doc.body;
        var MIN_WIDTH = 20;
        var w3cBoxModelWorks;

        var colDragger = $tom.collect(canvas.wysiwygEl, ".tx-table-col-resize-dragger");
        var rowDragger = $tom.collect(canvas.wysiwygEl, ".tx-table-row-resize-dragger");

        var isDragging = _FALSE;
        var _resizeRow = _FALSE,
            _resizeCol = _FALSE;

        var currentTable, currentTD, currentLeftTD, currentRightTD;
        var currentLeftTDWidth, currentRightTDWidth, currentTDHeight;
        var currentTableWidth, currentPointX, currentPointY;

        var currentNode, currentDragger;
        var movingX, movingY;
        var leftTdArray, rightTdArray, topTdArray;
        var leftWidthArr, rightWidthArr, topHeightArr;

        var posiX, posiY, elem;

        var EDGE_TYPE = {
            TOP: "EDGE_TOP",
            BOTTOM: "EDGE_BOTTOM",
            LEFT: "EDGE_LEFT",
            RIGHT: "EDGE_RIGHT",
            NONE: "NONE",
            TABLE_LEFT: "TABLE_LEFT",
            TABLE_LEFT: "TABLE_TOP"
        };

        var edgeType = EDGE_TYPE.NONE;

        var initDragger = function() {

            isDragging = _FALSE;
            _resizeRow = _resizeCol = _FALSE;
            currentNode = _NULL;
            currentDragger = _NULL;

            currentTable = currentTD = _NULL;
            currentLeftTD = currentRightTD = _NULL;

            rightTdArray = leftTdArray = topTdArray = _NULL;
            leftWidthArr = rightWidthArr = topHeightArr = _NULL;

            movingX = movingY = 0;
            currentTableWidth = currentPointX = currentPointY = 0;
            currentLeftTDWidth = currentRightTDWidth = currentTDHeight = 0;
        };

        var mouseDownHandler = function() {
            currentTable = $tom.find(currentNode, "table");
            currentTable.style.breakWord = "break-all";
            // KEDITOR table 속성 설정.
            if (currentTable == _NULL) {
                return _NULL;
            }
            if (edgeType == EDGE_TYPE.TABLE_TOP || edgeType == EDGE_TYPE.TABLE_LEFT) {
                return _NULL;
            }
            isDragging = _TRUE;
            currentTableWidth = currentTable.offsetWidth;

            if (edgeType != EDGE_TYPE.NONE) {
                $tx.stop(elem);
                showDragger();
            }

            switch (edgeType) {
                case EDGE_TYPE.LEFT:
                    makeTDArrForLeftEdge();
                    startResizeCol();
                    break;
                case EDGE_TYPE.RIGHT:
                    makeTDArrForRightEdge();
                    startResizeCol();
                    break;
                case EDGE_TYPE.TOP:
                    makeTDArrForTopEdge();
                    startResizeRow();
                    break;
                case EDGE_TYPE.BOTTOM:
                    makeTDArrForBottomEdge();
                    startResizeRow();
                    break;
            }
        };

        var makeTDArrForLeftEdge = function() {
            var indexer = new Trex.TableUtil.Indexer(currentTable);
            var curBoundery = indexer.getBoundary(currentNode);

            if (curBoundery.left > 0) {
                leftTdArray = indexer.getTdArrHasRight(curBoundery.left - 1);
                rightTdArray = indexer.getTdArrHasLeft(curBoundery.left);
            }
        };

        var makeTDArrForRightEdge = function() {
            var indexer = new Trex.TableUtil.Indexer(currentTable);
            var curBoundery = indexer.getBoundary(currentNode);
            var colSize = indexer.getColSize();

            leftTdArray = indexer.getTdArrHasRight(curBoundery.right);

            if (curBoundery.right < colSize - 1) {
                rightTdArray = indexer.getTdArrHasLeft(curBoundery.right + 1);
            }
        };

        var makeTDArrForTopEdge = function() {
            var indexer = new Trex.TableUtil.Indexer(currentTable);
            var curBoundery = indexer.getBoundary(currentNode);

            topTdArray = indexer.getTdArrHasBottom(curBoundery.top - 1);
        };

        var makeTDArrForBottomEdge = function() {
            var indexer = new Trex.TableUtil.Indexer(currentTable);
            var curBoundery = indexer.getBoundary(currentNode);

            topTdArray = indexer.getTdArrHasTop(curBoundery.bottom);
        };

        var mouseupHandler = function() {
            switch (edgeType) {
                case EDGE_TYPE.LEFT:
                case EDGE_TYPE.RIGHT:
                    stopResizeCol();
                    break;
                case EDGE_TYPE.TOP:
                case EDGE_TYPE.BOTTOM:
                    stopResizeRow();
                    break;
            }
        };

        var mouseClickHandler = function(ev) {
            if (edgeType == EDGE_TYPE.TABLE_TOP || edgeType == EDGE_TYPE.TABLE_LEFT) {
                try {
                    edgeType = EDGE_TYPE.NONE;
                    showDragger();
                    var tb = $tom.find(currentNode, "table");
                    var cr = body.createControlRange();
                    cr.add(tb);
                    cr.select();
                } catch (e) {}
                $tx.stop(ev);
                return _NULL;
            }
        }

        var mousemoveHandler = function() {
            if (isDragging) {
                currentDragger = getDragger();
                moveDraggingAction();
            } else {
                moveUnDraggingAction();
            }
        };

        var moveDraggingAction = function() {
            switch (edgeType) {
                case EDGE_TYPE.LEFT:
                case EDGE_TYPE.RIGHT:
                    moveCalcResizeCol();
                    break;
                case EDGE_TYPE.TOP:
                case EDGE_TYPE.BOTTOM:
                    moveCalcResizeRow();
                    break;
            }
        };

        var moveUnDraggingAction = function() {
            var td = $tom.find($tx.element(elem), "td");
            var isTxInfo = $tom.find(td, ".txc-info");
            if (td && !isTxInfo) {
                currentNode = td;
                edgeType = getEdgeType(currentNode);
                showDragger();
            } else {
                edgeType = EDGE_TYPE.NONE;
                showDragger();
            }
        };

        var getDragger = function() {
            var dragger = _NULL;
            switch (edgeType) {
                case EDGE_TYPE.LEFT:
                case EDGE_TYPE.RIGHT:
                    dragger = colDragger;
                    break;
                case EDGE_TYPE.TOP:
                case EDGE_TYPE.BOTTOM:
                    dragger = rowDragger;
                    break;
            }
            return dragger;
        };

        var startResizeCol = function() {
            isDragging = _TRUE;
            _resizeCol = _FALSE;
            leftWidthArr = [];
            rightWidthArr = [];
            var i = 0;

            if (leftTdArray) {
                for (i = 0; i < leftTdArray.length; i++) {
                    leftWidthArr.push(leftTdArray[i].offsetWidth);
                }
                currentLeftTDWidth = minimumOfArray(leftWidthArr);
                for (i = 0; i < leftTdArray.length; i++) {
                    if (currentLeftTDWidth == leftWidthArr[i]) {
                        currentLeftTD = leftTdArray[i];
                        break;
                    }
                }
            }
            if (rightTdArray) {
                for (i = 0; i < rightTdArray.length; i++) {
                    rightWidthArr.push(rightTdArray[i].offsetWidth);
                }
                currentRightTDWidth = minimumOfArray(rightWidthArr);
                for (i = 0; i < rightTdArray.length; i++) {
                    if (currentRightTDWidth == rightWidthArr[i]) {
                        currentRightTD = rightTdArray[i];
                        break;
                    }
                }
            }
            currentPointX = $tx.getCoordsTarget(currentDragger).left;
        };

        var moveCalcResizeCol = function() {
            if (isDragging) {
                _resizeCol = _TRUE;
                var distX = parseInt(posiX - $tom.getScrollLeft(doc) - currentPointX);
                var left;

                if (currentLeftTD && currentRightTD) {
                    left = calcMiddleCol(currentLeftTD, distX);
                }

                if (currentLeftTD && currentRightTD == _NULL) {
                    left = calcLeft(currentLeftTD, distX)
                }

                if (currentLeftTD == _NULL && currentRightTD) {
                    left = calcRight(currentRightTD, distX);
                }
                if (left) {
                    $tx.setStyle(currentDragger, {
                        "left": left.toPx()
                    });
                }
            }
        };

        var calcMiddleCol = function(currentLeftTD, distX) {
            var bothWidth, movingLeftWidth, movingRightWidth, tdRect, left;
            bothWidth = currentLeftTDWidth + currentRightTDWidth;
            movingLeftWidth = currentLeftTDWidth + distX;
            movingRightWidth = currentRightTDWidth - distX;

            tdRect = $tx.getCoordsTarget(currentLeftTD);
            if (movingLeftWidth >= MIN_WIDTH && movingRightWidth >= MIN_WIDTH) {
                left = posiX - $tom.getScrollLeft(doc);
            } else if (movingLeftWidth <= MIN_WIDTH) {
                movingLeftWidth = MIN_WIDTH;
                movingRightWidth = bothWidth - movingLeftWidth;
                left = tdRect.left - $tom.getScrollLeft(doc) + movingLeftWidth;
            } else if (movingRightWidth <= MIN_WIDTH) {
                movingRightWidth = MIN_WIDTH;
                movingLeftWidth = bothWidth - movingRightWidth;
                left = tdRect.left - $tom.getScrollLeft(doc) + movingLeftWidth;
            }

            movingX = movingLeftWidth - currentLeftTDWidth;
            return left;
        };

        var calcLeft = function(currentLeftTD, distX) {

            var movingLeftWidth, tdRect, left;
            movingLeftWidth = currentLeftTDWidth + distX;
            tdRect = $tx.getCoordsTarget(currentLeftTD);
            if (movingLeftWidth < MIN_WIDTH) {
                movingLeftWidth = MIN_WIDTH;
            }

            left = tdRect.left - $tom.getScrollLeft(doc) + movingLeftWidth;
            movingX = movingLeftWidth - currentLeftTDWidth;
            return left;
        };

        var calcRight = function(currentRightTD, distX) {

            var movingRightWidth, tdRect, left;
            movingRightWidth = currentRightTDWidth - distX;
            tdRect = $tx.getCoordsTarget(currentRightTD);
            if (movingRightWidth < MIN_WIDTH) {
                movingRightWidth = MIN_WIDTH;
            }

            left = tdRect.left + movingRightWidth;
            movingX = currentRightTDWidth - movingRightWidth;
            return left;
        };

        var stopResizeCol = function() {
            resizeWidth();
            initDragger();
            moveUnDraggingAction();
            saveHistory();
        };

        var resizeWidth = function() {
            var i;
            if (leftTdArray) {
                for (i = 0; i < leftTdArray.length; i++) {
                    leftTdArray[i].style.width = (leftWidthArr[i] + movingX).toPx();
                }
            }
            if (rightTdArray) {
                for (i = 0; i < rightTdArray.length; i++) {
                    rightTdArray[i].style.width = (rightWidthArr[i] - movingX).toPx();
                }
            }
            if (leftTdArray && rightTdArray == _NULL) {
                resizeTableWidth();
            }
        };

        var startResizeRow = function() {
            isDragging = _TRUE;
            _resizeRow = _FALSE;
            currentTDHeight = currentNode.offsetHeight;
            topHeightArr = [];

            if (topTdArray) {
                var i;
                for (i = 0; i < topTdArray.length; i++) {
                    topHeightArr.push(parseInt(topTdArray[i].offsetHeight));
                }
                currentTDHeight = minimumOfArray(topHeightArr);
                for (i = 0; i < topTdArray.length; i++) {
                    if (currentTDHeight == topHeightArr[i]) {
                        currentTD = topTdArray[i];
                    }
                }
            }
            currentPointY = $tx.getCoordsTarget(currentDragger).top;
        };

        var moveCalcResizeRow = function() {
            if (isDragging) {
                _resizeRow = _TRUE;
                var distY = posiY - $tom.getScrollTop(doc) - currentPointY;
                var movingHeight = currentTDHeight + parseInt(distY);
                var tdRect = $tx.getCoordsTarget(currentTD);
                var top = _NULL;
                if (movingHeight < 0) {
                    movingHeight = 0;
                    top = tdRect.top + movingHeight - $tom.getScrollTop(doc);
                } else {
                    top = posiY - $tom.getScrollTop(doc);
                }

                if (top) {
                    $tx.setStyle(currentDragger, {
                        "top": top.toPx()
                    });
                }
                movingY = movingHeight - currentTDHeight;
            }
        };

        var stopResizeRow = function() {
            if (_resizeRow) resizeHeight();
            initDragger();
            moveUnDraggingAction();
            saveHistory();
        };

        var resizeHeight = function() {
            if (topTdArray) {
                try{
                    if(topTdArray[0]){
                        var tr = topTdArray[0].parentNode;
                        if(tr && tr.nodeName == "TR"){
                            tr.style.height = '';
                            tr.removeAttribute('height');
                        }
                        var table = null;
                        table = tr.parentNode;
                        if(table && table.nodeName != "TABLE") table = table.parentNode;
                        if(table && table.nodeName == "TABLE" && table.style.height){
                            table.style.height = (table.offsetHeight + movingY) + 'px';
                        }
                    }
                }catch(e){}
                for (var i = 0; i < topTdArray.length; i++) {
                    var height = topHeightArr[i] + movingY;
                    if (height < 0) {
                        height = 20;
                    }
                    topTdArray[i].style.height = height.toPx();
                }
            }
        };

        (function checkW3cBoxModel() {
            var div = doc.createElement("div");
            body.appendChild(div);
            div.style.width = div.style.paddingLeft = "1px";
            w3cBoxModelWorks = div.offsetWidth === 2;
            body.removeChild(div);
        })();

        var getEdgeType = function(node) {
            var rect, edgeType = EDGE_TYPE.NONE;
            //HISTORY. 아래 코드는 jQuery 1.6.4 에서 훔쳐옴..
            //버그 재현 코드
            /*
<TABLE><TBODY><TR><TD style="BORDER-TOP: #ff8b16 50px solid">
여기에 테이블 삽입.
</TD></TR></TBODY></TABLE>
			*/
            if ("getBoundingClientRect" in document.documentElement) {
                try {
                    var doc = node.ownerDocument,
                        docElem = doc.documentElement,
                        body = doc.body;
                    var box = node.getBoundingClientRect(),
                        win = $tom.getWindow(doc),
                        clientTop = docElem.clientTop || body.clientTop || 0,
                        clientLeft = docElem.clientLeft || body.clientLeft || 0,
                        scrollTop = win.pageYOffset || w3cBoxModelWorks && docElem.scrollTop || body.scrollTop,
                        scrollLeft = win.pageXOffset || w3cBoxModelWorks && docElem.scrollLeft || body.scrollLeft,
                        top = box.top + scrollTop - clientTop,
                        left = box.left + scrollLeft - clientLeft;
                    rect = {
                        top: top,
                        left: left,
                        bottom: top + node.offsetHeight,
                        right: left + node.offsetWidth
                    };
                } catch (e) {
                    rect = _NULL;
                }
            }
            //기존 코드는 fallback.
            if (!rect) {
                rect = $tx.getCoordsTarget(node);
            }
            if ((posiX - rect.left) < 5 && node.cellIndex != 0) {
                edgeType = EDGE_TYPE.LEFT;
            } else if ($tx.msie && (posiX - rect.left) < 5 && node.cellIndex == 0) {
                edgeType = EDGE_TYPE.TABLE_LEFT;
            } else if ((rect.right - 5) < posiX) {
                edgeType = EDGE_TYPE.RIGHT;
            } else if ((posiY - rect.top) < 5 && node.parentNode.rowIndex != 0) {
                edgeType = EDGE_TYPE.TOP;
            } else if ($tx.msie && (posiY - rect.top) < 5 && node.parentNode.rowIndex == 0) {
                edgeType = EDGE_TYPE.TABLE_TOP;
            } else if ((rect.bottom - 5) < posiY) {
                edgeType = EDGE_TYPE.BOTTOM;
            }
            return edgeType;
        };

        var showDragger = function() {
            canvas.query(function(processor) {
                if (processor.table) {
                    if (processor.table.isDuringSelection() || canvas.config.readonly) {
                        edgeType = EDGE_TYPE.NONE;
                    }
                    switch (edgeType) {
                        case EDGE_TYPE.LEFT:
                        case EDGE_TYPE.RIGHT:
                        case EDGE_TYPE.TABLE_LEFT:
                            $tx.hide(rowDragger);
                            $tx.show(colDragger);
                            makeColDragger(colDragger);
                            currentDragger = colDragger;
                            break;
                        case EDGE_TYPE.TOP:
                        case EDGE_TYPE.BOTTOM:
                        case EDGE_TYPE.TABLE_TOP:
                            $tx.hide(colDragger);
                            $tx.show(rowDragger);
                            makeRowDragger(rowDragger);
                            currentDragger = rowDragger;
                            break;
                        case EDGE_TYPE.NONE:
                            $tx.hide(colDragger);
                            $tx.hide(rowDragger);
                            break;
                    }
                }
            });
        };

        var makeColDragger = function(dragger) {
            if (dragger == _NULL) return;
            var left;
            $tx.setStyle(dragger, { "cursor": edgeType == EDGE_TYPE.TABLE_LEFT ? "move" : "col-resize" });
            if (isDragging) {
                left = $tx.getCoordsTarget(dragger).left;
                $tx.setStyle(dragger, {
                    "width": "2px",
                    "height": wysiwygPanel.el.clientHeight.toPx(),
                    "border": "1px dotted #81aFFC",
                    "background": "",
                    "left": left.toPx()
                });
                $tx.setOpacity(colDragger, 1);

            } else {
                left = posiX - $tom.getScrollLeft(doc);
                $tx.setStyle(dragger, {
                    "width": "2px",
                    "height": wysiwygPanel.el.clientHeight.toPx(),
                    "border": "",
                    "background": "#fff",
                    "left": left.toPx()
                });
                $tx.setOpacity(colDragger, 0);
            }
        };

        var makeRowDragger = function(dragger) {
            if (dragger == _NULL) return;
            var top = _NULL;
            $tx.setStyle(dragger, { "cursor": edgeType == EDGE_TYPE.TABLE_TOP ? "move" : "row-resize" });
            if (isDragging) {
                top = $tx.getCoordsTarget(dragger).top;
                $tx.setStyle(dragger, {
                    "height": "2px",
                    "border": "1px dotted #81aFFC",
                    "background": "",
                    "top": top.toPx(),
                    "width": (wysiwygPanel.el.clientWidth - 2) + 'px'
                });
                $tx.setOpacity(rowDragger, 1);
            } else {
                top = posiY - $tom.getScrollTop(doc);
                $tx.setStyle(dragger, {
                    "height": "2px",
                    "border": "",
                    "background": "#fff",
                    "top": top.toPx(),
                    "width": (wysiwygPanel.el.clientWidth - 2) + 'px'
                });
                $tx.setOpacity(rowDragger, 0);
            }
        };

        /**
         * when I pasted MS office table, delete width or width style.
         */
        var resizeTableWidth = function() {
            var movingWidth = 0;
            if (currentTableWidth) {
                movingWidth = parseInt(currentTableWidth) + movingX;
                currentTable.width = movingWidth.toPx();
                currentTable.style.width = movingWidth.toPx();
            }
        };
        /**
         * dragger event binding
         */
        var eventBinding = function() {
            $tx.observe(_DOC.body, "mouseup", function(ev) {
                initElement(ev);
                mouseupHandler();
            });

            if ($tx.msie) {
                $tx.observe(body, "mousemove", function(ev) {
                    initElement(ev);
                    mousemoveHandler();
                });

                $tx.observe(body, "mouseup", function(ev) {
                    initElement(ev);
                    mouseupHandler();
                });
            } else {
                $tx.observe(win, "mousemove", function(ev) {
                    initElement(ev);
                    mousemoveHandler();
                });

                $tx.observe(win, "mouseup", function(ev) {
                    initElement(ev);
                    mouseupHandler();
                });
            }

            if ($tx.safari) {
                $tx.observe(_DOC.body, "mousemove", function(ev) {
                    if (isDragging) {
                        initElementForSafari(ev);
                        mousemoveHandler();
                    }
                });
            }

            $tx.observe(colDragger, "mousedown", function(ev) {
                initElement(ev);
                mouseDownHandler();
            });

            $tx.observe(rowDragger, "mousedown", function(ev) {
                initElement(ev);
                mouseDownHandler();
            });

            if ($tx.msie) {
                $tx.observe(rowDragger, "click", function(ev) {
                    mouseClickHandler(ev);
                });
            }
        };

        var initElement = function(ev) {
            elem = ev;
            posiX = posX(elem);
            posiY = posY(elem);
        };

        var initElementForSafari = function(ev) {
            elem = ev;
            posiX = posX(elem) - $tx.getCoords(canvas.wysiwygEl).left + doc.body.scrollLeft;
            posiY = posY(elem) - $tx.getCoords(canvas.wysiwygEl).top + doc.body.scrollTop;
        };

        // tabledragger 에서 추가된 utility, check!!
        var posX = function(e) {
            var posx = 0;
            e = e || win.event;
            if (e.pageX) {
                posx = e.pageX;
            } else
            if (e.clientX) {
                posx = e.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft;
            }
            return posx;
        };

        var posY = function(e) {
            var posy = 0;
            e = e || win.event;
            if (e.pageY) {
                posy = e.pageY;
            } else
            if (e.clientY) {
                posy = e.clientY + doc.body.scrollTop + doc.documentElement.scrollTop;
            }
            return posy;
        };

        function minimumOfArray(array) {
            return Math.min.apply(Math, array);
        }

        function saveHistory() {
            // console.log("saveHistory");
            canvas.history.saveHistory();
        }

        initDragger();
        eventBinding();
    });
});
/**
 * 이미지 ContextMenu
 */
Trex.module("image contextmenu", function(editor, toolbar, sidebar, canvas, config) {
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
        var wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        var doc = wysiwygPanel.getDocument();
        var win = wysiwygPanel.getWindow();
        var body = doc.body;
        var _context = null;
        
        var initImageContext = function(){
            _context = new Trex.Image.ContextMenu(editor, toolbar, canvas, config);
        };        
        initImageContext();
    });
});
TrexConfig.addContextMenu(
    'image', {
        options: [
            { label:'image', title: Trex._I18N.g('image.property.title', '이미지 속성'), icon: "imageinfo", popup: "imageInfo" },
            { label:'image_edit', title: Trex._I18N.g('image_editor.title', '이미지 편집'), icon: "image_editor", popup: "imageEditor" },
            { label:'image_delete', title: Trex._I18N.g('image.delete', '이미지 삭제'), icon: "image_delete", eventname: "Delete" }
        ]
    }
);
Trex.Image = {};
Trex.Image.EDIT_TARGET = {};
Trex.Image.ContextMenu = Trex.Class.create({
    initialize: function(editor, toolbar, canvas, rootConfig) {
        var self = this;
        this._initializedId = ((rootConfig.initializedId) ? rootConfig.initializedId : "");
        this.config = rootConfig;
        this.menus = TrexConfig.getContextMenu('image').options;
        this.editor = editor;
        this.canvas = canvas;
        this.toolbar = toolbar;
        this.elContextMenu = document.getElementById('tx_image_contextmenu_div' + this._initializedId);
        this.imageInfo = new Trex.Image.ImageInfo(editor, toolbar, canvas, rootConfig, "property");
        this.imageEditor = {
            showPopup:function(_img){
                var key = "_IE_" + (new Date()).getTime().toString(16);
                Trex.Image.EDIT_TARGET[key] = _img;
                self.editor.getSidebar().getAttacher("image_edit").execute('instance=' + self.editor.kEditor.instanceId + '&_TI=' + key);
            }
        };
        this.generateContextMenu();
        this.observeEvent();
    },
    /**
     * 컨텍스트 메뉴의 HTML을 생성한다
     */
    generateContextMenu: function() {
        var self = this;
        var menu, icon, text;
        var _ul = $(this.elContextMenu).find('ul');
        $.each(this.menus, function(idx, obj) {
            menu = $('<li class="tx-contextmenu ' + (obj.title == 'sepa' ? 'sepa' : 'menu') + '"></li>');
            var aWrapper = null;
            if (obj.title != 'sepa' && $tx.msie && document.documentMode < 8) {
                aWrapper = $('<a href="javascript:;" class="tx-contextmenu_a"></a>');
                menu.append(aWrapper);
            }
            if (obj.title != 'sepa') {
                icon = $('<div class="ts-contextmenu-icon' + (typeof(obj.icon) ? ' ' + obj.icon : '') + '"></div>');
                text = $('<span>' + obj.title + '</span>');
                menu.data('eventname', obj.eventname)
                    .data('popupname', obj.popup);
                (aWrapper ? aWrapper : menu).append(icon).append(text);

                if (obj.check) {
                    menu.addClass(obj.check == 'select' ? 'check1' :
                        obj.check == 'select_rows' ? 'check3' :
                        obj.check == 'select_cols' ? 'check4' :
                        'check2');
                }
            }

            $(_ul).append(menu);
        });
    },
    showContextMenu: function(e, elem) {
        this.currentTarget = elem;    
        var wrapper_top = $(this.editor.getWrapper()).offset().top,
            wrapper_left = $(this.editor.getWrapper()).offset().left,
            canvas_top = $(this.canvas.elContainer).offset().top - wrapper_top,
            canvas_left = $(this.canvas.elContainer).offset().left - wrapper_left,
            canvas_width = $(this.canvas.elContainer).width(),
            canvas_height = $(this.canvas.elContainer).height(),
            pointerX = e.clientX + 5,
            pointerY = e.clientY + 5,
            context_top = pointerY + canvas_top,
            context_left = pointerX + canvas_left,
            context_width = $(this.elContextMenu).outerWidth(),
            context_height = $(this.elContextMenu).outerHeight(),
            overflow_width = context_width + pointerX - canvas_width,
            overflow_height = context_height + pointerY - canvas_height;
        if (overflow_height > 0) {
            context_top -= overflow_height;
        }

        if (overflow_width > 0) {
            //context_left -= overflow_width;
            context_left -= context_width + 10; //마우스 왼쪽으로 띄우기
        }

        context_top = (context_top < 0 ? 0 : context_top);
        context_left = (context_left < 0 ? 0 : context_left);

        this.elContextMenu.style.top = context_top.toPx();
        this.elContextMenu.style.left = context_left.toPx();

        /**
         * 같은 도메인의 이미지만 Canvas가 처리할 수 있음.
         */
        var img_editor = $('.image_editor', this.elContextMenu).closest('li');
        var _img_src = this.currentTarget.src;
        if(_img_src.search(/^data:/i) == -1 && _img_src.toLowerCase().indexOf(document.location.hostname) == -1){
            img_editor.hide();
        }else{
            img_editor.show();
        }

        $tx.show(this.elContextMenu);
        $tx.stop(e);
    },
    hideContextMenu: function() {
        $tx.hide(this.elContextMenu);
    },
    observeEvent: function() {
        var self = this;

        //컨텍스트 메뉴 제어
        this.canvas.observeJob(Trex.Ev.__CANVAS_CONTEXTMENU_SHOW, function(e) {
            var _el = $tx.findElement(e, 'img');
            if (_el.tagName && _el.tagName.toLowerCase() == 'img') {
                self.showContextMenu(e, _el);
                $tx.stop(e);
            }
        });
        this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(e) {
            self.hideContextMenu();
        });
        this.toolbar.observeJob(Trex.Ev.__TOOL_CLICK, function(identity) {
            self.hideContextMenu();
        });

        //각 메뉴에 이벤트 bind
        $(this.elContextMenu).find('li')
            .on('click', function(e) {
                if ($(this).hasClass('disable')) return;
                if ($(this).data('popupname')) {
                    self.showPopup($(this).data('popupname'));
                    e.preventDefault();
                    return;
                }else if($(this).data('eventname')) {
                    self['exec' + $(this).data('eventname')]();
                    e.preventDefault();
                    return;
                }
                e.preventDefault();
            });
        
    },
    showPopup: function(name) {
        if(this[name]){
            this.hideContextMenu();
            this[name].showPopup(this.currentTarget);
        }
    },
    execDelete: function(){
        $(this.currentTarget).remove();
        this.hideContextMenu();
        this.canvas.history.saveHistory();
    }
});
Trex.MarkupTemplate.add(
    'image.property', [
        '<div class="layer_top">',
        '#{title}',
        '</div>',
        '<div class="tx-menu-inner">',
        '    <div style="position:absolute;top:-2000px;left:-2000px;width:10px;height:10px;overflow:hidden;"><canvas class="tmp_canvas" width="1" height="1"></canvas></div>',
        '<div style="position:absolute;top:-2000px;left:-2000px;width:10px;height:10px;overflow:hidden;"><img src="" class="tmp_img"></div>',
        '    <dl>',
        // '        <dt>#{title}',
        // '        </dt>',
        '        #{if:preview==true}<dd class="prev_image" style="text-align:left;border:1px solid #e0e0e0;/*margin-top:10px;*/padding:5px;overflow:hidden;"><img class="prev_img" src="" style="max-width:90%;max-height:100px;"></dd>#{/if:preview}',
        '        #{if:pasteTypeRadio==true}',
        '		 <dd class="imageInfo paste_type"><label style="padding-right:10px;">' +  Trex._I18N.g('image.paste.title2', "붙여넣기") + '</label>',
        '       <label class="paste_type paste_type_html"><input type="radio" name="paste_type" value="html" checked>' + Trex._I18N.g('image.paste.html_min', 'HTML') + '</label>',
        '       <label class="paste_type paste_type_image"><input type="radio" name="paste_type" value="image">' + Trex._I18N.g('image.paste.image_min', '이미지') + '</label>',
        '       <label class="paste_type paste_type_text"><input type="radio" name="paste_type" value="plain">' + Trex._I18N.g('image.paste.plain_min', '텍스트') + '</label>',
        '       </dd>',
        '        #{/if:pasteTypeRadio}',
        '		 <dd class="imageInfo imageAlign#{if:pasteTypeRadio==true} t_l#{/if:pasteTypeRadio}"><label>' +  Trex._I18N.g('image.width', "너비") + '</label><span class="g_select"><input type="text" name="txt_img_width" class="txt txt_sel txt_img_width" /><button name="btn_line_up" class="bg btn btn_up_arrow btn_width_up">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow btn_width_down">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span>',
        '		 <label class="inner">' +  Trex._I18N.g('image.height', "높이") + '</label><span class="g_select"><input type="text" name="txt_img_height" class="txt txt_sel txt_img_height" /><button name="btn_line_up" class="bg btn btn_up_arrow btn_height_up">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow btn_height_down">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span>',
        /** 정렬 숨김 처리 */
        // '           <label class="inner">' +  Trex._I18N.g('image.align', "정렬") + '</label>'
        // + '<span class="g_align"><span class="align_text"></span><button name="btn_text_align" class="bg btn btn_down_arrow1 btn_align">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        // '           </button></span>',
        // '			<ul class="align_option" style="display:none;">',
        // '				<li data-style="">' + /* Trex._I18N.g('cellattr.align.default','안함') +*/ '</li>',
        // '				<li data-style="left">' + Trex._I18N.g('cellattr.align.left', '왼쪽') + '</li>',
        // '				<li data-style="center">' + Trex._I18N.g('cellattr.align.center', '가운데') + '</li>',
        // '				<li data-style="right">' + Trex._I18N.g('cellattr.align.right', '오른쪽') + '</li>',
        // '			</ul>',
        '		    <label class="etc" style="margin-right:5px!important;float:right;line-height:25px;"><input type="checkbox" name="ratio" class="chk_img_ratio" style="vertical-align:middle;">' +  Trex._I18N.g('image.ratio', "비율유지") + '</label>',
        '        #{if:pasteTypeRadio==true}',
        '        <div class="disabled_area"></div>',
        '        #{/if:pasteTypeRadio}',
        '       </dd>',
        '		 <dd class="imageInfo" style="text-align:right;">',
        '           <button name="btn_reset" class="btn btn_ok custom btn_reset" style="margin-right:5px;min-width:63px;">' +  Trex._I18N.g('image.origin_size', "원본크기") + '</button>',
        '        #{if:pasteTypeRadio==true}',
        '        <div class="disabled_area"></div>',
        '        #{/if:pasteTypeRadio}',
        '        </dd>',
        '		<dd class="imageInfo line t_l">',
        '           <label>' +  Trex._I18N.g('table.detail.border_style', '테두리 스타일') + '</label>'
        + '<span class="g_line"><span class="line_style line1"></span><button name="btn_border_style" class="bg btn btn_down_arrow1">' + Trex._I18N.g('btn_down_arrow1', '펼치기') +
        '</button></span>',
        '			<ul class="line_style_option" style="display:none;">',
        '			#{for:line}<li class="#{class}" data-style="#{style}"><a href="javascript:;"></a></li>#{/for:line}',
        '			</ul>',
        '           <label class="inner">' +  Trex._I18N.g('table.detail.border_line', '테두리 두께') + '</label>'
        + '<span class="g_select"><input type="text" name="txt_border_line" class="txt txt_sel" /><button name="btn_line_up" class="bg btn btn_up_arrow btn_border_up">' + Trex._I18N.g('btn_up_arrow', '추가') +
        '</button><button name="btn_line_down" class="bg btn btn_down_arrow btn_border_down">' + Trex._I18N.g('btn_down_arrow', '삭제') +
        '</button></span>',
        '        #{if:pasteTypeRadio==true}',
        '        <div class="disabled_area"></div>',
        '        #{/if:pasteTypeRadio}',
        '		</dd>',
        '		<dd class="imageInfo line">',
        '           <label>' +  Trex._I18N.g('table.detail.border_color', '테두리 색') + '</label>'
        + '<input type="text" name="txt_border_color" class="txt txt_color" /><a href="#" class="btn_color"><span style="background:#dfeef9"></span></a>',
        '			<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:18000;"></div>',
        '        #{if:pasteTypeRadio==true}',
        '        <div class="disabled_area"></div>',
        '        #{/if:pasteTypeRadio}',
        '		</dd>',
        '		<dd class="imageInfo quality t_l">',
        '           <label><input type="checkbox" name="quality" class="img_jpeg_quality"><span>' +  Trex._I18N.g('image.jpeg_quality', 'JPEG 품질') + '</span></label>',
        '           <span class="ijqp_wrap" style="display:none;">: <input type="text" name="quality_p" class="img_jpeg_quality_percent" size=3 value="70"><span>%</span></span>',
        '			<span class="image_size_wrap">' +  Trex._I18N.g('image.size', 'Size') + ':<span class="image_size">-</span></span>',
        '        #{if:pasteTypeRadio==true}',
        '        <div class="disabled_area"></div>',
        '        #{/if:pasteTypeRadio}',
        '		</dd>',
        '    </dl>',
        '</div>',
        '<div class="layer_bottom">',
        '	<button class="btn btn_ok">' + TXMSG('@table.popup.ok') + '</button>',
        '   <span class="btn_paste_title" style="display:none;">' + Trex._I18N.g('image.paste.title', '붙여넣기 : ') + '</span>',
        '	<button class="btn btn_img" style="display:none;">' + Trex._I18N.g('image.paste.image_min', '이미지') + '</button>',
        '	<button class="btn btn_html" style="display:none;">' + Trex._I18N.g('image.paste.html_min', 'HTML') + '</button>',
        '	<button class="btn btn_plain" style="display:none;">' + Trex._I18N.g('image.paste.plain_min', '텍스트') + '</button>',
        '	<button class="btn btn_cancel">' + TXMSG('@table.popup.cancel') + '</button>',
        '   #{if:preview!=true}<label style="right: 10px; bottom: 5px; position: absolute;"><input type="checkbox" name="layer_opacity" class="chk_layer_opacity">' +  Trex._I18N.g('image.layer.opacity', "창 흐리게") + '</label>#{/if:preview}',
        '<div>'
    ].join("")
);
Trex.Image.ImageInfo = Trex.Class.create({
    initialize: function(editor, toolbar, canvas, rootConfig, infotype) {
        this._initializedId = ((rootConfig.initializedId) ? rootConfig.initializedId : "");
        this.config = rootConfig;
        this.editor = editor;
        this.canvas = canvas;
        this.toolbar = toolbar;
        this.infotype = infotype;
        this.elWrapper = document.getElementById('image_' + infotype + '_wrap' + this._initializedId);
        this.elEditorBlockUI = document.getElementById('tx_editor_blockui' + this._initializedId);
        this._keditor = KEditor.get(this._initializedId);
        this._isInit = false;
    },
    _init:function(){
        var info = {};
        info.line = [
            { "class": 'line1', "style": 'solid' },
            { "class": 'line2', "style": 'dotted' },
            { "class": 'line3', "style": 'double' }
        ];
        info.title = this.infotype == 'paste'?Trex._I18N.g('image.paste.popup.title', "붙여넣기 옵션"):Trex._I18N.g('image.property.title', "이미지 속성");
        info.preview = (this.infotype == 'paste');
        this.pasteTypeRadio = info.pasteTypeRadio = (this.infotype == 'paste') && true;
        Trex.MarkupTemplate.get("image.property").evaluateToDom(info, this.elWrapper);

        var _elMenu = this.elWrapper;
        this.elImgWidth = $tom.collect(_elMenu, '.txt_img_width');
        this.elImgHeight = $tom.collect(_elMenu, '.txt_img_height');
        this.elImgRatio = $tom.collect(_elMenu, '.chk_img_ratio');
        this.elOpacity = $tom.collect(_elMenu, '.chk_layer_opacity');
        this.elReset = $tom.collect(_elMenu, '.btn_reset');
        this.tmp_canvas = $tom.collect(_elMenu, '.tmp_canvas');
        this.img_size_wrap = $tom.collect(_elMenu, '.image_size_wrap');
        this.img_size = $tom.collect(_elMenu, '.image_size');
        this.elJpegQ = $tom.collect(_elMenu, '.img_jpeg_quality');
        this.elJpegQP = $tom.collect(_elMenu, '.img_jpeg_quality_percent');
        this.elJpegQWrap = $tom.collect(_elMenu, '.ijqp_wrap');
        this.qualityWrap = $tom.collect(_elMenu, '.quality');
        this.JPEG_Q_MIN = 50;
        this.JPEG_Q_MAX = 100;
        try{
            this.tmp_canvas.toDataURL('image/jpeg', 0);
            this.ctx = this.tmp_canvas.getContext("2d");
            this.ctx.save();
        }catch(E){
            // jepg quality not support
            this.tmp_canvas = null;
            this.ctx = null;
        }
        if(this.tmp_canvas == null || !(window.atob || window.Blob)){
            this.tmp_canvas = null;
            this.ctx = null; 
            this.qualityWrap.style.display = 'none';
        }
        var _self = this;
        this._origin = null;
        this._prevInfo = null;
        // this._align = null;
        this._img_tmp = $tom.collect(_elMenu, '.tmp_img');
        this._img = $tom.collect(_elMenu, '.prev_img');
        this._img_dd = $tom.collect(_elMenu, '.prev_image');
        function _imgLoad(){
            // img load
            _self._origin = {width:this.width, height:this.height};
            if(_self.infotype != 'property'){
                _self.elImgWidth.value = _self._origin.width;
                _self.elImgHeight.value = _self._origin.height;
                _self.elImgRatio.checked = true;
            }
            _self._img_tmp.width = _self.elImgWidth.value;
            _self._img_tmp.height = _self.elImgHeight.value;
            _displayImageSize(_self._origin_file_size);
        }
        function _imgError(){
            // img error
            // _self._origin = null;
        }
        this._img_tmp.onload = _imgLoad;
        this._img_tmp.onerror = _imgError;
        function _calCanvasImageSize(){
            if(!_self.tmp_canvas) return;
            if(!_self.elJpegQ.checked){
                _displayImageSize(_self._origin_file_size);
                return;
            }
            _self.img_size.innerHTML = '-';
            var img = _self._img_tmp;
            var _w = img.width, _h = img.height;
            var ctx = _self.ctx;
            var _canvas = _self.tmp_canvas;
            _canvas.width = _w;
            _canvas.height = _h;            
            ctx.clearRect(0, 0, _w, _h);
            ctx.drawImage(img, 0, 0, _w, _h);
            var q = (_self.elJpegQP.value||70) / 100;
            var data = _canvas.toDataURL('image/jpeg', q);
            /**
             * base64ToBlob 계산이 너무 오래 걸리고 메모리를 많이 먹는다. 그냥 3/4로 계산
             */
            // var blob = Trex.KEditor.base64ToBlob(data.split(',')[1], 'image/jpg');
            ctx.clearRect(0, 0, _w, _h);
            _canvas.width = 1;
            _canvas.height = 1;
            ctx.restore();
            if(_self.currentElem){
                _self.currentElem.src = data;
            }
            // _displayImageSize(blob.size);
            _displayImageSize(data.split(',')[1].length * (3/4));
            // delete blob;
            // blob = null;
            data = '';
            data = null;
        }
        function _displayImageSize(_size){
            var limit = _self._keditor.config.imageLimitSize||0;
            if(_size != null){
                _self.applyImageSize = _size;
                _self.img_size_wrap.style.display = '';
                _self.img_size.innerHTML = Trex._getDisplayFileSize(_size);
                $(_self.img_size)[limit == 0 || limit > _size?'removeClass':'addClass']('limit');
            }else{
                _self.applyImageSize = null;
                _self.img_size_wrap.style.display = 'none';
                _self.img_size.innerHTML = '-';
                $(_self.img_size)['removeClass']('limit');
            }
        }
        $tx.observe(this.elJpegQ, 'click', function(){
            if(this.checked){
                _self.elJpegQWrap.style.display = "";
                _calCanvasImageSize();
            }else{
                _self.elJpegQWrap.style.display = "none";
                if(_self.currentElem){
                    _self.currentElem.src = _self._originImage.src;
                }
                _displayImageSize(_self._origin_file_size);
            }
        });
        $tx.observe(this.elJpegQP, 'keyup', function(){
            if(this.value == '') return;
            var val = parseInt(this.value, 10);
            if(isNaN(val)) this.value = '';
            else if(val > _self.JPEG_Q_MAX) this.value = _self.JPEG_Q_MAX;
            else this.value = val;
            if(!this.value == '' && this.value >= _self.JPEG_Q_MIN && this.value <= _self.JPEG_Q_MAX){
                _calCanvasImageSize();
            }
        });
        $tx.observe(this.elJpegQP, 'blur', function(){
            if(this.value == '' || this.value < _self.JPEG_Q_MIN){
                this.value = _self.JPEG_Q_MIN;
                _calCanvasImageSize();
            }
        });
        function setImgSize(width, height){
            var _ratio = _self.elImgRatio.checked;
            var _width = parseInt(width, 0);
            var _height = parseInt(height, 0);
            _width = isNaN(_width)?'':_width;
            _height = isNaN(_height)?'':_height;

            if(_ratio && _self._origin){
                _self._img_tmp.removeAttribute('width');
                _self._img_tmp.removeAttribute('height');
                _self._img_tmp.style.width = '';
                _self._img_tmp.style.height = '';
                if(width != null) {
                    _self._img_tmp.style.width = parseInt(width, 10) + 'px';
                    _self._img_tmp.width = width;
                }
                if(height != null) {
                    _self._img_tmp.style.height = parseInt(height, 10) + 'px';
                    _self._img_tmp.height = height;
                }
                _width = _self._img_tmp.width;
                _height = _self._img_tmp.height;
            }else{
                if(width == null) _width = null; 
                if(height == null) _height = null;
            }
            if(_width != null) _self.elImgWidth.value = _width;
            if(_height != null) _self.elImgHeight.value = _height;
            _width = _self.elImgWidth.value;
            _height = _self.elImgHeight.value;
            if(_self.currentElem){                
                _self.currentElem.width = _width;
                _self.currentElem.style.width = _width + 'px';
                _self.currentElem.height = _height;
                _self.currentElem.style.height = _height + 'px';
            }
            if(_self._img){
                if(!_ratio) _self._img.width = _width;
                else _self._img.removeAttribute('width');
                _self._img.height = _height;
            }
            _calCanvasImageSize();
        }

        var _width_up = $tom.collect(_elMenu, '.btn_width_up'),
            _width_down = $tom.collect(_elMenu, '.btn_width_down'),
            _height_up = $tom.collect(_elMenu, '.btn_height_up'),
            _height_down = $tom.collect(_elMenu, '.btn_height_down'); 
        
        $tx.observe(this.elImgWidth, 'blur', function(){
            setImgSize(this.value, null);
        });
        $tx.observe(this.elImgWidth, 'keyup', function(){
            this.value = parseInt(this.value, 10)
            setImgSize(this.value, null);
        });
        $tx.observe(this.elImgRatio, 'click', function(){
            if(this.checked && _self.elImgHeight.value) setImgSize(null, _self.elImgHeight.value);
            // _self.elImgWidth.value = _self._origin?_self._origin.width:'';
            // _self.elImgHeight.value = _self._origin?_self._origin.height:'';
        });
        $tx.observe(this.elReset, 'click', function(){  
            var _width = _self._origin?_self._origin.width:'';
            var _height = _self._origin?_self._origin.height:'';
            setImgSize(_width, _height);
            // _self.elImgWidth.value = _self._origin?_self._origin.width:'';
            // _self.elImgHeight.value = _self._origin?_self._origin.height:'';
            // var _width = _self.elImgWidth.value;
            // var _height = _self.elImgHeight.value;
            // if(_self.currentElem){
            //     _self.currentElem.width = _width;
            //     _self.currentElem.style.width = _width + 'px';
            //     _self.currentElem.height = _height;
            //     _self.currentElem.style.height = _height + 'px';
            // }
            // if(_self._img){
            //     _self._img.width = _width;
            //     _self._img.height = _height;
            // }
            // _calCanvasImageSize();
        });
        $tx.observe(_width_up, 'click', function(){
            _self.elImgWidth.value = (_self.elImgWidth.value||0) - 0 + 1;
            setImgSize(_self.elImgWidth.value, null);
        });        
        $tx.observe(_width_down, 'click', function(){
            var _val = (_self.elImgWidth.value||0) - 1;
            _val = _val < 0?0:_val;
            _self.elImgWidth.value = _val;
            setImgSize(_self.elImgWidth.value, null);
        });
        $tx.observe(this.elImgHeight, 'blur', function(){
            setImgSize(null, this.value);
        });
        $tx.observe(this.elImgHeight, 'keyup', function(){
            setImgSize(null, this.value);
        });
        $tx.observe(_height_up, 'click', function(){
            _self.elImgHeight.value = (_self.elImgHeight.value||0) - 0 + 1;
            setImgSize(null, _self.elImgHeight.value);
        });        
        $tx.observe(_height_down, 'click', function(){
            var _val = (_self.elImgHeight.value||0) - 1;
            _val = _val < 0?0:_val;
            _self.elImgHeight.value = _val;
            setImgSize(null, _self.elImgHeight.value);
        });

        // var _align = $tom.collect(_elMenu, '.imageAlign .g_align'),
        // _align_btn = $tom.collect(_elMenu, '.imageAlign button.btn_align'),
        // _align_list = $tom.collect(_elMenu, '.imageAlign .align_option');
        // var _align_arr = $('li', _align_list);
        // this._align_map = {
        //     '-':_align_arr[0],
        //     'left':_align_arr[1],
        //     'center':_align_arr[2],
        //     'right':_align_arr[3]
        // };
        // this._align_text = $('.align_text', _align);

        // function __align_click(){
        //     _self._closeSubLayer(_align_btn);
        //     if($tx.hasClassName(_align_btn, 'btn_down_arrow1')){
        //         $tx.removeClassName(_align_btn, 'btn_down_arrow1');
        //         $tx.addClassName(_align_btn, 'btn_up_arrow1');
        //         $tx.show(_align_list);
        //     } else {
        //         $tx.removeClassName(_align_btn, 'btn_up_arrow1');
        //         $tx.addClassName(_align_btn, 'btn_down_arrow1');
        //         $tx.hide(_align_list);
        //     }
        // }
        // $tx.observe(_align, 'click', __align_click);
        // // $tx.observe(_align_btn, "click", function(){
        // //     __align_click();
        // // });
        // $('li', _align_list).on('click', function(){
        //     _self._setAlign(this);
        //     __align_click();
        // });
        this.btn_border_style = $('button[name=btn_border_style]', _elMenu);
        this.border_list = $('.line_style_option', _elMenu);
        this.txt_border_line = $('input[name=txt_border_line]', _elMenu);
        this.btn_line_up = $('.btn_border_up', _elMenu);
        this.btn_line_dn = $('.btn_border_down', _elMenu);
        this.txt_border_color = $('input[name=txt_border_color]', _elMenu);
        this.btn_line_color = $('.btn_color', _elMenu);
        this.span_line_color = $('.btn_color span', _elMenu);
        this.line_color_pal = $('.tx-colorpallete', _elMenu);
        this.g_line = $('.line .g_line', _elMenu);
        this._line = {};
        var _bs_map = $('li', this.border_list)
        this.border_style_map = {
            'solid':_bs_map[0],
            'dotted':_bs_map[1],
            'double':_bs_map[2]
        };

        this._getBorderStyle = function(){
            var _l = _self._line;
            var _border = (_l.color && _l.width && _l.style?_l.width + 'px ' + _l.style + ' ' + _l.color:'');
            return _border;
        }
        function changeBorderStyle(){            
            if(_self.currentElem) _self.currentElem.style.border = _self._getBorderStyle();
            if(_self._img) _self._img.style.border = _self._getBorderStyle();
        }

        this._closeSubLayer = function(_cur) {
            if (_cur != _self.btn_line_color && _self.linePallete_c) _self.linePallete_c.hide();
            if (_cur != _self.btn_border_style) {
                $(_self.btn_border_style).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                $tx.hide(_self.border_list.get(0));
            }
            // if (_cur != _align_btn) {
            //     $(_align_btn).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
            //     $tx.hide(_align_list);
            // }
        }
        var validCheck = {
            calculate: function(type, operand) {
                var value = (type == 'line' ? (_self._line.width ? _self._line.width : 0) :
                    '');
                var max = (type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                    '');
                value = parseInt(value);
                if (isNaN(value)) value = 1;
                if (value + operand > max || value + operand < 0) {
                    if (type != 'line' && type != 'padding') alert(TXMSG("@table.alert"));
                    return value;
                }
                value = value + operand;
                if (value < 0) value = 0;
                return value.toString();
            },
            getValidValue: function(type, value, previousValue, obj) {
                var max = (type == 'row' ? Trex.Menu.Table.MAX_ROW :
                    type == 'col' ? Trex.Menu.Table.MAX_COL :
                    type == 'line' ? Trex.Menu.Table.MAX_LINE_WIDTH :
                    type == 'padding' ? Trex.Menu.Table.MAX_PADDING :
                    '');
                if (isNaN(value)) return previousValue;
                if (value < 0 || value > max) {
                    value = value > max ? max : previousValue;
                    if (obj) obj.value = value;
                    alert(Trex._I18N.g('number.alert', '1', max.toString(), '1 이상 ' + max + ' 이하의 숫자만 입력 가능합니다.'));
                }
                return value;
            },
            validColor: function(type, color, previousValue) {
                var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
                if (m === _NULL || color.length > 8) {
                    return previousValue;
                }
                if (m[1].length == 3) {
                    //return "#" + m[1] + m[1];
                    return "#" + m[1].toLowerCase();
                } else {
                    return "#" + m[1].toLowerCase();
                }
            }
        };
        
        //테두리 스타일
        this.btn_border_style.on('click', function() {
            _self._closeSubLayer(_self.btn_border_style);
            if ($(this).hasClass('btn_down_arrow1')) {
                $(this).removeClass('btn_down_arrow1').addClass('btn_up_arrow1');
                $tx.show(_self.border_list.get(0));
            } else {
                $(this).removeClass('btn_up_arrow1').addClass('btn_down_arrow1');
                $tx.hide(_self.border_list.get(0));
            }
            return false;
        });
        this.btn_border_style.closest('span').on('click', function() {
            _self.btn_border_style.click();
        });
        this._setBorderList = function(_li){
            var span = $(_self.g_line);
            var cls = $(_li).attr('class');
            var style = $(_li).data('style');

            if (!span.find('.line_style').hasClass(cls)) {
                span.find('.line_style').remove();
                span.prepend('<span class="line_style ' + cls + '"></span>');
            }
            _self._line.style = style;            
        }
        this.border_list.find('li').on('click', function(el) {
            _self._setBorderList(this);
            _self.btn_border_style.click();
            changeBorderStyle();
            el.preventDefault();
        });
        // 테두리 두께
        this.setLineColor = function() {
            if (_self._line.width != "" && _self._line.width != "0" && !_self._line.color) {
                _self._line.color = "#ccc";
                _self.txt_border_color.val(_self._line.color);
            } else if (_self._line.width == "" || _self._line.width == "0") {
                //_self._line.color = "";
                //_self.txt_border_color.val(_self._line.color);
            }
            if (!_self._line.color) {
                _self.span_line_color.css('background', '#dfeef9');
            } else {
                _self.span_line_color.css('background', _self._line.color);
            }
            changeBorderStyle();
        }

        this.setLineWidth = function() {
            if (_self._line.color != "" && !_self._line.width) {
                _self._line.width = "1";
                _self.txt_border_line.val(_self._line.width);
            } else if (_self._line.color == "" && _self._line.width != "0") {
                //_self._line.width = "";
                //_self.txt_border_line.val(_self._line.width);
            }
            changeBorderStyle();
        }
        // 테두리 두께
        this.txt_border_line.on('blur', function() {
            this.value = _self._line.width = validCheck.getValidValue('line', this.value, '', this);
            _self.setLineColor();
        });
        this.txt_border_line.on('keyup', function() {
            this.value = _self._line.width = validCheck.getValidValue('line', this.value, '', this);
            _self.setLineColor();
        });
        this.btn_line_up.on('click', function() {
            _self.txt_border_line.get(0).value = _self._line.width = validCheck.calculate('line', 1);
            _self.setLineColor();
        });
        this.btn_line_dn.on('click', function() {
            _self.txt_border_line.get(0).value = _self._line.width = validCheck.calculate('line', -1);
            _self.setLineColor();
        });
        // 테두리 색
        this.txt_border_color.on('blur', function() {
            this.value = _self._line.color = validCheck.validColor('line', this.value, '');
            if (this.value == '') {
                _self.span_line_color.css('background', '#dfeef9');
            } else {
                _self.span_line_color.css('background', this.value);
            }
            _self.setLineWidth();
        });
        this.btn_line_color.on('click', function() {
            _self._closeSubLayer(_self.btn_line_color);
            if (_self.linePallete_c == _NULL) {
                if ($tx.ltie8) {
                    $('.tx-image-property', _elMenu).append(_self.line_color_pal);
                    $(_self.line_color_pal).css('top', '80px');
                    $(_self.line_color_pal).css('right', '10px');
                }
                _self.linePallete_c = _self.createColorPallete(_self.line_color_pal.get(0), function(color) {
                    color = color.toLowerCase();
                    _self._line.color = color;
                    _self.txt_border_color.val(color);
                    if (color == '') {
                        _self.span_line_color.css('background', '#dfeef9');
                    } else {
                        _self.span_line_color.css('background', color);
                    }
                    _self.setLineWidth();
                }, false);
            }
            $tx.hide(_self.border_list.get(0));
            _self.linePallete_c.toggle();
            _self.linePallete_c.remainColor(_self.txt_border_color.val());
            return false;
        });

        if(this.elOpacity){
            $tx.observe(this.elOpacity, 'click', function(){
                if(this.checked){
                    $tx.addClassName(_self.elWrapper, 'opacity8');
                    $tx.addClassName(_self.elEditorBlockUI, 'opacity1');
                }else{
                    $tx.removeClassName(_self.elWrapper, 'opacity8');
                    $tx.removeClassName(_self.elEditorBlockUI, 'opacity1');
                }
            });
        }

        this.btn_OK = $tom.collect(_elMenu, '.layer_bottom .btn_ok');
        this.btn_CANCEL = $tom.collect(_elMenu, '.layer_bottom .btn_cancel');
        this.btn_paste_title = $tom.collect(_elMenu, '.layer_bottom .btn_paste_title');
        this.btn_IMG = $tom.collect(_elMenu, '.layer_bottom .btn_img');
        this.btn_HTML = $tom.collect(_elMenu, '.layer_bottom .btn_html');
        this.btn_PLAIN = $tom.collect(_elMenu, '.layer_bottom .btn_plain');
        this.radio_HTML = $tom.collect(_elMenu, '.paste_type_html');
        this.radio_IMG = $tom.collect(_elMenu, '.paste_type_image');
        this.radio_TEXT = $tom.collect(_elMenu, '.paste_type_text');
        this.disabled_wrap = $('.disabled_area', _elMenu);
        this.paste_radio = $('dd.paste_type input', _elMenu);

        function getImageInfo(){
            var __info = {
                'width':_self.elImgWidth.value,
                'height': _self.elImgHeight.value,
                // 'align': _self._align,
                'border': _self._getBorderStyle()
            };
            if(_self.elJpegQ.checked){
                var q = (_self.elJpegQP.value||70) / 100;
                __info.src = _self.tmp_canvas.toDataURL('image/jpeg', q);
            }
            return __info;
        }
        
        $tx.observe(this.btn_OK, "click", function(ev) {
            if(this.pasteTypeRadio){
                _self.canvas.focus();
                if(this.paste_radio[0]&&this.paste_radio[0].checked) this.callback.html(this._htmlcode);
                else if(this.paste_radio[1]&&this.paste_radio[1].checked) this.callback.image(getImageInfo());
                else if(this.paste_radio[2]&&this.paste_radio[2].checked) this.callback.plain(this._plaincode);
            }else if(this.infotype != 'property' && this.callback && this.callback.image) this.callback.image(getImageInfo());
            else if(this.callback) this.callback();
            if(_self.infotype == 'property') _self.canvas.history.saveHistory();
            this.clearLayer();
            this.hidePopup();
            $tx.stop(ev);
        }.bind(this));

        $tx.observe(this.btn_IMG, "click", function(ev) {
            if(this.callback && this.callback.image) this.callback.image(getImageInfo());
            this.clearLayer();
            this.hidePopup();
            $tx.stop(ev);
        }.bind(this));

        $tx.observe(this.btn_HTML, "click", function(ev) {
            if(this.callback && this.callback.html) this.callback.html(this._htmlcode);
            this.clearLayer();
            this.hidePopup();
            $tx.stop(ev);
        }.bind(this));

        $tx.observe(this.btn_PLAIN, "click", function(ev) {
            if(this.callback && this.callback.plain) this.callback.plain(this._plaincode);
            this.clearLayer();
            this.hidePopup();
            $tx.stop(ev);
        }.bind(this));

        this.paste_radio.on('click', function(ev){
            _self._closeSubLayer(null);
            _self.disabled_wrap[(this.value == 'image'?'hide':'show')]();
            var e = ev.originalEvent;
            var _this = this;
            setTimeout(function(){_this.checked = true;}, 0);
            $tx.stop(e);
            return false;
        });
        
        $tx.observe(this.btn_CANCEL, 'click', function(ev) {
            if(_self.currentElem && _self._originImage){
                var _e = _self.currentElem;
                var _o = _self._originImage;
                if(_o.src) _e.src = _o.src;
                if(_o.width) _e.width = _o.width;
                else _e.removeAttribute('width');
                if(_o.height) _e.height = _o.height;
                else _e.removeAttribute('height');
                // if(_self._img_parent && _o.align) _self._img_parent.align = _o.align;
                // else _e.removeAttribute('align');
                _e.style.width = _o.style.width;
                _e.style.height = _o.style.height;
                // if(_self._img_parent) _self._img_parent.style.textAlign = _o.style.textAlign;
                _e.style.border = _o.style.border;
            };
            this.clearLayer();
            this.hidePopup();
            $tx.stop(ev);
        }.bind(this));
        if(this.infotype == 'paste' && !this.pasteTypeRadio){
            this.btn_CANCEL.style.marginLeft = '20px';
        }
        this._isInit = true;
    },
    _setAlign:function(_li){
        var _self = this;
        var _align = $tom.collect(this.elWrapper, '.imageAlign .g_align');
        var span = $('.align_text', _align);
        var txt = $(_li).html();
        var style = $(_li).data('style');
        span.html(txt);
        _self._align = style;
        if(_self._img_parent) _self._img_parent.style.textAlign = _self._align;
        if( _self._img_dd) _self._img_dd.style.textAlign = _self._align;        
    },
    observeEvent:function(){
        //BlockUI 이벤트 bind
        $(this.elEditorBlockUI).on('mousedown', function(e) { return false; });
    },
    hidePopup:function(){
        $tx.hide(this.elEditorBlockUI);
        $tx.hide(this.elWrapper);
        this.callback = null;
        this._originImage = null;
        $tx.removeClassName(this.elWrapper, 'opacity8');
        $tx.removeClassName(this.elEditorBlockUI, 'opacity1');
        if(this.elOpacity) this.elOpacity.checked = false;
    },
    clearLayer:function(){
        var _self = this;
        _self._img_tmp.src = '';
        _self._img_tmp.removeAttribute('width');
        _self._img_tmp.removeAttribute('height');
        _self._img_tmp.style.width = '';
        _self._img_tmp.style.height = '';
        if(_self._img){
            _self._img.src = '';
            _self._img.removeAttribute('width');
            _self._img.removeAttribute('height');
            _self._img.style.width = '';
            _self._img.style.height = '';
            _self._img.style.border = '';
        }
        _self._clearLayer = true;
    },
    showPopup:function(elem, callback, _img, _html, _plain, _size){
        //BlockUI 처리
        var _self = this;
        _self._htmlcode = _html;
        _self._plaincode = _plain?_plain.replace(/\t/g, '    ').replace(/  /g, '&nbsp; ').replace(/\n/g, '<br>'):'';
        _self.currentElem = elem;
        _self.callback = callback;
        $tx.show(_self.elEditorBlockUI);
        if(!_self._isInit) _self._init();
        if(!this._clearLayer) this.clearLayer();
        this._clearLayer = false;
        _self._origin = null;
        _self._line = {color:'', width:'', style:'solid'};
        _self.txt_border_color.val(_self._line.color);
        _self.span_line_color.css('background', '#dfeef9');
        _self.txt_border_line.val(_self._line.width);
        _self._setBorderList($('li', _self.border_list)[0]);        
        _self._origin_file_size = _size;
        if(this.infotype == 'property'){
            var _w = _self._img_parent = $tom.find(elem, "%paragraph");
            _self._originImage = {
                src:elem.src,
                width:elem.width,
                height:elem.height,
                // align:_w?_w.align:'',
                style:{
                    width:elem.style.width,
                    height:elem.style.height,
                    // textAlign:_w?_w.style.textAlign:'',
                    border:elem.style.border
                }
            };
            try{
                if(_self._originImage.src.search(/^data:/i) != -1 && _size == null){
                    _self._origin_file_size = _self._originImage.src.split(',')[1].length * (3/4);
                }
            }catch(e){}            

            _self.elImgWidth.value = parseInt(_self._originImage.style.width||_self._originImage.width, 10);
            _self.elImgHeight.value = parseInt(_self._originImage.style.height||_self._originImage.height, 10);
            _self.elImgRatio.checked = true;
            // var _align = (_self._originImage.style.textAlign||_self._originImage.align||'-').toLowerCase();
            // if(_self._align_map[_align]) _self._setAlign(_self._align_map[_align]);
            // else _self._setAlign(_self._align_map['-']);
    
            var _bw = elem.style.borderWidth;
            if(_bw != null) _bw = parseInt(_bw, 10);
            if(_bw != null && !isNaN(_bw)){
                _self._line.width = _bw;
                _self.txt_border_line.val(_bw);
            }
            var _bc = elem.style.borderColor;
            var _rgb = /rgb\s*\(\s*(\d+)\s*,\s*(\d+),\s*(\d+)\s*\)\s*/i
            if(_bc){
                if(_bc.search(_rgb) != -1){
                    var _match = _bc.match(_rgb);
                    if(_match){
                        _bc = "#";
                        _bc += parseInt(_match[1], 10).toString(16).fixed_length(2, "0");
                        _bc += parseInt(_match[2], 10).toString(16).fixed_length(2, "0");
                        _bc += parseInt(_match[3], 10).toString(16).fixed_length(2, "0");
                    }                
                }
                _self._line.color = _bc;
                _self.txt_border_color.val(_self._line.color);
                _self.span_line_color.css('background', _self._line.color);
            }
            var _bs = elem.style.borderStyle;
            if(_bs && _self.border_style_map[_bs]){
                _self._line.style = _bs;
                _self._setBorderList(_self.border_style_map[_bs]);
            }
            /**
             * 같은 도메인의 이미지만 Canvas가 처리할 수 있음.
             */
            if(_self._originImage.src.search(/^data:/i) == -1 && _self._originImage.src.toLowerCase().indexOf(document.location.hostname) == -1){
                _self.qualityWrap.style.display = 'none';
            }else if(this.tmp_canvas){
                _self.qualityWrap.style.display = '';
            }
        } else {
            _self._originImage = null;
            // _self.elImgWidth.value = '';
            // _self.elImgHeight.value ='';
            _self.elImgRatio.checked = true;
            // _self._setAlign(_self._align_map['-']);

            if(_self.pasteTypeRadio){
                _self.btn_OK.style.display = '';
                _self.paste_radio[0].checked = true;
                if(_img && _html){
                    _self.radio_HTML.style.display = '';
                    _self.radio_IMG.style.display = '';
                    _self.radio_TEXT.style.display = (_plain?'':'none');
                    _self.disabled_wrap.show();
                }else{
                    _self.paste_radio[1].checked = true;
                    _self.radio_HTML.style.display = 'none';
                    _self.radio_IMG.style.display = '';
                    _self.radio_TEXT.style.display = 'none';
                    _self.disabled_wrap.hide();
                }
            }else{
                if(_img && _html){
                    if(_self.btn_paste_title) _self.btn_paste_title.style.display = '';
                    _self.btn_IMG.style.display = '';
                    _self.btn_HTML.style.display = '';
                    _self.btn_PLAIN.style.display = (_plain?'':'none');
                    _self.btn_OK.style.display = 'none';
                }else{
                    if(_self.btn_paste_title) _self.btn_paste_title.style.display = 'none';
                    _self.btn_IMG.style.display = 'none';
                    _self.btn_HTML.style.display = 'none';
                    _self.btn_PLAIN.style.display = 'none';
                    _self.btn_OK.style.display = '';
                }
            }
        }

        _self.elJpegQ.checked = false;
        _self.elJpegQP.value = '70';
        _self.elJpegQWrap.style.display = 'none';
        _self.img_size.innerHTML = '-';

        _self._closeSubLayer(null);
        var $container = $(_self.canvas.elContainer),
            $popup = $(_self.elWrapper);

        var canvas_w = $container.outerWidth(),
            canvas_h = $container.outerHeight(),
            popup_w = $popup.outerWidth(),
            popup_h = $popup.outerHeight(),
            left = (Math.ceil(canvas_w / 2) - Math.ceil(popup_w / 2)) + $container.position().left,
            top = (Math.ceil(canvas_h / 2) - Math.ceil(popup_h / 2)) + $container.position().top;

        $popup.css({ 'top': top, 'left': left });
        $tx.show(_self.elWrapper);
        if(this.infotype == 'property'){
            _self._img_tmp.src = elem.src;            
        }else{
            if(_self._img) _self._img.src = _img.src;
            _self._img_tmp.src = _img.src;
        }
    },
    createColorPallete: function(element, fn, inputHidden, elInput, elPreview) {
        var self = this;
        var pallete = new Trex.Menu.ColorPallete({
            el: element,
            thumbs: Trex.__CONFIG_COMMON.thumbs,
            colorInputHidden: inputHidden
        });
        pallete.setCommand(fn);
        return pallete;
    }
});
/**
 * Created by sungwon on 14. 5. 9.
 */
TrexConfig.add({
    canvas: {
        exitEditor: {
            desc: Trex._I18N.g('exitEditor_desc', '에디터 영역 : 에디터 영역에서 빠져 나오시려면 Shift+ESC키를 누르세요'),
            hotKey: {
                shiftKey: true,
                keyCode: 27
            },
            nextElement: null
        }
    }
}, null);
Trex.module("exit Editor", function(editor, toolbar, sidebar, canvas, config) {
    var _wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
    var _elWysiwyg = _wysiwygPanel.el;
    var _config = config.canvas.exitEditor;

    function isSearchElement(searchElement) {
        return !($tx.getStyle(searchElement, 'display') == 'none' ||
            $tx.getStyle(searchElement, 'visibility') == 'hidden' ||
            searchElement.tagName.toLowerCase() === 'input' && searchElement.type == 'hidden' ||
            searchElement.tagName.toLowerCase() === 'a' && (searchElement.href || '').trim() == '' ||
            searchElement.offsetLeft <= 0);
    }

    function execHandler(e) {
        try {
            if (_config.nextElement) {
                _config.nextElement.focus();
                return;
            }
            var el = _elWysiwyg;
            var pattern = 'button,a,input,select,object';
            var searchElement = null;
            var els = null;
            do {
                var next = $tom.nextContent(el, '#element');
                if ($tom.kindOf(next, pattern)) {
                    searchElement = next;
                } else {
                    els = $tom.descendants(next, pattern);
                    searchElement = els.find(isSearchElement);
                }
                if (searchElement) {
                    if (!isSearchElement(searchElement))
                        searchElement = null;
                }
                el = next;
            } while (!searchElement && el);
            if (searchElement)
                searchElement.focus();
            else
                canvas.getProcessor().blur();
        } catch (e) {
            canvas.getProcessor().blur();
        }
    }

    //_elWysiwyg.title = _config.desc;

    canvas.observeKey(_config.hotKey, function(ev) {
        $tx.stop(ev);
        execHandler(ev);
    });
});

/**
 * 번역1
 */
TrexConfig.addTool(
    "translate", {
        disabledonmobile: _TRUE,
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _FALSE
    }    
);

Trex.Tool.Translate = Trex.Class.create({
    $const: {
        __Identity: 'translate'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,
            function() {
                var _canvas = _editor.getCanvas();
                var wysiwygPanel = _canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE)
                var doc = wysiwygPanel.getDocument();
                var win = doc.parentWindow || doc.defaultView;
                var range = null, txt, html;
                var _sel = win.getSelection || win.document.getSelection;
                if(_sel){
                    var sel = _sel();
                    txt = sel + '';
                    range = sel.getRangeAt(0);
                    var _clone = range.cloneContents();
                    var div = document.createElement('div');
                    div.appendChild(_clone);
                    html = div.innerHTML;
                    var tmp = $('<div></div>');
                    if($tx.msie){
                        tmp.html(html.replace(/<div/gi, "<span").replace(/<\/div>/gi, "</span>").replace(/><br\/?></gi, '><'));
                        $("p", tmp).css({"display":"inline"});
                    }else{
                        tmp.html(html.replace(/<p/gi, "<div").replace(/<\/p>/gi, "</div>"));
                    }
                    txt = (tmp[0].innerText||tmp[0].textContent||txt);
                }else if(win.document.selection){
                    range = win.document.selection.createRange().text;
                    txt = range.text;
                    html = range.htmlText;
                }
                var _range = _canvas.getProcessor().getSelectionRange(_canvas);
                _canvas.translateFn(txt, html, function(result){
                    if(!result) return;
                    _canvas.focus();
                    _canvas.execute(
                        function(processor) {
                            processor.pasteHtml(result, _canvas, _range);
                        }
                    );
                }, range);
            }
        );
    }
});

/**
 * Cleanup
 */
TrexConfig.addTool(
    "cleanup", {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _FALSE
    }
);

Trex.Tool.Cleanup = Trex.Class.create({
    $const: {
        __Identity: 'cleanup'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var _editor = this.editor;
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,
            function() {
                if(!confirm(Trex._I18N.g('cleanup.confirm', 'Tag를 정리합니다.\n시간이 오래 걸릴 수 있습니다\n실행하시겠습니까?'))) return;

                var _canvas = _editor.getCanvas();
                var wysiwygPanel = _canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE)
                var doc = wysiwygPanel.getDocument();
                var _win_doc = window.document;
                // if(!_progress){
                    var _progress = _win_doc.createElement('div');
                    _win_doc.body.appendChild(_progress);
                    _progress.className = 'cleanupProgress';
                    _progress.innerHTML = '<div class="bg"></div><div class="icon"></div><div class="desc"><span>' 
                        + Trex._I18N.g('cleanup.desc', 'Tag를 정리중 입니다. 시간이 오래 걸릴 수 있습니다. 잠시만 기다려 주세요.') + '</span></div>'
                // }
                setTimeout(function(){
                    var _html = doc.body.innerHTML;
                    doc.body.innerHTML = '';
                    _html = Trex.KEditor.cleanupHTML(_html);
                    doc.body.innerHTML = _html;
                    _canvas.history.saveHistory();
                    $(_progress).remove();
                    _editor.showCleanupBtn(false);
                }, 500);
            }
        );
    }
});

if (typeof Editor !== "undefined") {
    //Editor.version = "7.3.47";
    Editor.version = "1.0.05_LGE";
}
try {
    EditorJSLoader.readyState = "complete";
    EditorJSLoader.finish();
} catch (s) {}